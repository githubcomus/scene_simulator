// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_game_2eproto__INCLUDED
#define PROTOBUF_game_2eproto__INCLUDED

#pragma warning(disable:4456)
#pragma warning(disable:4146)
#pragma warning(disable:4647)
#pragma warning(disable:4668)
#pragma warning(disable:4125)
#pragma warning(disable:4800)
#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "the_public.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_game_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[63];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlayerRacingInfoImpl();
void InitDefaultsPlayerRacingInfo();
void InitDefaultsPlayerButtonKeyInfoImpl();
void InitDefaultsPlayerButtonKeyInfo();
void InitDefaultsPlayerEntityButtonInfoImpl();
void InitDefaultsPlayerEntityButtonInfo();
void InitDefaultsPlayerLocaionInfoImpl();
void InitDefaultsPlayerLocaionInfo();
void InitDefaultsPlayerStorageEntityImpl();
void InitDefaultsPlayerStorageEntity();
void InitDefaultsPlayerEntityStorageInfoImpl();
void InitDefaultsPlayerEntityStorageInfo();
void InitDefaultsPlayerInfoImpl();
void InitDefaultsPlayerInfo();
void InitDefaultsPlayerEnterViewImpl();
void InitDefaultsPlayerEnterView();
void InitDefaultsPlayerLeaveViewImpl();
void InitDefaultsPlayerLeaveView();
void InitDefaultsPlayerUpdateViewImpl();
void InitDefaultsPlayerUpdateView();
void InitDefaultsPlayerUpdateLocationImpl();
void InitDefaultsPlayerUpdateLocation();
void InitDefaultsUpdatePlayerDataRequestImpl();
void InitDefaultsUpdatePlayerDataRequest();
void InitDefaultsUpdateLocationRequestImpl();
void InitDefaultsUpdateLocationRequest();
void InitDefaultsChangeJiugonggeRequestImpl();
void InitDefaultsChangeJiugonggeRequest();
void InitDefaultsEntitySplineAloneImpl();
void InitDefaultsEntitySplineAlone();
void InitDefaultsEntityLaserImpl();
void InitDefaultsEntityLaser();
void InitDefaultsEntityMusicImpl();
void InitDefaultsEntityMusic();
void InitDefaultsEntityScenesTimelineGroupImpl();
void InitDefaultsEntityScenesTimelineGroup();
void InitDefaultsEntityScenesTimelineNodeImpl();
void InitDefaultsEntityScenesTimelineNode();
void InitDefaultsEntityScenesTimelineAlone_EntityMapEntry_DoNotUseImpl();
void InitDefaultsEntityScenesTimelineAlone_EntityMapEntry_DoNotUse();
void InitDefaultsEntityScenesTimelineAloneImpl();
void InitDefaultsEntityScenesTimelineAlone();
void InitDefaultsEntityScenesTimelineTotal_GroupMapEntry_DoNotUseImpl();
void InitDefaultsEntityScenesTimelineTotal_GroupMapEntry_DoNotUse();
void InitDefaultsEntityScenesTimelineTotalImpl();
void InitDefaultsEntityScenesTimelineTotal();
void InitDefaultsEntityMoveTimelinePointImpl();
void InitDefaultsEntityMoveTimelinePoint();
void InitDefaultsEntityMoveTimeline_PointMapEntry_DoNotUseImpl();
void InitDefaultsEntityMoveTimeline_PointMapEntry_DoNotUse();
void InitDefaultsEntityMoveTimelineImpl();
void InitDefaultsEntityMoveTimeline();
void InitDefaultsEntityPythonInfoImpl();
void InitDefaultsEntityPythonInfo();
void InitDefaultsEntityCommandAutoImpl();
void InitDefaultsEntityCommandAuto();
void InitDefaultsEntityCommandCommandImpl();
void InitDefaultsEntityCommandCommand();
void InitDefaultsEntityCommandInteractiveImpl();
void InitDefaultsEntityCommandInteractive();
void InitDefaultsEntityCommandTriggerImpl();
void InitDefaultsEntityCommandTrigger();
void InitDefaultsEntityCommandInfoImpl();
void InitDefaultsEntityCommandInfo();
void InitDefaultsEntityTransformTimelinePointImpl();
void InitDefaultsEntityTransformTimelinePoint();
void InitDefaultsEntityTransformTimeline_PointMapEntry_DoNotUseImpl();
void InitDefaultsEntityTransformTimeline_PointMapEntry_DoNotUse();
void InitDefaultsEntityTransformTimelineImpl();
void InitDefaultsEntityTransformTimeline();
void InitDefaultsEntityChildInfoImpl();
void InitDefaultsEntityChildInfo();
void InitDefaultsEntityMMeshInfoImpl();
void InitDefaultsEntityMMeshInfo();
void InitDefaultsEntityImageInfoImpl();
void InitDefaultsEntityImageInfo();
void InitDefaultsEntityInfoImpl();
void InitDefaultsEntityInfo();
void InitDefaultsEntityEnterViewImpl();
void InitDefaultsEntityEnterView();
void InitDefaultsEntityUpdateViewImpl();
void InitDefaultsEntityUpdateView();
void InitDefaultsEntityLeaveViewImpl();
void InitDefaultsEntityLeaveView();
void InitDefaultsEntityAddRequestImpl();
void InitDefaultsEntityAddRequest();
void InitDefaultsEntityRemoveRequestImpl();
void InitDefaultsEntityRemoveRequest();
void InitDefaultsEntityUpdateRequestImpl();
void InitDefaultsEntityUpdateRequest();
void InitDefaultsEntityOperationValue1Impl();
void InitDefaultsEntityOperationValue1();
void InitDefaultsEntityOperationValue2Impl();
void InitDefaultsEntityOperationValue2();
void InitDefaultsEntityOperationAloneImpl();
void InitDefaultsEntityOperationAlone();
void InitDefaultsEntityOperationTotalImpl();
void InitDefaultsEntityOperationTotal();
void InitDefaultsOverallSituationSkyInfoImpl();
void InitDefaultsOverallSituationSkyInfo();
void InitDefaultsEntityMeshChildInfoImpl();
void InitDefaultsEntityMeshChildInfo();
void InitDefaultsEntityMeshMasterInfoImpl();
void InitDefaultsEntityMeshMasterInfo();
void InitDefaultsOverallSituationData_ActorListEntry_DoNotUseImpl();
void InitDefaultsOverallSituationData_ActorListEntry_DoNotUse();
void InitDefaultsOverallSituationDataImpl();
void InitDefaultsOverallSituationData();
void InitDefaultsOverallSituationDataRequestImpl();
void InitDefaultsOverallSituationDataRequest();
void InitDefaultsOverallSituationDataResponse_ActorListEntry_DoNotUseImpl();
void InitDefaultsOverallSituationDataResponse_ActorListEntry_DoNotUse();
void InitDefaultsOverallSituationDataResponseImpl();
void InitDefaultsOverallSituationDataResponse();
void InitDefaultsEventCommandInfoImpl();
void InitDefaultsEventCommandInfo();
void InitDefaultsEventInfoImpl();
void InitDefaultsEventInfo();
void InitDefaultsTimelineOneFrameOneEntityDataImpl();
void InitDefaultsTimelineOneFrameOneEntityData();
void InitDefaultsTimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUseImpl();
void InitDefaultsTimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse();
void InitDefaultsTimelineOnewFrameAllEntityDataImpl();
void InitDefaultsTimelineOnewFrameAllEntityData();
void InitDefaultsTimelineOneSecondAllFrameDataImpl();
void InitDefaultsTimelineOneSecondAllFrameData();
inline void InitDefaults() {
  InitDefaultsPlayerRacingInfo();
  InitDefaultsPlayerButtonKeyInfo();
  InitDefaultsPlayerEntityButtonInfo();
  InitDefaultsPlayerLocaionInfo();
  InitDefaultsPlayerStorageEntity();
  InitDefaultsPlayerEntityStorageInfo();
  InitDefaultsPlayerInfo();
  InitDefaultsPlayerEnterView();
  InitDefaultsPlayerLeaveView();
  InitDefaultsPlayerUpdateView();
  InitDefaultsPlayerUpdateLocation();
  InitDefaultsUpdatePlayerDataRequest();
  InitDefaultsUpdateLocationRequest();
  InitDefaultsChangeJiugonggeRequest();
  InitDefaultsEntitySplineAlone();
  InitDefaultsEntityLaser();
  InitDefaultsEntityMusic();
  InitDefaultsEntityScenesTimelineGroup();
  InitDefaultsEntityScenesTimelineNode();
  InitDefaultsEntityScenesTimelineAlone_EntityMapEntry_DoNotUse();
  InitDefaultsEntityScenesTimelineAlone();
  InitDefaultsEntityScenesTimelineTotal_GroupMapEntry_DoNotUse();
  InitDefaultsEntityScenesTimelineTotal();
  InitDefaultsEntityMoveTimelinePoint();
  InitDefaultsEntityMoveTimeline_PointMapEntry_DoNotUse();
  InitDefaultsEntityMoveTimeline();
  InitDefaultsEntityPythonInfo();
  InitDefaultsEntityCommandAuto();
  InitDefaultsEntityCommandCommand();
  InitDefaultsEntityCommandInteractive();
  InitDefaultsEntityCommandTrigger();
  InitDefaultsEntityCommandInfo();
  InitDefaultsEntityTransformTimelinePoint();
  InitDefaultsEntityTransformTimeline_PointMapEntry_DoNotUse();
  InitDefaultsEntityTransformTimeline();
  InitDefaultsEntityChildInfo();
  InitDefaultsEntityMMeshInfo();
  InitDefaultsEntityImageInfo();
  InitDefaultsEntityInfo();
  InitDefaultsEntityEnterView();
  InitDefaultsEntityUpdateView();
  InitDefaultsEntityLeaveView();
  InitDefaultsEntityAddRequest();
  InitDefaultsEntityRemoveRequest();
  InitDefaultsEntityUpdateRequest();
  InitDefaultsEntityOperationValue1();
  InitDefaultsEntityOperationValue2();
  InitDefaultsEntityOperationAlone();
  InitDefaultsEntityOperationTotal();
  InitDefaultsOverallSituationSkyInfo();
  InitDefaultsEntityMeshChildInfo();
  InitDefaultsEntityMeshMasterInfo();
  InitDefaultsOverallSituationData_ActorListEntry_DoNotUse();
  InitDefaultsOverallSituationData();
  InitDefaultsOverallSituationDataRequest();
  InitDefaultsOverallSituationDataResponse_ActorListEntry_DoNotUse();
  InitDefaultsOverallSituationDataResponse();
  InitDefaultsEventCommandInfo();
  InitDefaultsEventInfo();
  InitDefaultsTimelineOneFrameOneEntityData();
  InitDefaultsTimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse();
  InitDefaultsTimelineOnewFrameAllEntityData();
  InitDefaultsTimelineOneSecondAllFrameData();
}
}  // namespace protobuf_game_2eproto
namespace Gamedata {
class ChangeJiugonggeRequest;
class ChangeJiugonggeRequestDefaultTypeInternal;
extern ChangeJiugonggeRequestDefaultTypeInternal _ChangeJiugonggeRequest_default_instance_;
class EntityAddRequest;
class EntityAddRequestDefaultTypeInternal;
extern EntityAddRequestDefaultTypeInternal _EntityAddRequest_default_instance_;
class EntityChildInfo;
class EntityChildInfoDefaultTypeInternal;
extern EntityChildInfoDefaultTypeInternal _EntityChildInfo_default_instance_;
class EntityCommandAuto;
class EntityCommandAutoDefaultTypeInternal;
extern EntityCommandAutoDefaultTypeInternal _EntityCommandAuto_default_instance_;
class EntityCommandCommand;
class EntityCommandCommandDefaultTypeInternal;
extern EntityCommandCommandDefaultTypeInternal _EntityCommandCommand_default_instance_;
class EntityCommandInfo;
class EntityCommandInfoDefaultTypeInternal;
extern EntityCommandInfoDefaultTypeInternal _EntityCommandInfo_default_instance_;
class EntityCommandInteractive;
class EntityCommandInteractiveDefaultTypeInternal;
extern EntityCommandInteractiveDefaultTypeInternal _EntityCommandInteractive_default_instance_;
class EntityCommandTrigger;
class EntityCommandTriggerDefaultTypeInternal;
extern EntityCommandTriggerDefaultTypeInternal _EntityCommandTrigger_default_instance_;
class EntityEnterView;
class EntityEnterViewDefaultTypeInternal;
extern EntityEnterViewDefaultTypeInternal _EntityEnterView_default_instance_;
class EntityImageInfo;
class EntityImageInfoDefaultTypeInternal;
extern EntityImageInfoDefaultTypeInternal _EntityImageInfo_default_instance_;
class EntityInfo;
class EntityInfoDefaultTypeInternal;
extern EntityInfoDefaultTypeInternal _EntityInfo_default_instance_;
class EntityLaser;
class EntityLaserDefaultTypeInternal;
extern EntityLaserDefaultTypeInternal _EntityLaser_default_instance_;
class EntityLeaveView;
class EntityLeaveViewDefaultTypeInternal;
extern EntityLeaveViewDefaultTypeInternal _EntityLeaveView_default_instance_;
class EntityMMeshInfo;
class EntityMMeshInfoDefaultTypeInternal;
extern EntityMMeshInfoDefaultTypeInternal _EntityMMeshInfo_default_instance_;
class EntityMeshChildInfo;
class EntityMeshChildInfoDefaultTypeInternal;
extern EntityMeshChildInfoDefaultTypeInternal _EntityMeshChildInfo_default_instance_;
class EntityMeshMasterInfo;
class EntityMeshMasterInfoDefaultTypeInternal;
extern EntityMeshMasterInfoDefaultTypeInternal _EntityMeshMasterInfo_default_instance_;
class EntityMoveTimeline;
class EntityMoveTimelineDefaultTypeInternal;
extern EntityMoveTimelineDefaultTypeInternal _EntityMoveTimeline_default_instance_;
class EntityMoveTimelinePoint;
class EntityMoveTimelinePointDefaultTypeInternal;
extern EntityMoveTimelinePointDefaultTypeInternal _EntityMoveTimelinePoint_default_instance_;
class EntityMoveTimeline_PointMapEntry_DoNotUse;
class EntityMoveTimeline_PointMapEntry_DoNotUseDefaultTypeInternal;
extern EntityMoveTimeline_PointMapEntry_DoNotUseDefaultTypeInternal _EntityMoveTimeline_PointMapEntry_DoNotUse_default_instance_;
class EntityMusic;
class EntityMusicDefaultTypeInternal;
extern EntityMusicDefaultTypeInternal _EntityMusic_default_instance_;
class EntityOperationAlone;
class EntityOperationAloneDefaultTypeInternal;
extern EntityOperationAloneDefaultTypeInternal _EntityOperationAlone_default_instance_;
class EntityOperationTotal;
class EntityOperationTotalDefaultTypeInternal;
extern EntityOperationTotalDefaultTypeInternal _EntityOperationTotal_default_instance_;
class EntityOperationValue1;
class EntityOperationValue1DefaultTypeInternal;
extern EntityOperationValue1DefaultTypeInternal _EntityOperationValue1_default_instance_;
class EntityOperationValue2;
class EntityOperationValue2DefaultTypeInternal;
extern EntityOperationValue2DefaultTypeInternal _EntityOperationValue2_default_instance_;
class EntityPythonInfo;
class EntityPythonInfoDefaultTypeInternal;
extern EntityPythonInfoDefaultTypeInternal _EntityPythonInfo_default_instance_;
class EntityRemoveRequest;
class EntityRemoveRequestDefaultTypeInternal;
extern EntityRemoveRequestDefaultTypeInternal _EntityRemoveRequest_default_instance_;
class EntityScenesTimelineAlone;
class EntityScenesTimelineAloneDefaultTypeInternal;
extern EntityScenesTimelineAloneDefaultTypeInternal _EntityScenesTimelineAlone_default_instance_;
class EntityScenesTimelineAlone_EntityMapEntry_DoNotUse;
class EntityScenesTimelineAlone_EntityMapEntry_DoNotUseDefaultTypeInternal;
extern EntityScenesTimelineAlone_EntityMapEntry_DoNotUseDefaultTypeInternal _EntityScenesTimelineAlone_EntityMapEntry_DoNotUse_default_instance_;
class EntityScenesTimelineGroup;
class EntityScenesTimelineGroupDefaultTypeInternal;
extern EntityScenesTimelineGroupDefaultTypeInternal _EntityScenesTimelineGroup_default_instance_;
class EntityScenesTimelineNode;
class EntityScenesTimelineNodeDefaultTypeInternal;
extern EntityScenesTimelineNodeDefaultTypeInternal _EntityScenesTimelineNode_default_instance_;
class EntityScenesTimelineTotal;
class EntityScenesTimelineTotalDefaultTypeInternal;
extern EntityScenesTimelineTotalDefaultTypeInternal _EntityScenesTimelineTotal_default_instance_;
class EntityScenesTimelineTotal_GroupMapEntry_DoNotUse;
class EntityScenesTimelineTotal_GroupMapEntry_DoNotUseDefaultTypeInternal;
extern EntityScenesTimelineTotal_GroupMapEntry_DoNotUseDefaultTypeInternal _EntityScenesTimelineTotal_GroupMapEntry_DoNotUse_default_instance_;
class EntitySplineAlone;
class EntitySplineAloneDefaultTypeInternal;
extern EntitySplineAloneDefaultTypeInternal _EntitySplineAlone_default_instance_;
class EntityTransformTimeline;
class EntityTransformTimelineDefaultTypeInternal;
extern EntityTransformTimelineDefaultTypeInternal _EntityTransformTimeline_default_instance_;
class EntityTransformTimelinePoint;
class EntityTransformTimelinePointDefaultTypeInternal;
extern EntityTransformTimelinePointDefaultTypeInternal _EntityTransformTimelinePoint_default_instance_;
class EntityTransformTimeline_PointMapEntry_DoNotUse;
class EntityTransformTimeline_PointMapEntry_DoNotUseDefaultTypeInternal;
extern EntityTransformTimeline_PointMapEntry_DoNotUseDefaultTypeInternal _EntityTransformTimeline_PointMapEntry_DoNotUse_default_instance_;
class EntityUpdateRequest;
class EntityUpdateRequestDefaultTypeInternal;
extern EntityUpdateRequestDefaultTypeInternal _EntityUpdateRequest_default_instance_;
class EntityUpdateView;
class EntityUpdateViewDefaultTypeInternal;
extern EntityUpdateViewDefaultTypeInternal _EntityUpdateView_default_instance_;
class EventCommandInfo;
class EventCommandInfoDefaultTypeInternal;
extern EventCommandInfoDefaultTypeInternal _EventCommandInfo_default_instance_;
class EventInfo;
class EventInfoDefaultTypeInternal;
extern EventInfoDefaultTypeInternal _EventInfo_default_instance_;
class OverallSituationData;
class OverallSituationDataDefaultTypeInternal;
extern OverallSituationDataDefaultTypeInternal _OverallSituationData_default_instance_;
class OverallSituationDataRequest;
class OverallSituationDataRequestDefaultTypeInternal;
extern OverallSituationDataRequestDefaultTypeInternal _OverallSituationDataRequest_default_instance_;
class OverallSituationDataResponse;
class OverallSituationDataResponseDefaultTypeInternal;
extern OverallSituationDataResponseDefaultTypeInternal _OverallSituationDataResponse_default_instance_;
class OverallSituationDataResponse_ActorListEntry_DoNotUse;
class OverallSituationDataResponse_ActorListEntry_DoNotUseDefaultTypeInternal;
extern OverallSituationDataResponse_ActorListEntry_DoNotUseDefaultTypeInternal _OverallSituationDataResponse_ActorListEntry_DoNotUse_default_instance_;
class OverallSituationData_ActorListEntry_DoNotUse;
class OverallSituationData_ActorListEntry_DoNotUseDefaultTypeInternal;
extern OverallSituationData_ActorListEntry_DoNotUseDefaultTypeInternal _OverallSituationData_ActorListEntry_DoNotUse_default_instance_;
class OverallSituationSkyInfo;
class OverallSituationSkyInfoDefaultTypeInternal;
extern OverallSituationSkyInfoDefaultTypeInternal _OverallSituationSkyInfo_default_instance_;
class PlayerButtonKeyInfo;
class PlayerButtonKeyInfoDefaultTypeInternal;
extern PlayerButtonKeyInfoDefaultTypeInternal _PlayerButtonKeyInfo_default_instance_;
class PlayerEnterView;
class PlayerEnterViewDefaultTypeInternal;
extern PlayerEnterViewDefaultTypeInternal _PlayerEnterView_default_instance_;
class PlayerEntityButtonInfo;
class PlayerEntityButtonInfoDefaultTypeInternal;
extern PlayerEntityButtonInfoDefaultTypeInternal _PlayerEntityButtonInfo_default_instance_;
class PlayerEntityStorageInfo;
class PlayerEntityStorageInfoDefaultTypeInternal;
extern PlayerEntityStorageInfoDefaultTypeInternal _PlayerEntityStorageInfo_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerLeaveView;
class PlayerLeaveViewDefaultTypeInternal;
extern PlayerLeaveViewDefaultTypeInternal _PlayerLeaveView_default_instance_;
class PlayerLocaionInfo;
class PlayerLocaionInfoDefaultTypeInternal;
extern PlayerLocaionInfoDefaultTypeInternal _PlayerLocaionInfo_default_instance_;
class PlayerRacingInfo;
class PlayerRacingInfoDefaultTypeInternal;
extern PlayerRacingInfoDefaultTypeInternal _PlayerRacingInfo_default_instance_;
class PlayerStorageEntity;
class PlayerStorageEntityDefaultTypeInternal;
extern PlayerStorageEntityDefaultTypeInternal _PlayerStorageEntity_default_instance_;
class PlayerUpdateLocation;
class PlayerUpdateLocationDefaultTypeInternal;
extern PlayerUpdateLocationDefaultTypeInternal _PlayerUpdateLocation_default_instance_;
class PlayerUpdateView;
class PlayerUpdateViewDefaultTypeInternal;
extern PlayerUpdateViewDefaultTypeInternal _PlayerUpdateView_default_instance_;
class TimelineOneFrameOneEntityData;
class TimelineOneFrameOneEntityDataDefaultTypeInternal;
extern TimelineOneFrameOneEntityDataDefaultTypeInternal _TimelineOneFrameOneEntityData_default_instance_;
class TimelineOneSecondAllFrameData;
class TimelineOneSecondAllFrameDataDefaultTypeInternal;
extern TimelineOneSecondAllFrameDataDefaultTypeInternal _TimelineOneSecondAllFrameData_default_instance_;
class TimelineOnewFrameAllEntityData;
class TimelineOnewFrameAllEntityDataDefaultTypeInternal;
extern TimelineOnewFrameAllEntityDataDefaultTypeInternal _TimelineOnewFrameAllEntityData_default_instance_;
class TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse;
class TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUseDefaultTypeInternal;
extern TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUseDefaultTypeInternal _TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse_default_instance_;
class UpdateLocationRequest;
class UpdateLocationRequestDefaultTypeInternal;
extern UpdateLocationRequestDefaultTypeInternal _UpdateLocationRequest_default_instance_;
class UpdatePlayerDataRequest;
class UpdatePlayerDataRequestDefaultTypeInternal;
extern UpdatePlayerDataRequestDefaultTypeInternal _UpdatePlayerDataRequest_default_instance_;
}  // namespace Gamedata
namespace Gamedata {

enum GameMainOperationMode {
  GameMainOperationMode_None = 0,
  GameMainOperationMode_Character = 1,
  GameMainOperationMode_Racing = 2,
  GameMainOperationMode_edit_etity = 3,
  GameMainOperationMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameMainOperationMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameMainOperationMode_IsValid(int value);
const GameMainOperationMode GameMainOperationMode_MIN = GameMainOperationMode_None;
const GameMainOperationMode GameMainOperationMode_MAX = GameMainOperationMode_edit_etity;
const int GameMainOperationMode_ARRAYSIZE = GameMainOperationMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMainOperationMode_descriptor();
inline const ::std::string& GameMainOperationMode_Name(GameMainOperationMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMainOperationMode_descriptor(), value);
}
inline bool GameMainOperationMode_Parse(
    const ::std::string& name, GameMainOperationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMainOperationMode>(
    GameMainOperationMode_descriptor(), name, value);
}
enum CharacterMovementModeType {
  CharacterMovementModeType_None = 0,
  CharacterMovementModeType_Walk = 1,
  CharacterMovementModeType_Falling = 2,
  CharacterMovementModeType_Swimming = 3,
  CharacterMovementModeType_Flying = 4,
  CharacterMovementModeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CharacterMovementModeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CharacterMovementModeType_IsValid(int value);
const CharacterMovementModeType CharacterMovementModeType_MIN = CharacterMovementModeType_None;
const CharacterMovementModeType CharacterMovementModeType_MAX = CharacterMovementModeType_Flying;
const int CharacterMovementModeType_ARRAYSIZE = CharacterMovementModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterMovementModeType_descriptor();
inline const ::std::string& CharacterMovementModeType_Name(CharacterMovementModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterMovementModeType_descriptor(), value);
}
inline bool CharacterMovementModeType_Parse(
    const ::std::string& name, CharacterMovementModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterMovementModeType>(
    CharacterMovementModeType_descriptor(), name, value);
}
enum CharacterActionType {
  CharacterActionType_None = 0,
  CharacterActionType_Attack = 1,
  CharacterActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CharacterActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CharacterActionType_IsValid(int value);
const CharacterActionType CharacterActionType_MIN = CharacterActionType_None;
const CharacterActionType CharacterActionType_MAX = CharacterActionType_Attack;
const int CharacterActionType_ARRAYSIZE = CharacterActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CharacterActionType_descriptor();
inline const ::std::string& CharacterActionType_Name(CharacterActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CharacterActionType_descriptor(), value);
}
inline bool CharacterActionType_Parse(
    const ::std::string& name, CharacterActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CharacterActionType>(
    CharacterActionType_descriptor(), name, value);
}
enum EntityTimeType {
  EntityTimeType_MoveNode = 0,
  EntityTimeType_Spin = 1,
  EntityTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityTimeType_IsValid(int value);
const EntityTimeType EntityTimeType_MIN = EntityTimeType_MoveNode;
const EntityTimeType EntityTimeType_MAX = EntityTimeType_Spin;
const int EntityTimeType_ARRAYSIZE = EntityTimeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityTimeType_descriptor();
inline const ::std::string& EntityTimeType_Name(EntityTimeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityTimeType_descriptor(), value);
}
inline bool EntityTimeType_Parse(
    const ::std::string& name, EntityTimeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityTimeType>(
    EntityTimeType_descriptor(), name, value);
}
enum EntityMoveTimelineEndOfPlay {
  EntityMoveTimelineEndOfPlay_Cycle = 0,
  EntityMoveTimelineEndOfPlay_ShutDown = 1,
  EntityMoveTimelineEndOfPlay_Return = 2,
  EntityMoveTimelineEndOfPlay_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityMoveTimelineEndOfPlay_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityMoveTimelineEndOfPlay_IsValid(int value);
const EntityMoveTimelineEndOfPlay EntityMoveTimelineEndOfPlay_MIN = EntityMoveTimelineEndOfPlay_Cycle;
const EntityMoveTimelineEndOfPlay EntityMoveTimelineEndOfPlay_MAX = EntityMoveTimelineEndOfPlay_Return;
const int EntityMoveTimelineEndOfPlay_ARRAYSIZE = EntityMoveTimelineEndOfPlay_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityMoveTimelineEndOfPlay_descriptor();
inline const ::std::string& EntityMoveTimelineEndOfPlay_Name(EntityMoveTimelineEndOfPlay value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityMoveTimelineEndOfPlay_descriptor(), value);
}
inline bool EntityMoveTimelineEndOfPlay_Parse(
    const ::std::string& name, EntityMoveTimelineEndOfPlay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityMoveTimelineEndOfPlay>(
    EntityMoveTimelineEndOfPlay_descriptor(), name, value);
}
enum EntityPythonErrorType {
  EntityPythonErrorType_none = 0,
  EntityPythonErrorType_code_error = 1,
  EntityPythonErrorType_lag = 2,
  EntityPythonErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityPythonErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityPythonErrorType_IsValid(int value);
const EntityPythonErrorType EntityPythonErrorType_MIN = EntityPythonErrorType_none;
const EntityPythonErrorType EntityPythonErrorType_MAX = EntityPythonErrorType_lag;
const int EntityPythonErrorType_ARRAYSIZE = EntityPythonErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityPythonErrorType_descriptor();
inline const ::std::string& EntityPythonErrorType_Name(EntityPythonErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityPythonErrorType_descriptor(), value);
}
inline bool EntityPythonErrorType_Parse(
    const ::std::string& name, EntityPythonErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityPythonErrorType>(
    EntityPythonErrorType_descriptor(), name, value);
}
enum EntityCommandType {
  EntityCommandType_auto = 0,
  EntityCommandType_command = 1,
  EntityCommandType_interactive = 2,
  EntityCommandType_trigger = 3,
  EntityCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityCommandType_IsValid(int value);
const EntityCommandType EntityCommandType_MIN = EntityCommandType_auto;
const EntityCommandType EntityCommandType_MAX = EntityCommandType_trigger;
const int EntityCommandType_ARRAYSIZE = EntityCommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityCommandType_descriptor();
inline const ::std::string& EntityCommandType_Name(EntityCommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityCommandType_descriptor(), value);
}
inline bool EntityCommandType_Parse(
    const ::std::string& name, EntityCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityCommandType>(
    EntityCommandType_descriptor(), name, value);
}
enum TimelineHighlightType {
  TimelineHighlightType_off = 0,
  TimelineHighlightType_color = 1,
  TimelineHighlightType_hightlight = 2,
  TimelineHighlightType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TimelineHighlightType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TimelineHighlightType_IsValid(int value);
const TimelineHighlightType TimelineHighlightType_MIN = TimelineHighlightType_off;
const TimelineHighlightType TimelineHighlightType_MAX = TimelineHighlightType_hightlight;
const int TimelineHighlightType_ARRAYSIZE = TimelineHighlightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimelineHighlightType_descriptor();
inline const ::std::string& TimelineHighlightType_Name(TimelineHighlightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimelineHighlightType_descriptor(), value);
}
inline bool TimelineHighlightType_Parse(
    const ::std::string& name, TimelineHighlightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimelineHighlightType>(
    TimelineHighlightType_descriptor(), name, value);
}
enum EntityCollisionType {
  EntityCollisionType_None = 0,
  EntityCollisionType_Query = 1,
  EntityCollisionType_QueryAndPhysics = 2,
  EntityCollisionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityCollisionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityCollisionType_IsValid(int value);
const EntityCollisionType EntityCollisionType_MIN = EntityCollisionType_None;
const EntityCollisionType EntityCollisionType_MAX = EntityCollisionType_QueryAndPhysics;
const int EntityCollisionType_ARRAYSIZE = EntityCollisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityCollisionType_descriptor();
inline const ::std::string& EntityCollisionType_Name(EntityCollisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityCollisionType_descriptor(), value);
}
inline bool EntityCollisionType_Parse(
    const ::std::string& name, EntityCollisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityCollisionType>(
    EntityCollisionType_descriptor(), name, value);
}
enum EntitySyncType {
  EntitySyncType_near = 0,
  EntitySyncType_in = 1,
  EntitySyncType_far = 2,
  EntitySyncType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntitySyncType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntitySyncType_IsValid(int value);
const EntitySyncType EntitySyncType_MIN = EntitySyncType_near;
const EntitySyncType EntitySyncType_MAX = EntitySyncType_far;
const int EntitySyncType_ARRAYSIZE = EntitySyncType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntitySyncType_descriptor();
inline const ::std::string& EntitySyncType_Name(EntitySyncType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntitySyncType_descriptor(), value);
}
inline bool EntitySyncType_Parse(
    const ::std::string& name, EntitySyncType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntitySyncType>(
    EntitySyncType_descriptor(), name, value);
}
enum EntityOperationType {
  EntityOperationType_None = 0,
  EntityOperationType_IsPlay = 5000,
  EntityOperationType_Image = 5001,
  EntityOperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityOperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityOperationType_IsValid(int value);
const EntityOperationType EntityOperationType_MIN = EntityOperationType_None;
const EntityOperationType EntityOperationType_MAX = EntityOperationType_Image;
const int EntityOperationType_ARRAYSIZE = EntityOperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityOperationType_descriptor();
inline const ::std::string& EntityOperationType_Name(EntityOperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityOperationType_descriptor(), value);
}
inline bool EntityOperationType_Parse(
    const ::std::string& name, EntityOperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityOperationType>(
    EntityOperationType_descriptor(), name, value);
}
enum OverallSituationDataType {
  OverallSituationDataType_push_all = 0,
  OverallSituationDataType_req_sky = 1,
  OverallSituationDataType_rsp_sky = 2,
  OverallSituationDataType_req_get_all_actor = 3,
  OverallSituationDataType_req_add_actor = 4,
  OverallSituationDataType_req_update_actor = 5,
  OverallSituationDataType_req_remove_actor = 6,
  OverallSituationDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OverallSituationDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OverallSituationDataType_IsValid(int value);
const OverallSituationDataType OverallSituationDataType_MIN = OverallSituationDataType_push_all;
const OverallSituationDataType OverallSituationDataType_MAX = OverallSituationDataType_req_remove_actor;
const int OverallSituationDataType_ARRAYSIZE = OverallSituationDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OverallSituationDataType_descriptor();
inline const ::std::string& OverallSituationDataType_Name(OverallSituationDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OverallSituationDataType_descriptor(), value);
}
inline bool OverallSituationDataType_Parse(
    const ::std::string& name, OverallSituationDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OverallSituationDataType>(
    OverallSituationDataType_descriptor(), name, value);
}
enum EventType {
  EventType_none = 0,
  EventType_command = 1,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EventType_IsValid(int value);
const EventType EventType_MIN = EventType_none;
const EventType EventType_MAX = EventType_command;
const int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventType_descriptor();
inline const ::std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventType_descriptor(), value);
}
inline bool EventType_Parse(
    const ::std::string& name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum EventBroadcastRangeType {
  EventBroadcastRangeType_online = 0,
  EventBroadcastRangeType_specify = 1,
  EventBroadcastRangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EventBroadcastRangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EventBroadcastRangeType_IsValid(int value);
const EventBroadcastRangeType EventBroadcastRangeType_MIN = EventBroadcastRangeType_online;
const EventBroadcastRangeType EventBroadcastRangeType_MAX = EventBroadcastRangeType_specify;
const int EventBroadcastRangeType_ARRAYSIZE = EventBroadcastRangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventBroadcastRangeType_descriptor();
inline const ::std::string& EventBroadcastRangeType_Name(EventBroadcastRangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventBroadcastRangeType_descriptor(), value);
}
inline bool EventBroadcastRangeType_Parse(
    const ::std::string& name, EventBroadcastRangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventBroadcastRangeType>(
    EventBroadcastRangeType_descriptor(), name, value);
}
// ===================================================================

class PlayerRacingInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerRacingInfo) */ {
 public:
  PlayerRacingInfo();
  virtual ~PlayerRacingInfo();

  PlayerRacingInfo(const PlayerRacingInfo& from);

  inline PlayerRacingInfo& operator=(const PlayerRacingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerRacingInfo(PlayerRacingInfo&& from) noexcept
    : PlayerRacingInfo() {
    *this = ::std::move(from);
  }

  inline PlayerRacingInfo& operator=(PlayerRacingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRacingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerRacingInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerRacingInfo*>(
               &_PlayerRacingInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlayerRacingInfo* other);
  friend void swap(PlayerRacingInfo& a, PlayerRacingInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerRacingInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerRacingInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerRacingInfo& from);
  void MergeFrom(const PlayerRacingInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerRacingInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float steering_input = 1;
  void clear_steering_input();
  static const int kSteeringInputFieldNumber = 1;
  float steering_input() const;
  void set_steering_input(float value);

  // float throttle_input = 2;
  void clear_throttle_input();
  static const int kThrottleInputFieldNumber = 2;
  float throttle_input() const;
  void set_throttle_input(float value);

  // float brake_input = 3;
  void clear_brake_input();
  static const int kBrakeInputFieldNumber = 3;
  float brake_input() const;
  void set_brake_input(float value);

  // float handbrake_input = 4;
  void clear_handbrake_input();
  static const int kHandbrakeInputFieldNumber = 4;
  float handbrake_input() const;
  void set_handbrake_input(float value);

  // int32 current_gear = 5;
  void clear_current_gear();
  static const int kCurrentGearFieldNumber = 5;
  ::google::protobuf::int32 current_gear() const;
  void set_current_gear(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerRacingInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float steering_input_;
  float throttle_input_;
  float brake_input_;
  float handbrake_input_;
  ::google::protobuf::int32 current_gear_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerRacingInfoImpl();
};
// -------------------------------------------------------------------

class PlayerButtonKeyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerButtonKeyInfo) */ {
 public:
  PlayerButtonKeyInfo();
  virtual ~PlayerButtonKeyInfo();

  PlayerButtonKeyInfo(const PlayerButtonKeyInfo& from);

  inline PlayerButtonKeyInfo& operator=(const PlayerButtonKeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerButtonKeyInfo(PlayerButtonKeyInfo&& from) noexcept
    : PlayerButtonKeyInfo() {
    *this = ::std::move(from);
  }

  inline PlayerButtonKeyInfo& operator=(PlayerButtonKeyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerButtonKeyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerButtonKeyInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerButtonKeyInfo*>(
               &_PlayerButtonKeyInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PlayerButtonKeyInfo* other);
  friend void swap(PlayerButtonKeyInfo& a, PlayerButtonKeyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerButtonKeyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerButtonKeyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerButtonKeyInfo& from);
  void MergeFrom(const PlayerButtonKeyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerButtonKeyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string command_list = 1;
  int command_list_size() const;
  void clear_command_list();
  static const int kCommandListFieldNumber = 1;
  const ::std::string& command_list(int index) const;
  ::std::string* mutable_command_list(int index);
  void set_command_list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_command_list(int index, ::std::string&& value);
  #endif
  void set_command_list(int index, const char* value);
  void set_command_list(int index, const char* value, size_t size);
  ::std::string* add_command_list();
  void add_command_list(const ::std::string& value);
  #if LANG_CXX11
  void add_command_list(::std::string&& value);
  #endif
  void add_command_list(const char* value);
  void add_command_list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& command_list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_command_list();

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerButtonKeyInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> command_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerButtonKeyInfoImpl();
};
// -------------------------------------------------------------------

class PlayerEntityButtonInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerEntityButtonInfo) */ {
 public:
  PlayerEntityButtonInfo();
  virtual ~PlayerEntityButtonInfo();

  PlayerEntityButtonInfo(const PlayerEntityButtonInfo& from);

  inline PlayerEntityButtonInfo& operator=(const PlayerEntityButtonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerEntityButtonInfo(PlayerEntityButtonInfo&& from) noexcept
    : PlayerEntityButtonInfo() {
    *this = ::std::move(from);
  }

  inline PlayerEntityButtonInfo& operator=(PlayerEntityButtonInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerEntityButtonInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerEntityButtonInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerEntityButtonInfo*>(
               &_PlayerEntityButtonInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PlayerEntityButtonInfo* other);
  friend void swap(PlayerEntityButtonInfo& a, PlayerEntityButtonInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerEntityButtonInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerEntityButtonInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerEntityButtonInfo& from);
  void MergeFrom(const PlayerEntityButtonInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerEntityButtonInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.PlayerButtonKeyInfo key_list = 1;
  int key_list_size() const;
  void clear_key_list();
  static const int kKeyListFieldNumber = 1;
  const ::Gamedata::PlayerButtonKeyInfo& key_list(int index) const;
  ::Gamedata::PlayerButtonKeyInfo* mutable_key_list(int index);
  ::Gamedata::PlayerButtonKeyInfo* add_key_list();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerButtonKeyInfo >*
      mutable_key_list();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerButtonKeyInfo >&
      key_list() const;

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerEntityButtonInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerButtonKeyInfo > key_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerEntityButtonInfoImpl();
};
// -------------------------------------------------------------------

class PlayerLocaionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLocaionInfo) */ {
 public:
  PlayerLocaionInfo();
  virtual ~PlayerLocaionInfo();

  PlayerLocaionInfo(const PlayerLocaionInfo& from);

  inline PlayerLocaionInfo& operator=(const PlayerLocaionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLocaionInfo(PlayerLocaionInfo&& from) noexcept
    : PlayerLocaionInfo() {
    *this = ::std::move(from);
  }

  inline PlayerLocaionInfo& operator=(PlayerLocaionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLocaionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLocaionInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerLocaionInfo*>(
               &_PlayerLocaionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PlayerLocaionInfo* other);
  friend void swap(PlayerLocaionInfo& a, PlayerLocaionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLocaionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLocaionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLocaionInfo& from);
  void MergeFrom(const PlayerLocaionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLocaionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FTransform_s transform_s = 1;
  bool has_transform_s() const;
  void clear_transform_s();
  static const int kTransformSFieldNumber = 1;
  const ::Gamedata::FTransform_s& transform_s() const;
  ::Gamedata::FTransform_s* release_transform_s();
  ::Gamedata::FTransform_s* mutable_transform_s();
  void set_allocated_transform_s(::Gamedata::FTransform_s* transform_s);

  // .Gamedata.FVector velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  const ::Gamedata::FVector& velocity() const;
  ::Gamedata::FVector* release_velocity();
  ::Gamedata::FVector* mutable_velocity();
  void set_allocated_velocity(::Gamedata::FVector* velocity);

  // .Gamedata.PlayerRacingInfo player_racing_info = 6;
  bool has_player_racing_info() const;
  void clear_player_racing_info();
  static const int kPlayerRacingInfoFieldNumber = 6;
  const ::Gamedata::PlayerRacingInfo& player_racing_info() const;
  ::Gamedata::PlayerRacingInfo* release_player_racing_info();
  ::Gamedata::PlayerRacingInfo* mutable_player_racing_info();
  void set_allocated_player_racing_info(::Gamedata::PlayerRacingInfo* player_racing_info);

  // .Gamedata.CharacterMovementModeType characterMovementModeType = 3;
  void clear_charactermovementmodetype();
  static const int kCharacterMovementModeTypeFieldNumber = 3;
  ::Gamedata::CharacterMovementModeType charactermovementmodetype() const;
  void set_charactermovementmodetype(::Gamedata::CharacterMovementModeType value);

  // .Gamedata.CharacterActionType characterActionType = 4;
  void clear_characteractiontype();
  static const int kCharacterActionTypeFieldNumber = 4;
  ::Gamedata::CharacterActionType characteractiontype() const;
  void set_characteractiontype(::Gamedata::CharacterActionType value);

  // bool isRacing = 5;
  void clear_isracing();
  static const int kIsRacingFieldNumber = 5;
  bool isracing() const;
  void set_isracing(bool value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLocaionInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FTransform_s* transform_s_;
  ::Gamedata::FVector* velocity_;
  ::Gamedata::PlayerRacingInfo* player_racing_info_;
  int charactermovementmodetype_;
  int characteractiontype_;
  bool isracing_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerLocaionInfoImpl();
};
// -------------------------------------------------------------------

class PlayerStorageEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerStorageEntity) */ {
 public:
  PlayerStorageEntity();
  virtual ~PlayerStorageEntity();

  PlayerStorageEntity(const PlayerStorageEntity& from);

  inline PlayerStorageEntity& operator=(const PlayerStorageEntity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerStorageEntity(PlayerStorageEntity&& from) noexcept
    : PlayerStorageEntity() {
    *this = ::std::move(from);
  }

  inline PlayerStorageEntity& operator=(PlayerStorageEntity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerStorageEntity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerStorageEntity* internal_default_instance() {
    return reinterpret_cast<const PlayerStorageEntity*>(
               &_PlayerStorageEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PlayerStorageEntity* other);
  friend void swap(PlayerStorageEntity& a, PlayerStorageEntity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerStorageEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerStorageEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerStorageEntity& from);
  void MergeFrom(const PlayerStorageEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerStorageEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string entity_name = 2;
  void clear_entity_name();
  static const int kEntityNameFieldNumber = 2;
  const ::std::string& entity_name() const;
  void set_entity_name(const ::std::string& value);
  #if LANG_CXX11
  void set_entity_name(::std::string&& value);
  #endif
  void set_entity_name(const char* value);
  void set_entity_name(const char* value, size_t size);
  ::std::string* mutable_entity_name();
  ::std::string* release_entity_name();
  void set_allocated_entity_name(::std::string* entity_name);

  // .Gamedata.EntityInfo entity_info = 1;
  bool has_entity_info() const;
  void clear_entity_info();
  static const int kEntityInfoFieldNumber = 1;
  const ::Gamedata::EntityInfo& entity_info() const;
  ::Gamedata::EntityInfo* release_entity_info();
  ::Gamedata::EntityInfo* mutable_entity_info();
  void set_allocated_entity_info(::Gamedata::EntityInfo* entity_info);

  // int32 unique_mark = 3;
  void clear_unique_mark();
  static const int kUniqueMarkFieldNumber = 3;
  ::google::protobuf::int32 unique_mark() const;
  void set_unique_mark(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerStorageEntity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr entity_name_;
  ::Gamedata::EntityInfo* entity_info_;
  ::google::protobuf::int32 unique_mark_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerStorageEntityImpl();
};
// -------------------------------------------------------------------

class PlayerEntityStorageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerEntityStorageInfo) */ {
 public:
  PlayerEntityStorageInfo();
  virtual ~PlayerEntityStorageInfo();

  PlayerEntityStorageInfo(const PlayerEntityStorageInfo& from);

  inline PlayerEntityStorageInfo& operator=(const PlayerEntityStorageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerEntityStorageInfo(PlayerEntityStorageInfo&& from) noexcept
    : PlayerEntityStorageInfo() {
    *this = ::std::move(from);
  }

  inline PlayerEntityStorageInfo& operator=(PlayerEntityStorageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerEntityStorageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerEntityStorageInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerEntityStorageInfo*>(
               &_PlayerEntityStorageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PlayerEntityStorageInfo* other);
  friend void swap(PlayerEntityStorageInfo& a, PlayerEntityStorageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerEntityStorageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerEntityStorageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerEntityStorageInfo& from);
  void MergeFrom(const PlayerEntityStorageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerEntityStorageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.PlayerStorageEntity storage_entity_list = 1;
  int storage_entity_list_size() const;
  void clear_storage_entity_list();
  static const int kStorageEntityListFieldNumber = 1;
  const ::Gamedata::PlayerStorageEntity& storage_entity_list(int index) const;
  ::Gamedata::PlayerStorageEntity* mutable_storage_entity_list(int index);
  ::Gamedata::PlayerStorageEntity* add_storage_entity_list();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerStorageEntity >*
      mutable_storage_entity_list();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerStorageEntity >&
      storage_entity_list() const;

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerEntityStorageInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerStorageEntity > storage_entity_list_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerEntityStorageInfoImpl();
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.PlayerLocaionInfo playerLocaionInfo = 4;
  bool has_playerlocaioninfo() const;
  void clear_playerlocaioninfo();
  static const int kPlayerLocaionInfoFieldNumber = 4;
  const ::Gamedata::PlayerLocaionInfo& playerlocaioninfo() const;
  ::Gamedata::PlayerLocaionInfo* release_playerlocaioninfo();
  ::Gamedata::PlayerLocaionInfo* mutable_playerlocaioninfo();
  void set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo);

  // .Gamedata.PlayerEntityButtonInfo entity_button_info = 5;
  bool has_entity_button_info() const;
  void clear_entity_button_info();
  static const int kEntityButtonInfoFieldNumber = 5;
  const ::Gamedata::PlayerEntityButtonInfo& entity_button_info() const;
  ::Gamedata::PlayerEntityButtonInfo* release_entity_button_info();
  ::Gamedata::PlayerEntityButtonInfo* mutable_entity_button_info();
  void set_allocated_entity_button_info(::Gamedata::PlayerEntityButtonInfo* entity_button_info);

  // .Gamedata.PlayerEntityStorageInfo entity_storage = 6;
  bool has_entity_storage() const;
  void clear_entity_storage();
  static const int kEntityStorageFieldNumber = 6;
  const ::Gamedata::PlayerEntityStorageInfo& entity_storage() const;
  ::Gamedata::PlayerEntityStorageInfo* release_entity_storage();
  ::Gamedata::PlayerEntityStorageInfo* mutable_entity_storage();
  void set_allocated_entity_storage(::Gamedata::PlayerEntityStorageInfo* entity_storage);

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // .Gamedata.GameMainOperationMode character_pawn_type = 2;
  void clear_character_pawn_type();
  static const int kCharacterPawnTypeFieldNumber = 2;
  ::Gamedata::GameMainOperationMode character_pawn_type() const;
  void set_character_pawn_type(::Gamedata::GameMainOperationMode value);

  // int32 sky_level_index = 7;
  void clear_sky_level_index();
  static const int kSkyLevelIndexFieldNumber = 7;
  ::google::protobuf::int32 sky_level_index() const;
  void set_sky_level_index(::google::protobuf::int32 value);

  // int32 character_index = 8;
  void clear_character_index();
  static const int kCharacterIndexFieldNumber = 8;
  ::google::protobuf::int32 character_index() const;
  void set_character_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::PlayerLocaionInfo* playerlocaioninfo_;
  ::Gamedata::PlayerEntityButtonInfo* entity_button_info_;
  ::Gamedata::PlayerEntityStorageInfo* entity_storage_;
  ::google::protobuf::int32 playerid_;
  int character_pawn_type_;
  ::google::protobuf::int32 sky_level_index_;
  ::google::protobuf::int32 character_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerInfoImpl();
};
// -------------------------------------------------------------------

class PlayerEnterView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerEnterView) */ {
 public:
  PlayerEnterView();
  virtual ~PlayerEnterView();

  PlayerEnterView(const PlayerEnterView& from);

  inline PlayerEnterView& operator=(const PlayerEnterView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerEnterView(PlayerEnterView&& from) noexcept
    : PlayerEnterView() {
    *this = ::std::move(from);
  }

  inline PlayerEnterView& operator=(PlayerEnterView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerEnterView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerEnterView* internal_default_instance() {
    return reinterpret_cast<const PlayerEnterView*>(
               &_PlayerEnterView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(PlayerEnterView* other);
  friend void swap(PlayerEnterView& a, PlayerEnterView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerEnterView* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerEnterView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerEnterView& from);
  void MergeFrom(const PlayerEnterView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerEnterView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.PlayerInfo playerInfoList = 1;
  int playerinfolist_size() const;
  void clear_playerinfolist();
  static const int kPlayerInfoListFieldNumber = 1;
  const ::Gamedata::PlayerInfo& playerinfolist(int index) const;
  ::Gamedata::PlayerInfo* mutable_playerinfolist(int index);
  ::Gamedata::PlayerInfo* add_playerinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >*
      mutable_playerinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >&
      playerinfolist() const;

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerEnterView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo > playerinfolist_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerEnterViewImpl();
};
// -------------------------------------------------------------------

class PlayerLeaveView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLeaveView) */ {
 public:
  PlayerLeaveView();
  virtual ~PlayerLeaveView();

  PlayerLeaveView(const PlayerLeaveView& from);

  inline PlayerLeaveView& operator=(const PlayerLeaveView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLeaveView(PlayerLeaveView&& from) noexcept
    : PlayerLeaveView() {
    *this = ::std::move(from);
  }

  inline PlayerLeaveView& operator=(PlayerLeaveView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLeaveView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLeaveView* internal_default_instance() {
    return reinterpret_cast<const PlayerLeaveView*>(
               &_PlayerLeaveView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PlayerLeaveView* other);
  friend void swap(PlayerLeaveView& a, PlayerLeaveView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLeaveView* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLeaveView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLeaveView& from);
  void MergeFrom(const PlayerLeaveView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLeaveView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 playerIdList = 1;
  int playeridlist_size() const;
  void clear_playeridlist();
  static const int kPlayerIdListFieldNumber = 1;
  ::google::protobuf::int32 playeridlist(int index) const;
  void set_playeridlist(int index, ::google::protobuf::int32 value);
  void add_playeridlist(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      playeridlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_playeridlist();

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLeaveView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > playeridlist_;
  mutable int _playeridlist_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerLeaveViewImpl();
};
// -------------------------------------------------------------------

class PlayerUpdateView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerUpdateView) */ {
 public:
  PlayerUpdateView();
  virtual ~PlayerUpdateView();

  PlayerUpdateView(const PlayerUpdateView& from);

  inline PlayerUpdateView& operator=(const PlayerUpdateView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerUpdateView(PlayerUpdateView&& from) noexcept
    : PlayerUpdateView() {
    *this = ::std::move(from);
  }

  inline PlayerUpdateView& operator=(PlayerUpdateView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerUpdateView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerUpdateView* internal_default_instance() {
    return reinterpret_cast<const PlayerUpdateView*>(
               &_PlayerUpdateView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PlayerUpdateView* other);
  friend void swap(PlayerUpdateView& a, PlayerUpdateView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerUpdateView* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerUpdateView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerUpdateView& from);
  void MergeFrom(const PlayerUpdateView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerUpdateView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.PlayerInfo playerInfoList = 1;
  int playerinfolist_size() const;
  void clear_playerinfolist();
  static const int kPlayerInfoListFieldNumber = 1;
  const ::Gamedata::PlayerInfo& playerinfolist(int index) const;
  ::Gamedata::PlayerInfo* mutable_playerinfolist(int index);
  ::Gamedata::PlayerInfo* add_playerinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >*
      mutable_playerinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >&
      playerinfolist() const;

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerUpdateView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo > playerinfolist_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerUpdateViewImpl();
};
// -------------------------------------------------------------------

class PlayerUpdateLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerUpdateLocation) */ {
 public:
  PlayerUpdateLocation();
  virtual ~PlayerUpdateLocation();

  PlayerUpdateLocation(const PlayerUpdateLocation& from);

  inline PlayerUpdateLocation& operator=(const PlayerUpdateLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerUpdateLocation(PlayerUpdateLocation&& from) noexcept
    : PlayerUpdateLocation() {
    *this = ::std::move(from);
  }

  inline PlayerUpdateLocation& operator=(PlayerUpdateLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerUpdateLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerUpdateLocation* internal_default_instance() {
    return reinterpret_cast<const PlayerUpdateLocation*>(
               &_PlayerUpdateLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PlayerUpdateLocation* other);
  friend void swap(PlayerUpdateLocation& a, PlayerUpdateLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerUpdateLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerUpdateLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerUpdateLocation& from);
  void MergeFrom(const PlayerUpdateLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerUpdateLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.PlayerLocaionInfo playerLocaionInfo = 2;
  bool has_playerlocaioninfo() const;
  void clear_playerlocaioninfo();
  static const int kPlayerLocaionInfoFieldNumber = 2;
  const ::Gamedata::PlayerLocaionInfo& playerlocaioninfo() const;
  ::Gamedata::PlayerLocaionInfo* release_playerlocaioninfo();
  ::Gamedata::PlayerLocaionInfo* mutable_playerlocaioninfo();
  void set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo);

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerUpdateLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::PlayerLocaionInfo* playerlocaioninfo_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPlayerUpdateLocationImpl();
};
// -------------------------------------------------------------------

class UpdatePlayerDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.UpdatePlayerDataRequest) */ {
 public:
  UpdatePlayerDataRequest();
  virtual ~UpdatePlayerDataRequest();

  UpdatePlayerDataRequest(const UpdatePlayerDataRequest& from);

  inline UpdatePlayerDataRequest& operator=(const UpdatePlayerDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatePlayerDataRequest(UpdatePlayerDataRequest&& from) noexcept
    : UpdatePlayerDataRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerDataRequest& operator=(UpdatePlayerDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePlayerDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePlayerDataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerDataRequest*>(
               &_UpdatePlayerDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(UpdatePlayerDataRequest* other);
  friend void swap(UpdatePlayerDataRequest& a, UpdatePlayerDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdatePlayerDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdatePlayerDataRequest& from);
  void MergeFrom(const UpdatePlayerDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdatePlayerDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.PlayerInfo playerInfo = 1;
  bool has_playerinfo() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  const ::Gamedata::PlayerInfo& playerinfo() const;
  ::Gamedata::PlayerInfo* release_playerinfo();
  ::Gamedata::PlayerInfo* mutable_playerinfo();
  void set_allocated_playerinfo(::Gamedata::PlayerInfo* playerinfo);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.UpdatePlayerDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::PlayerInfo* playerinfo_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsUpdatePlayerDataRequestImpl();
};
// -------------------------------------------------------------------

class UpdateLocationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.UpdateLocationRequest) */ {
 public:
  UpdateLocationRequest();
  virtual ~UpdateLocationRequest();

  UpdateLocationRequest(const UpdateLocationRequest& from);

  inline UpdateLocationRequest& operator=(const UpdateLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateLocationRequest(UpdateLocationRequest&& from) noexcept
    : UpdateLocationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateLocationRequest& operator=(UpdateLocationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateLocationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateLocationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateLocationRequest*>(
               &_UpdateLocationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(UpdateLocationRequest* other);
  friend void swap(UpdateLocationRequest& a, UpdateLocationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateLocationRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateLocationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateLocationRequest& from);
  void MergeFrom(const UpdateLocationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateLocationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.PlayerLocaionInfo playerLocaionInfo = 2;
  bool has_playerlocaioninfo() const;
  void clear_playerlocaioninfo();
  static const int kPlayerLocaionInfoFieldNumber = 2;
  const ::Gamedata::PlayerLocaionInfo& playerlocaioninfo() const;
  ::Gamedata::PlayerLocaionInfo* release_playerlocaioninfo();
  ::Gamedata::PlayerLocaionInfo* mutable_playerlocaioninfo();
  void set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo);

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.UpdateLocationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::PlayerLocaionInfo* playerlocaioninfo_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsUpdateLocationRequestImpl();
};
// -------------------------------------------------------------------

class ChangeJiugonggeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.ChangeJiugonggeRequest) */ {
 public:
  ChangeJiugonggeRequest();
  virtual ~ChangeJiugonggeRequest();

  ChangeJiugonggeRequest(const ChangeJiugonggeRequest& from);

  inline ChangeJiugonggeRequest& operator=(const ChangeJiugonggeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeJiugonggeRequest(ChangeJiugonggeRequest&& from) noexcept
    : ChangeJiugonggeRequest() {
    *this = ::std::move(from);
  }

  inline ChangeJiugonggeRequest& operator=(ChangeJiugonggeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeJiugonggeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeJiugonggeRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeJiugonggeRequest*>(
               &_ChangeJiugonggeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ChangeJiugonggeRequest* other);
  friend void swap(ChangeJiugonggeRequest& a, ChangeJiugonggeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeJiugonggeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangeJiugonggeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangeJiugonggeRequest& from);
  void MergeFrom(const ChangeJiugonggeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangeJiugonggeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::Gamedata::FVector& location() const;
  ::Gamedata::FVector* release_location();
  ::Gamedata::FVector* mutable_location();
  void set_allocated_location(::Gamedata::FVector* location);

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.ChangeJiugonggeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* location_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsChangeJiugonggeRequestImpl();
};
// -------------------------------------------------------------------

class EntitySplineAlone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntitySplineAlone) */ {
 public:
  EntitySplineAlone();
  virtual ~EntitySplineAlone();

  EntitySplineAlone(const EntitySplineAlone& from);

  inline EntitySplineAlone& operator=(const EntitySplineAlone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntitySplineAlone(EntitySplineAlone&& from) noexcept
    : EntitySplineAlone() {
    *this = ::std::move(from);
  }

  inline EntitySplineAlone& operator=(EntitySplineAlone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntitySplineAlone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntitySplineAlone* internal_default_instance() {
    return reinterpret_cast<const EntitySplineAlone*>(
               &_EntitySplineAlone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(EntitySplineAlone* other);
  friend void swap(EntitySplineAlone& a, EntitySplineAlone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntitySplineAlone* New() const PROTOBUF_FINAL { return New(NULL); }

  EntitySplineAlone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntitySplineAlone& from);
  void MergeFrom(const EntitySplineAlone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntitySplineAlone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FTransform_s transform_s = 1;
  bool has_transform_s() const;
  void clear_transform_s();
  static const int kTransformSFieldNumber = 1;
  const ::Gamedata::FTransform_s& transform_s() const;
  ::Gamedata::FTransform_s* release_transform_s();
  ::Gamedata::FTransform_s* mutable_transform_s();
  void set_allocated_transform_s(::Gamedata::FTransform_s* transform_s);

  // @@protoc_insertion_point(class_scope:Gamedata.EntitySplineAlone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FTransform_s* transform_s_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntitySplineAloneImpl();
};
// -------------------------------------------------------------------

class EntityLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityLaser) */ {
 public:
  EntityLaser();
  virtual ~EntityLaser();

  EntityLaser(const EntityLaser& from);

  inline EntityLaser& operator=(const EntityLaser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityLaser(EntityLaser&& from) noexcept
    : EntityLaser() {
    *this = ::std::move(from);
  }

  inline EntityLaser& operator=(EntityLaser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityLaser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityLaser* internal_default_instance() {
    return reinterpret_cast<const EntityLaser*>(
               &_EntityLaser_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(EntityLaser* other);
  friend void swap(EntityLaser& a, EntityLaser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityLaser* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityLaser* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityLaser& from);
  void MergeFrom(const EntityLaser& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Gamedata.EntityLaser)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityLaserImpl();
};
// -------------------------------------------------------------------

class EntityMusic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMusic) */ {
 public:
  EntityMusic();
  virtual ~EntityMusic();

  EntityMusic(const EntityMusic& from);

  inline EntityMusic& operator=(const EntityMusic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMusic(EntityMusic&& from) noexcept
    : EntityMusic() {
    *this = ::std::move(from);
  }

  inline EntityMusic& operator=(EntityMusic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMusic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMusic* internal_default_instance() {
    return reinterpret_cast<const EntityMusic*>(
               &_EntityMusic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(EntityMusic* other);
  friend void swap(EntityMusic& a, EntityMusic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMusic* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMusic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMusic& from);
  void MergeFrom(const EntityMusic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMusic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMusic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMusicImpl();
};
// -------------------------------------------------------------------

class EntityScenesTimelineGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityScenesTimelineGroup) */ {
 public:
  EntityScenesTimelineGroup();
  virtual ~EntityScenesTimelineGroup();

  EntityScenesTimelineGroup(const EntityScenesTimelineGroup& from);

  inline EntityScenesTimelineGroup& operator=(const EntityScenesTimelineGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityScenesTimelineGroup(EntityScenesTimelineGroup&& from) noexcept
    : EntityScenesTimelineGroup() {
    *this = ::std::move(from);
  }

  inline EntityScenesTimelineGroup& operator=(EntityScenesTimelineGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityScenesTimelineGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityScenesTimelineGroup* internal_default_instance() {
    return reinterpret_cast<const EntityScenesTimelineGroup*>(
               &_EntityScenesTimelineGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(EntityScenesTimelineGroup* other);
  friend void swap(EntityScenesTimelineGroup& a, EntityScenesTimelineGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityScenesTimelineGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityScenesTimelineGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityScenesTimelineGroup& from);
  void MergeFrom(const EntityScenesTimelineGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityScenesTimelineGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 entityIdList = 3;
  int entityidlist_size() const;
  void clear_entityidlist();
  static const int kEntityIdListFieldNumber = 3;
  ::google::protobuf::int32 entityidlist(int index) const;
  void set_entityidlist(int index, ::google::protobuf::int32 value);
  void add_entityidlist(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entityidlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entityidlist();

  // string groupName = 2;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // int32 groupId = 1;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  ::google::protobuf::int32 groupid() const;
  void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityScenesTimelineGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entityidlist_;
  mutable int _entityidlist_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::google::protobuf::int32 groupid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityScenesTimelineGroupImpl();
};
// -------------------------------------------------------------------

class EntityScenesTimelineNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityScenesTimelineNode) */ {
 public:
  EntityScenesTimelineNode();
  virtual ~EntityScenesTimelineNode();

  EntityScenesTimelineNode(const EntityScenesTimelineNode& from);

  inline EntityScenesTimelineNode& operator=(const EntityScenesTimelineNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityScenesTimelineNode(EntityScenesTimelineNode&& from) noexcept
    : EntityScenesTimelineNode() {
    *this = ::std::move(from);
  }

  inline EntityScenesTimelineNode& operator=(EntityScenesTimelineNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityScenesTimelineNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityScenesTimelineNode* internal_default_instance() {
    return reinterpret_cast<const EntityScenesTimelineNode*>(
               &_EntityScenesTimelineNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(EntityScenesTimelineNode* other);
  friend void swap(EntityScenesTimelineNode& a, EntityScenesTimelineNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityScenesTimelineNode* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityScenesTimelineNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityScenesTimelineNode& from);
  void MergeFrom(const EntityScenesTimelineNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityScenesTimelineNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 entityId = 1;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // int32 groupId = 2;
  void clear_groupid();
  static const int kGroupIdFieldNumber = 2;
  ::google::protobuf::int32 groupid() const;
  void set_groupid(::google::protobuf::int32 value);

  // int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityScenesTimelineNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 groupid_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityScenesTimelineNodeImpl();
};
// -------------------------------------------------------------------

class EntityScenesTimelineAlone_EntityMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EntityScenesTimelineAlone_EntityMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EntityScenesTimelineAlone_EntityMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EntityScenesTimelineAlone_EntityMapEntry_DoNotUse();
  EntityScenesTimelineAlone_EntityMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EntityScenesTimelineAlone_EntityMapEntry_DoNotUse& other);
  static const EntityScenesTimelineAlone_EntityMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EntityScenesTimelineAlone_EntityMapEntry_DoNotUse*>(&_EntityScenesTimelineAlone_EntityMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EntityScenesTimelineAlone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityScenesTimelineAlone) */ {
 public:
  EntityScenesTimelineAlone();
  virtual ~EntityScenesTimelineAlone();

  EntityScenesTimelineAlone(const EntityScenesTimelineAlone& from);

  inline EntityScenesTimelineAlone& operator=(const EntityScenesTimelineAlone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityScenesTimelineAlone(EntityScenesTimelineAlone&& from) noexcept
    : EntityScenesTimelineAlone() {
    *this = ::std::move(from);
  }

  inline EntityScenesTimelineAlone& operator=(EntityScenesTimelineAlone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityScenesTimelineAlone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityScenesTimelineAlone* internal_default_instance() {
    return reinterpret_cast<const EntityScenesTimelineAlone*>(
               &_EntityScenesTimelineAlone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(EntityScenesTimelineAlone* other);
  friend void swap(EntityScenesTimelineAlone& a, EntityScenesTimelineAlone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityScenesTimelineAlone* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityScenesTimelineAlone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityScenesTimelineAlone& from);
  void MergeFrom(const EntityScenesTimelineAlone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityScenesTimelineAlone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityScenesTimelineNode> entityMap = 3;
  int entitymap_size() const;
  void clear_entitymap();
  static const int kEntityMapFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode >&
      entitymap() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode >*
      mutable_entitymap();

  // string timelineName = 2;
  void clear_timelinename();
  static const int kTimelineNameFieldNumber = 2;
  const ::std::string& timelinename() const;
  void set_timelinename(const ::std::string& value);
  #if LANG_CXX11
  void set_timelinename(::std::string&& value);
  #endif
  void set_timelinename(const char* value);
  void set_timelinename(const char* value, size_t size);
  ::std::string* mutable_timelinename();
  ::std::string* release_timelinename();
  void set_allocated_timelinename(::std::string* timelinename);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityScenesTimelineAlone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      EntityScenesTimelineAlone_EntityMapEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > entitymap_;
  ::google::protobuf::internal::ArenaStringPtr timelinename_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityScenesTimelineAloneImpl();
};
// -------------------------------------------------------------------

class EntityScenesTimelineTotal_GroupMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EntityScenesTimelineTotal_GroupMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EntityScenesTimelineTotal_GroupMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EntityScenesTimelineTotal_GroupMapEntry_DoNotUse();
  EntityScenesTimelineTotal_GroupMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EntityScenesTimelineTotal_GroupMapEntry_DoNotUse& other);
  static const EntityScenesTimelineTotal_GroupMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EntityScenesTimelineTotal_GroupMapEntry_DoNotUse*>(&_EntityScenesTimelineTotal_GroupMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EntityScenesTimelineTotal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityScenesTimelineTotal) */ {
 public:
  EntityScenesTimelineTotal();
  virtual ~EntityScenesTimelineTotal();

  EntityScenesTimelineTotal(const EntityScenesTimelineTotal& from);

  inline EntityScenesTimelineTotal& operator=(const EntityScenesTimelineTotal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityScenesTimelineTotal(EntityScenesTimelineTotal&& from) noexcept
    : EntityScenesTimelineTotal() {
    *this = ::std::move(from);
  }

  inline EntityScenesTimelineTotal& operator=(EntityScenesTimelineTotal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityScenesTimelineTotal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityScenesTimelineTotal* internal_default_instance() {
    return reinterpret_cast<const EntityScenesTimelineTotal*>(
               &_EntityScenesTimelineTotal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(EntityScenesTimelineTotal* other);
  friend void swap(EntityScenesTimelineTotal& a, EntityScenesTimelineTotal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityScenesTimelineTotal* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityScenesTimelineTotal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityScenesTimelineTotal& from);
  void MergeFrom(const EntityScenesTimelineTotal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityScenesTimelineTotal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityScenesTimelineGroup> groupMap = 3;
  int groupmap_size() const;
  void clear_groupmap();
  static const int kGroupMapFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup >&
      groupmap() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup >*
      mutable_groupmap();

  // repeated .Gamedata.EntityScenesTimelineAlone alone = 4;
  int alone_size() const;
  void clear_alone();
  static const int kAloneFieldNumber = 4;
  const ::Gamedata::EntityScenesTimelineAlone& alone(int index) const;
  ::Gamedata::EntityScenesTimelineAlone* mutable_alone(int index);
  ::Gamedata::EntityScenesTimelineAlone* add_alone();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityScenesTimelineAlone >*
      mutable_alone();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityScenesTimelineAlone >&
      alone() const;

  // bool isPlay = 1;
  void clear_isplay();
  static const int kIsPlayFieldNumber = 1;
  bool isplay() const;
  void set_isplay(bool value);

  // float playTime = 2;
  void clear_playtime();
  static const int kPlayTimeFieldNumber = 2;
  float playtime() const;
  void set_playtime(float value);

  // float totalTime = 5;
  void clear_totaltime();
  static const int kTotalTimeFieldNumber = 5;
  float totaltime() const;
  void set_totaltime(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityScenesTimelineTotal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      EntityScenesTimelineTotal_GroupMapEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > groupmap_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityScenesTimelineAlone > alone_;
  bool isplay_;
  float playtime_;
  float totaltime_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityScenesTimelineTotalImpl();
};
// -------------------------------------------------------------------

class EntityMoveTimelinePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMoveTimelinePoint) */ {
 public:
  EntityMoveTimelinePoint();
  virtual ~EntityMoveTimelinePoint();

  EntityMoveTimelinePoint(const EntityMoveTimelinePoint& from);

  inline EntityMoveTimelinePoint& operator=(const EntityMoveTimelinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMoveTimelinePoint(EntityMoveTimelinePoint&& from) noexcept
    : EntityMoveTimelinePoint() {
    *this = ::std::move(from);
  }

  inline EntityMoveTimelinePoint& operator=(EntityMoveTimelinePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMoveTimelinePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMoveTimelinePoint* internal_default_instance() {
    return reinterpret_cast<const EntityMoveTimelinePoint*>(
               &_EntityMoveTimelinePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(EntityMoveTimelinePoint* other);
  friend void swap(EntityMoveTimelinePoint& a, EntityMoveTimelinePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMoveTimelinePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMoveTimelinePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMoveTimelinePoint& from);
  void MergeFrom(const EntityMoveTimelinePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMoveTimelinePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::Gamedata::FVector& location() const;
  ::Gamedata::FVector* release_location();
  ::Gamedata::FVector* mutable_location();
  void set_allocated_location(::Gamedata::FVector* location);

  // .Gamedata.FRotator rotator = 3;
  bool has_rotator() const;
  void clear_rotator();
  static const int kRotatorFieldNumber = 3;
  const ::Gamedata::FRotator& rotator() const;
  ::Gamedata::FRotator* release_rotator();
  ::Gamedata::FRotator* mutable_rotator();
  void set_allocated_rotator(::Gamedata::FRotator* rotator);

  // .Gamedata.FVector scale = 5;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 5;
  const ::Gamedata::FVector& scale() const;
  ::Gamedata::FVector* release_scale();
  ::Gamedata::FVector* mutable_scale();
  void set_allocated_scale(::Gamedata::FVector* scale);

  // int32 uniqueMark = 1;
  void clear_uniquemark();
  static const int kUniqueMarkFieldNumber = 1;
  ::google::protobuf::int32 uniquemark() const;
  void set_uniquemark(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMoveTimelinePoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* location_;
  ::Gamedata::FRotator* rotator_;
  ::Gamedata::FVector* scale_;
  ::google::protobuf::int32 uniquemark_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMoveTimelinePointImpl();
};
// -------------------------------------------------------------------

class EntityMoveTimeline_PointMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EntityMoveTimeline_PointMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EntityMoveTimeline_PointMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EntityMoveTimeline_PointMapEntry_DoNotUse();
  EntityMoveTimeline_PointMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EntityMoveTimeline_PointMapEntry_DoNotUse& other);
  static const EntityMoveTimeline_PointMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EntityMoveTimeline_PointMapEntry_DoNotUse*>(&_EntityMoveTimeline_PointMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EntityMoveTimeline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMoveTimeline) */ {
 public:
  EntityMoveTimeline();
  virtual ~EntityMoveTimeline();

  EntityMoveTimeline(const EntityMoveTimeline& from);

  inline EntityMoveTimeline& operator=(const EntityMoveTimeline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMoveTimeline(EntityMoveTimeline&& from) noexcept
    : EntityMoveTimeline() {
    *this = ::std::move(from);
  }

  inline EntityMoveTimeline& operator=(EntityMoveTimeline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMoveTimeline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMoveTimeline* internal_default_instance() {
    return reinterpret_cast<const EntityMoveTimeline*>(
               &_EntityMoveTimeline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(EntityMoveTimeline* other);
  friend void swap(EntityMoveTimeline& a, EntityMoveTimeline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMoveTimeline* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMoveTimeline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMoveTimeline& from);
  void MergeFrom(const EntityMoveTimeline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMoveTimeline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityMoveTimelinePoint> pointMap = 2;
  int pointmap_size() const;
  void clear_pointmap();
  static const int kPointMapFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint >&
      pointmap() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint >*
      mutable_pointmap();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Gamedata.EntityMoveTimelineEndOfPlay EntityMoveTimelineEndOfPlay = 5;
  void clear_entitymovetimelineendofplay();
  static const int kEntityMoveTimelineEndOfPlayFieldNumber = 5;
  ::Gamedata::EntityMoveTimelineEndOfPlay entitymovetimelineendofplay() const;
  void set_entitymovetimelineendofplay(::Gamedata::EntityMoveTimelineEndOfPlay value);

  // float size = 7;
  void clear_size();
  static const int kSizeFieldNumber = 7;
  float size() const;
  void set_size(float value);

  // int32 lenght = 8;
  void clear_lenght();
  static const int kLenghtFieldNumber = 8;
  ::google::protobuf::int32 lenght() const;
  void set_lenght(::google::protobuf::int32 value);

  // float playLenght = 9;
  void clear_playlenght();
  static const int kPlayLenghtFieldNumber = 9;
  float playlenght() const;
  void set_playlenght(float value);

  // bool isReflection = 6;
  void clear_isreflection();
  static const int kIsReflectionFieldNumber = 6;
  bool isreflection() const;
  void set_isreflection(bool value);

  // bool isMove = 10;
  void clear_ismove();
  static const int kIsMoveFieldNumber = 10;
  bool ismove() const;
  void set_ismove(bool value);

  // bool moveYaw = 11;
  void clear_moveyaw();
  static const int kMoveYawFieldNumber = 11;
  bool moveyaw() const;
  void set_moveyaw(bool value);

  // int32 scenesTimelineIndex = 12;
  void clear_scenestimelineindex();
  static const int kScenesTimelineIndexFieldNumber = 12;
  ::google::protobuf::int32 scenestimelineindex() const;
  void set_scenestimelineindex(::google::protobuf::int32 value);

  // int32 entityListIndex = 13;
  void clear_entitylistindex();
  static const int kEntityListIndexFieldNumber = 13;
  ::google::protobuf::int32 entitylistindex() const;
  void set_entitylistindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMoveTimeline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      EntityMoveTimeline_PointMapEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > pointmap_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int entitymovetimelineendofplay_;
  float size_;
  ::google::protobuf::int32 lenght_;
  float playlenght_;
  bool isreflection_;
  bool ismove_;
  bool moveyaw_;
  ::google::protobuf::int32 scenestimelineindex_;
  ::google::protobuf::int32 entitylistindex_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMoveTimelineImpl();
};
// -------------------------------------------------------------------

class EntityPythonInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityPythonInfo) */ {
 public:
  EntityPythonInfo();
  virtual ~EntityPythonInfo();

  EntityPythonInfo(const EntityPythonInfo& from);

  inline EntityPythonInfo& operator=(const EntityPythonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityPythonInfo(EntityPythonInfo&& from) noexcept
    : EntityPythonInfo() {
    *this = ::std::move(from);
  }

  inline EntityPythonInfo& operator=(EntityPythonInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityPythonInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityPythonInfo* internal_default_instance() {
    return reinterpret_cast<const EntityPythonInfo*>(
               &_EntityPythonInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(EntityPythonInfo* other);
  friend void swap(EntityPythonInfo& a, EntityPythonInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityPythonInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityPythonInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityPythonInfo& from);
  void MergeFrom(const EntityPythonInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityPythonInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string py = 2;
  void clear_py();
  static const int kPyFieldNumber = 2;
  const ::std::string& py() const;
  void set_py(const ::std::string& value);
  #if LANG_CXX11
  void set_py(::std::string&& value);
  #endif
  void set_py(const char* value);
  void set_py(const char* value, size_t size);
  ::std::string* mutable_py();
  ::std::string* release_py();
  void set_allocated_py(::std::string* py);

  // .Gamedata.EntityPythonErrorType err = 1;
  void clear_err();
  static const int kErrFieldNumber = 1;
  ::Gamedata::EntityPythonErrorType err() const;
  void set_err(::Gamedata::EntityPythonErrorType value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityPythonInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr py_;
  int err_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityPythonInfoImpl();
};
// -------------------------------------------------------------------

class EntityCommandAuto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityCommandAuto) */ {
 public:
  EntityCommandAuto();
  virtual ~EntityCommandAuto();

  EntityCommandAuto(const EntityCommandAuto& from);

  inline EntityCommandAuto& operator=(const EntityCommandAuto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityCommandAuto(EntityCommandAuto&& from) noexcept
    : EntityCommandAuto() {
    *this = ::std::move(from);
  }

  inline EntityCommandAuto& operator=(EntityCommandAuto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityCommandAuto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityCommandAuto* internal_default_instance() {
    return reinterpret_cast<const EntityCommandAuto*>(
               &_EntityCommandAuto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(EntityCommandAuto* other);
  friend void swap(EntityCommandAuto& a, EntityCommandAuto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityCommandAuto* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityCommandAuto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityCommandAuto& from);
  void MergeFrom(const EntityCommandAuto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityCommandAuto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Gamedata.EntityCommandAuto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityCommandAutoImpl();
};
// -------------------------------------------------------------------

class EntityCommandCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityCommandCommand) */ {
 public:
  EntityCommandCommand();
  virtual ~EntityCommandCommand();

  EntityCommandCommand(const EntityCommandCommand& from);

  inline EntityCommandCommand& operator=(const EntityCommandCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityCommandCommand(EntityCommandCommand&& from) noexcept
    : EntityCommandCommand() {
    *this = ::std::move(from);
  }

  inline EntityCommandCommand& operator=(EntityCommandCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityCommandCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityCommandCommand* internal_default_instance() {
    return reinterpret_cast<const EntityCommandCommand*>(
               &_EntityCommandCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(EntityCommandCommand* other);
  friend void swap(EntityCommandCommand& a, EntityCommandCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityCommandCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityCommandCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityCommandCommand& from);
  void MergeFrom(const EntityCommandCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityCommandCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string command_name = 2;
  void clear_command_name();
  static const int kCommandNameFieldNumber = 2;
  const ::std::string& command_name() const;
  void set_command_name(const ::std::string& value);
  #if LANG_CXX11
  void set_command_name(::std::string&& value);
  #endif
  void set_command_name(const char* value);
  void set_command_name(const char* value, size_t size);
  ::std::string* mutable_command_name();
  ::std::string* release_command_name();
  void set_allocated_command_name(::std::string* command_name);

  // float start_time = 3;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  float start_time() const;
  void set_start_time(float value);

  // float end_time = 4;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  float end_time() const;
  void set_end_time(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityCommandCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr command_name_;
  float start_time_;
  float end_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityCommandCommandImpl();
};
// -------------------------------------------------------------------

class EntityCommandInteractive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityCommandInteractive) */ {
 public:
  EntityCommandInteractive();
  virtual ~EntityCommandInteractive();

  EntityCommandInteractive(const EntityCommandInteractive& from);

  inline EntityCommandInteractive& operator=(const EntityCommandInteractive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityCommandInteractive(EntityCommandInteractive&& from) noexcept
    : EntityCommandInteractive() {
    *this = ::std::move(from);
  }

  inline EntityCommandInteractive& operator=(EntityCommandInteractive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityCommandInteractive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityCommandInteractive* internal_default_instance() {
    return reinterpret_cast<const EntityCommandInteractive*>(
               &_EntityCommandInteractive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(EntityCommandInteractive* other);
  friend void swap(EntityCommandInteractive& a, EntityCommandInteractive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityCommandInteractive* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityCommandInteractive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityCommandInteractive& from);
  void MergeFrom(const EntityCommandInteractive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityCommandInteractive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_fixed_position = 1;
  void clear_is_fixed_position();
  static const int kIsFixedPositionFieldNumber = 1;
  bool is_fixed_position() const;
  void set_is_fixed_position(bool value);

  // bool is_open = 2;
  void clear_is_open();
  static const int kIsOpenFieldNumber = 2;
  bool is_open() const;
  void set_is_open(bool value);

  // float start_time = 3;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  float start_time() const;
  void set_start_time(float value);

  // float end_time = 4;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  float end_time() const;
  void set_end_time(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityCommandInteractive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_fixed_position_;
  bool is_open_;
  float start_time_;
  float end_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityCommandInteractiveImpl();
};
// -------------------------------------------------------------------

class EntityCommandTrigger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityCommandTrigger) */ {
 public:
  EntityCommandTrigger();
  virtual ~EntityCommandTrigger();

  EntityCommandTrigger(const EntityCommandTrigger& from);

  inline EntityCommandTrigger& operator=(const EntityCommandTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityCommandTrigger(EntityCommandTrigger&& from) noexcept
    : EntityCommandTrigger() {
    *this = ::std::move(from);
  }

  inline EntityCommandTrigger& operator=(EntityCommandTrigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityCommandTrigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityCommandTrigger* internal_default_instance() {
    return reinterpret_cast<const EntityCommandTrigger*>(
               &_EntityCommandTrigger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(EntityCommandTrigger* other);
  friend void swap(EntityCommandTrigger& a, EntityCommandTrigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityCommandTrigger* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityCommandTrigger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityCommandTrigger& from);
  void MergeFrom(const EntityCommandTrigger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityCommandTrigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_open = 1;
  void clear_is_open();
  static const int kIsOpenFieldNumber = 1;
  bool is_open() const;
  void set_is_open(bool value);

  // float start_time = 2;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  float start_time() const;
  void set_start_time(float value);

  // float end_time = 3;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  float end_time() const;
  void set_end_time(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityCommandTrigger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_open_;
  float start_time_;
  float end_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityCommandTriggerImpl();
};
// -------------------------------------------------------------------

class EntityCommandInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityCommandInfo) */ {
 public:
  EntityCommandInfo();
  virtual ~EntityCommandInfo();

  EntityCommandInfo(const EntityCommandInfo& from);

  inline EntityCommandInfo& operator=(const EntityCommandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityCommandInfo(EntityCommandInfo&& from) noexcept
    : EntityCommandInfo() {
    *this = ::std::move(from);
  }

  inline EntityCommandInfo& operator=(EntityCommandInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityCommandInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityCommandInfo* internal_default_instance() {
    return reinterpret_cast<const EntityCommandInfo*>(
               &_EntityCommandInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(EntityCommandInfo* other);
  friend void swap(EntityCommandInfo& a, EntityCommandInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityCommandInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityCommandInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityCommandInfo& from);
  void MergeFrom(const EntityCommandInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityCommandInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityCommandCommand command_list = 2;
  int command_list_size() const;
  void clear_command_list();
  static const int kCommandListFieldNumber = 2;
  const ::Gamedata::EntityCommandCommand& command_list(int index) const;
  ::Gamedata::EntityCommandCommand* mutable_command_list(int index);
  ::Gamedata::EntityCommandCommand* add_command_list();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityCommandCommand >*
      mutable_command_list();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityCommandCommand >&
      command_list() const;

  // .Gamedata.EntityCommandInteractive interactive = 3;
  bool has_interactive() const;
  void clear_interactive();
  static const int kInteractiveFieldNumber = 3;
  const ::Gamedata::EntityCommandInteractive& interactive() const;
  ::Gamedata::EntityCommandInteractive* release_interactive();
  ::Gamedata::EntityCommandInteractive* mutable_interactive();
  void set_allocated_interactive(::Gamedata::EntityCommandInteractive* interactive);

  // .Gamedata.EntityCommandTrigger trigger = 4;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 4;
  const ::Gamedata::EntityCommandTrigger& trigger() const;
  ::Gamedata::EntityCommandTrigger* release_trigger();
  ::Gamedata::EntityCommandTrigger* mutable_trigger();
  void set_allocated_trigger(::Gamedata::EntityCommandTrigger* trigger);

  // .Gamedata.EntityCommandType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Gamedata::EntityCommandType type() const;
  void set_type(::Gamedata::EntityCommandType value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityCommandInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityCommandCommand > command_list_;
  ::Gamedata::EntityCommandInteractive* interactive_;
  ::Gamedata::EntityCommandTrigger* trigger_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityCommandInfoImpl();
};
// -------------------------------------------------------------------

class EntityTransformTimelinePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityTransformTimelinePoint) */ {
 public:
  EntityTransformTimelinePoint();
  virtual ~EntityTransformTimelinePoint();

  EntityTransformTimelinePoint(const EntityTransformTimelinePoint& from);

  inline EntityTransformTimelinePoint& operator=(const EntityTransformTimelinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityTransformTimelinePoint(EntityTransformTimelinePoint&& from) noexcept
    : EntityTransformTimelinePoint() {
    *this = ::std::move(from);
  }

  inline EntityTransformTimelinePoint& operator=(EntityTransformTimelinePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityTransformTimelinePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityTransformTimelinePoint* internal_default_instance() {
    return reinterpret_cast<const EntityTransformTimelinePoint*>(
               &_EntityTransformTimelinePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(EntityTransformTimelinePoint* other);
  friend void swap(EntityTransformTimelinePoint& a, EntityTransformTimelinePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityTransformTimelinePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityTransformTimelinePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityTransformTimelinePoint& from);
  void MergeFrom(const EntityTransformTimelinePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityTransformTimelinePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::Gamedata::FVector& location() const;
  ::Gamedata::FVector* release_location();
  ::Gamedata::FVector* mutable_location();
  void set_allocated_location(::Gamedata::FVector* location);

  // .Gamedata.FRotator rotator = 3;
  bool has_rotator() const;
  void clear_rotator();
  static const int kRotatorFieldNumber = 3;
  const ::Gamedata::FRotator& rotator() const;
  ::Gamedata::FRotator* release_rotator();
  ::Gamedata::FRotator* mutable_rotator();
  void set_allocated_rotator(::Gamedata::FRotator* rotator);

  // .Gamedata.FVector color = 4;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::Gamedata::FVector& color() const;
  ::Gamedata::FVector* release_color();
  ::Gamedata::FVector* mutable_color();
  void set_allocated_color(::Gamedata::FVector* color);

  // int32 uniqueMark = 1;
  void clear_uniquemark();
  static const int kUniqueMarkFieldNumber = 1;
  ::google::protobuf::int32 uniquemark() const;
  void set_uniquemark(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityTransformTimelinePoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* location_;
  ::Gamedata::FRotator* rotator_;
  ::Gamedata::FVector* color_;
  ::google::protobuf::int32 uniquemark_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityTransformTimelinePointImpl();
};
// -------------------------------------------------------------------

class EntityTransformTimeline_PointMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<EntityTransformTimeline_PointMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<EntityTransformTimeline_PointMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  EntityTransformTimeline_PointMapEntry_DoNotUse();
  EntityTransformTimeline_PointMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const EntityTransformTimeline_PointMapEntry_DoNotUse& other);
  static const EntityTransformTimeline_PointMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EntityTransformTimeline_PointMapEntry_DoNotUse*>(&_EntityTransformTimeline_PointMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class EntityTransformTimeline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityTransformTimeline) */ {
 public:
  EntityTransformTimeline();
  virtual ~EntityTransformTimeline();

  EntityTransformTimeline(const EntityTransformTimeline& from);

  inline EntityTransformTimeline& operator=(const EntityTransformTimeline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityTransformTimeline(EntityTransformTimeline&& from) noexcept
    : EntityTransformTimeline() {
    *this = ::std::move(from);
  }

  inline EntityTransformTimeline& operator=(EntityTransformTimeline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityTransformTimeline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityTransformTimeline* internal_default_instance() {
    return reinterpret_cast<const EntityTransformTimeline*>(
               &_EntityTransformTimeline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(EntityTransformTimeline* other);
  friend void swap(EntityTransformTimeline& a, EntityTransformTimeline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityTransformTimeline* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityTransformTimeline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityTransformTimeline& from);
  void MergeFrom(const EntityTransformTimeline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityTransformTimeline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityTransformTimelinePoint> point_map = 1;
  int point_map_size() const;
  void clear_point_map();
  static const int kPointMapFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint >&
      point_map() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint >*
      mutable_point_map();

  // int32 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // .Gamedata.TimelineHighlightType timeline_highlight = 4;
  void clear_timeline_highlight();
  static const int kTimelineHighlightFieldNumber = 4;
  ::Gamedata::TimelineHighlightType timeline_highlight() const;
  void set_timeline_highlight(::Gamedata::TimelineHighlightType value);

  // bool is_loop = 2;
  void clear_is_loop();
  static const int kIsLoopFieldNumber = 2;
  bool is_loop() const;
  void set_is_loop(bool value);

  // bool location_teleport = 5;
  void clear_location_teleport();
  static const int kLocationTeleportFieldNumber = 5;
  bool location_teleport() const;
  void set_location_teleport(bool value);

  // bool color_teleport = 6;
  void clear_color_teleport();
  static const int kColorTeleportFieldNumber = 6;
  bool color_teleport() const;
  void set_color_teleport(bool value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityTransformTimeline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      EntityTransformTimeline_PointMapEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > point_map_;
  ::google::protobuf::int32 version_;
  int timeline_highlight_;
  bool is_loop_;
  bool location_teleport_;
  bool color_teleport_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityTransformTimelineImpl();
};
// -------------------------------------------------------------------

class EntityChildInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityChildInfo) */ {
 public:
  EntityChildInfo();
  virtual ~EntityChildInfo();

  EntityChildInfo(const EntityChildInfo& from);

  inline EntityChildInfo& operator=(const EntityChildInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityChildInfo(EntityChildInfo&& from) noexcept
    : EntityChildInfo() {
    *this = ::std::move(from);
  }

  inline EntityChildInfo& operator=(EntityChildInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityChildInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityChildInfo* internal_default_instance() {
    return reinterpret_cast<const EntityChildInfo*>(
               &_EntityChildInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(EntityChildInfo* other);
  friend void swap(EntityChildInfo& a, EntityChildInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityChildInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityChildInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityChildInfo& from);
  void MergeFrom(const EntityChildInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityChildInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FTransform transform = 2;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 2;
  const ::Gamedata::FTransform& transform() const;
  ::Gamedata::FTransform* release_transform();
  ::Gamedata::FTransform* mutable_transform();
  void set_allocated_transform(::Gamedata::FTransform* transform);

  // .Gamedata.EntityMMeshInfo mesh = 3;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 3;
  const ::Gamedata::EntityMMeshInfo& mesh() const;
  ::Gamedata::EntityMMeshInfo* release_mesh();
  ::Gamedata::EntityMMeshInfo* mutable_mesh();
  void set_allocated_mesh(::Gamedata::EntityMMeshInfo* mesh);

  // .Gamedata.EntityImageInfo image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  const ::Gamedata::EntityImageInfo& image() const;
  ::Gamedata::EntityImageInfo* release_image();
  ::Gamedata::EntityImageInfo* mutable_image();
  void set_allocated_image(::Gamedata::EntityImageInfo* image);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityChildInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FTransform* transform_;
  ::Gamedata::EntityMMeshInfo* mesh_;
  ::Gamedata::EntityImageInfo* image_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityChildInfoImpl();
};
// -------------------------------------------------------------------

class EntityMMeshInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMMeshInfo) */ {
 public:
  EntityMMeshInfo();
  virtual ~EntityMMeshInfo();

  EntityMMeshInfo(const EntityMMeshInfo& from);

  inline EntityMMeshInfo& operator=(const EntityMMeshInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMMeshInfo(EntityMMeshInfo&& from) noexcept
    : EntityMMeshInfo() {
    *this = ::std::move(from);
  }

  inline EntityMMeshInfo& operator=(EntityMMeshInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMMeshInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMMeshInfo* internal_default_instance() {
    return reinterpret_cast<const EntityMMeshInfo*>(
               &_EntityMMeshInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(EntityMMeshInfo* other);
  friend void swap(EntityMMeshInfo& a, EntityMMeshInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMMeshInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMMeshInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMMeshInfo& from);
  void MergeFrom(const EntityMMeshInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMMeshInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector color = 4;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::Gamedata::FVector& color() const;
  ::Gamedata::FVector* release_color();
  ::Gamedata::FVector* mutable_color();
  void set_allocated_color(::Gamedata::FVector* color);

  // int32 xls_id = 1;
  void clear_xls_id();
  static const int kXlsIdFieldNumber = 1;
  ::google::protobuf::int32 xls_id() const;
  void set_xls_id(::google::protobuf::int32 value);

  // int32 material_id = 2;
  void clear_material_id();
  static const int kMaterialIdFieldNumber = 2;
  ::google::protobuf::int32 material_id() const;
  void set_material_id(::google::protobuf::int32 value);

  // bool highlight = 3;
  void clear_highlight();
  static const int kHighlightFieldNumber = 3;
  bool highlight() const;
  void set_highlight(bool value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMMeshInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* color_;
  ::google::protobuf::int32 xls_id_;
  ::google::protobuf::int32 material_id_;
  bool highlight_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMMeshInfoImpl();
};
// -------------------------------------------------------------------

class EntityImageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityImageInfo) */ {
 public:
  EntityImageInfo();
  virtual ~EntityImageInfo();

  EntityImageInfo(const EntityImageInfo& from);

  inline EntityImageInfo& operator=(const EntityImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityImageInfo(EntityImageInfo&& from) noexcept
    : EntityImageInfo() {
    *this = ::std::move(from);
  }

  inline EntityImageInfo& operator=(EntityImageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityImageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityImageInfo* internal_default_instance() {
    return reinterpret_cast<const EntityImageInfo*>(
               &_EntityImageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(EntityImageInfo* other);
  friend void swap(EntityImageInfo& a, EntityImageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityImageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityImageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityImageInfo& from);
  void MergeFrom(const EntityImageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityImageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 8;
  void clear_url();
  static const int kUrlFieldNumber = 8;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityImageInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityImageInfoImpl();
};
// -------------------------------------------------------------------

class EntityInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityInfo) */ {
 public:
  EntityInfo();
  virtual ~EntityInfo();

  EntityInfo(const EntityInfo& from);

  inline EntityInfo& operator=(const EntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityInfo(EntityInfo&& from) noexcept
    : EntityInfo() {
    *this = ::std::move(from);
  }

  inline EntityInfo& operator=(EntityInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityInfo* internal_default_instance() {
    return reinterpret_cast<const EntityInfo*>(
               &_EntityInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(EntityInfo* other);
  friend void swap(EntityInfo& a, EntityInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityInfo& from);
  void MergeFrom(const EntityInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityChildInfo child_list = 5;
  int child_list_size() const;
  void clear_child_list();
  static const int kChildListFieldNumber = 5;
  const ::Gamedata::EntityChildInfo& child_list(int index) const;
  ::Gamedata::EntityChildInfo* mutable_child_list(int index);
  ::Gamedata::EntityChildInfo* add_child_list();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityChildInfo >*
      mutable_child_list();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityChildInfo >&
      child_list() const;

  // .Gamedata.FTransform transform = 3;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 3;
  const ::Gamedata::FTransform& transform() const;
  ::Gamedata::FTransform* release_transform();
  ::Gamedata::FTransform* mutable_transform();
  void set_allocated_transform(::Gamedata::FTransform* transform);

  // .Gamedata.EntitySplineAlone spline = 6;
  bool has_spline() const;
  void clear_spline();
  static const int kSplineFieldNumber = 6;
  const ::Gamedata::EntitySplineAlone& spline() const;
  ::Gamedata::EntitySplineAlone* release_spline();
  ::Gamedata::EntitySplineAlone* mutable_spline();
  void set_allocated_spline(::Gamedata::EntitySplineAlone* spline);

  // .Gamedata.EntityPythonInfo python_info = 7;
  bool has_python_info() const;
  void clear_python_info();
  static const int kPythonInfoFieldNumber = 7;
  const ::Gamedata::EntityPythonInfo& python_info() const;
  ::Gamedata::EntityPythonInfo* release_python_info();
  ::Gamedata::EntityPythonInfo* mutable_python_info();
  void set_allocated_python_info(::Gamedata::EntityPythonInfo* python_info);

  // .Gamedata.EntityTransformTimeline transform_timeline = 8;
  bool has_transform_timeline() const;
  void clear_transform_timeline();
  static const int kTransformTimelineFieldNumber = 8;
  const ::Gamedata::EntityTransformTimeline& transform_timeline() const;
  ::Gamedata::EntityTransformTimeline* release_transform_timeline();
  ::Gamedata::EntityTransformTimeline* mutable_transform_timeline();
  void set_allocated_transform_timeline(::Gamedata::EntityTransformTimeline* transform_timeline);

  // .Gamedata.EntityCommandInfo command = 9;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 9;
  const ::Gamedata::EntityCommandInfo& command() const;
  ::Gamedata::EntityCommandInfo* release_command();
  ::Gamedata::EntityCommandInfo* mutable_command();
  void set_allocated_command(::Gamedata::EntityCommandInfo* command);

  // int32 entityId = 1;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // .Gamedata.EntityCollisionType collision_type = 4;
  void clear_collision_type();
  static const int kCollisionTypeFieldNumber = 4;
  ::Gamedata::EntityCollisionType collision_type() const;
  void set_collision_type(::Gamedata::EntityCollisionType value);

  // int32 lockPlayerId = 10;
  void clear_lockplayerid();
  static const int kLockPlayerIdFieldNumber = 10;
  ::google::protobuf::int32 lockplayerid() const;
  void set_lockplayerid(::google::protobuf::int32 value);

  // .Gamedata.EntitySyncType entity_sync_type = 11;
  void clear_entity_sync_type();
  static const int kEntitySyncTypeFieldNumber = 11;
  ::Gamedata::EntitySyncType entity_sync_type() const;
  void set_entity_sync_type(::Gamedata::EntitySyncType value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityChildInfo > child_list_;
  ::Gamedata::FTransform* transform_;
  ::Gamedata::EntitySplineAlone* spline_;
  ::Gamedata::EntityPythonInfo* python_info_;
  ::Gamedata::EntityTransformTimeline* transform_timeline_;
  ::Gamedata::EntityCommandInfo* command_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 playerid_;
  int collision_type_;
  ::google::protobuf::int32 lockplayerid_;
  int entity_sync_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityInfoImpl();
};
// -------------------------------------------------------------------

class EntityEnterView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityEnterView) */ {
 public:
  EntityEnterView();
  virtual ~EntityEnterView();

  EntityEnterView(const EntityEnterView& from);

  inline EntityEnterView& operator=(const EntityEnterView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityEnterView(EntityEnterView&& from) noexcept
    : EntityEnterView() {
    *this = ::std::move(from);
  }

  inline EntityEnterView& operator=(EntityEnterView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityEnterView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityEnterView* internal_default_instance() {
    return reinterpret_cast<const EntityEnterView*>(
               &_EntityEnterView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(EntityEnterView* other);
  friend void swap(EntityEnterView& a, EntityEnterView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityEnterView* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityEnterView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityEnterView& from);
  void MergeFrom(const EntityEnterView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityEnterView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityInfo entityInfoList = 1;
  int entityinfolist_size() const;
  void clear_entityinfolist();
  static const int kEntityInfoListFieldNumber = 1;
  const ::Gamedata::EntityInfo& entityinfolist(int index) const;
  ::Gamedata::EntityInfo* mutable_entityinfolist(int index);
  ::Gamedata::EntityInfo* add_entityinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
      mutable_entityinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
      entityinfolist() const;

  // @@protoc_insertion_point(class_scope:Gamedata.EntityEnterView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo > entityinfolist_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityEnterViewImpl();
};
// -------------------------------------------------------------------

class EntityUpdateView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityUpdateView) */ {
 public:
  EntityUpdateView();
  virtual ~EntityUpdateView();

  EntityUpdateView(const EntityUpdateView& from);

  inline EntityUpdateView& operator=(const EntityUpdateView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityUpdateView(EntityUpdateView&& from) noexcept
    : EntityUpdateView() {
    *this = ::std::move(from);
  }

  inline EntityUpdateView& operator=(EntityUpdateView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityUpdateView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityUpdateView* internal_default_instance() {
    return reinterpret_cast<const EntityUpdateView*>(
               &_EntityUpdateView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(EntityUpdateView* other);
  friend void swap(EntityUpdateView& a, EntityUpdateView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityUpdateView* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityUpdateView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityUpdateView& from);
  void MergeFrom(const EntityUpdateView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityUpdateView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityInfo entityInfoList = 1;
  int entityinfolist_size() const;
  void clear_entityinfolist();
  static const int kEntityInfoListFieldNumber = 1;
  const ::Gamedata::EntityInfo& entityinfolist(int index) const;
  ::Gamedata::EntityInfo* mutable_entityinfolist(int index);
  ::Gamedata::EntityInfo* add_entityinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
      mutable_entityinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
      entityinfolist() const;

  // @@protoc_insertion_point(class_scope:Gamedata.EntityUpdateView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo > entityinfolist_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityUpdateViewImpl();
};
// -------------------------------------------------------------------

class EntityLeaveView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityLeaveView) */ {
 public:
  EntityLeaveView();
  virtual ~EntityLeaveView();

  EntityLeaveView(const EntityLeaveView& from);

  inline EntityLeaveView& operator=(const EntityLeaveView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityLeaveView(EntityLeaveView&& from) noexcept
    : EntityLeaveView() {
    *this = ::std::move(from);
  }

  inline EntityLeaveView& operator=(EntityLeaveView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityLeaveView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityLeaveView* internal_default_instance() {
    return reinterpret_cast<const EntityLeaveView*>(
               &_EntityLeaveView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(EntityLeaveView* other);
  friend void swap(EntityLeaveView& a, EntityLeaveView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityLeaveView* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityLeaveView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityLeaveView& from);
  void MergeFrom(const EntityLeaveView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityLeaveView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 entityIdList = 1;
  int entityidlist_size() const;
  void clear_entityidlist();
  static const int kEntityIdListFieldNumber = 1;
  ::google::protobuf::int32 entityidlist(int index) const;
  void set_entityidlist(int index, ::google::protobuf::int32 value);
  void add_entityidlist(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entityidlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entityidlist();

  // @@protoc_insertion_point(class_scope:Gamedata.EntityLeaveView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entityidlist_;
  mutable int _entityidlist_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityLeaveViewImpl();
};
// -------------------------------------------------------------------

class EntityAddRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityAddRequest) */ {
 public:
  EntityAddRequest();
  virtual ~EntityAddRequest();

  EntityAddRequest(const EntityAddRequest& from);

  inline EntityAddRequest& operator=(const EntityAddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityAddRequest(EntityAddRequest&& from) noexcept
    : EntityAddRequest() {
    *this = ::std::move(from);
  }

  inline EntityAddRequest& operator=(EntityAddRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityAddRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityAddRequest* internal_default_instance() {
    return reinterpret_cast<const EntityAddRequest*>(
               &_EntityAddRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(EntityAddRequest* other);
  friend void swap(EntityAddRequest& a, EntityAddRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityAddRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityAddRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityAddRequest& from);
  void MergeFrom(const EntityAddRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityAddRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityInfo entityInfoList = 1;
  int entityinfolist_size() const;
  void clear_entityinfolist();
  static const int kEntityInfoListFieldNumber = 1;
  const ::Gamedata::EntityInfo& entityinfolist(int index) const;
  ::Gamedata::EntityInfo* mutable_entityinfolist(int index);
  ::Gamedata::EntityInfo* add_entityinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
      mutable_entityinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
      entityinfolist() const;

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityAddRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo > entityinfolist_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityAddRequestImpl();
};
// -------------------------------------------------------------------

class EntityRemoveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityRemoveRequest) */ {
 public:
  EntityRemoveRequest();
  virtual ~EntityRemoveRequest();

  EntityRemoveRequest(const EntityRemoveRequest& from);

  inline EntityRemoveRequest& operator=(const EntityRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityRemoveRequest(EntityRemoveRequest&& from) noexcept
    : EntityRemoveRequest() {
    *this = ::std::move(from);
  }

  inline EntityRemoveRequest& operator=(EntityRemoveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityRemoveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityRemoveRequest* internal_default_instance() {
    return reinterpret_cast<const EntityRemoveRequest*>(
               &_EntityRemoveRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(EntityRemoveRequest* other);
  friend void swap(EntityRemoveRequest& a, EntityRemoveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityRemoveRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityRemoveRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityRemoveRequest& from);
  void MergeFrom(const EntityRemoveRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityRemoveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 entityIdList = 1;
  int entityidlist_size() const;
  void clear_entityidlist();
  static const int kEntityIdListFieldNumber = 1;
  ::google::protobuf::int32 entityidlist(int index) const;
  void set_entityidlist(int index, ::google::protobuf::int32 value);
  void add_entityidlist(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entityidlist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entityidlist();

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityRemoveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entityidlist_;
  mutable int _entityidlist_cached_byte_size_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityRemoveRequestImpl();
};
// -------------------------------------------------------------------

class EntityUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityUpdateRequest) */ {
 public:
  EntityUpdateRequest();
  virtual ~EntityUpdateRequest();

  EntityUpdateRequest(const EntityUpdateRequest& from);

  inline EntityUpdateRequest& operator=(const EntityUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityUpdateRequest(EntityUpdateRequest&& from) noexcept
    : EntityUpdateRequest() {
    *this = ::std::move(from);
  }

  inline EntityUpdateRequest& operator=(EntityUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityUpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const EntityUpdateRequest*>(
               &_EntityUpdateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(EntityUpdateRequest* other);
  friend void swap(EntityUpdateRequest& a, EntityUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityUpdateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityUpdateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityUpdateRequest& from);
  void MergeFrom(const EntityUpdateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityInfo entityInfoList = 1;
  int entityinfolist_size() const;
  void clear_entityinfolist();
  static const int kEntityInfoListFieldNumber = 1;
  const ::Gamedata::EntityInfo& entityinfolist(int index) const;
  ::Gamedata::EntityInfo* mutable_entityinfolist(int index);
  ::Gamedata::EntityInfo* add_entityinfolist();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
      mutable_entityinfolist();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
      entityinfolist() const;

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo > entityinfolist_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityUpdateRequestImpl();
};
// -------------------------------------------------------------------

class EntityOperationValue1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityOperationValue1) */ {
 public:
  EntityOperationValue1();
  virtual ~EntityOperationValue1();

  EntityOperationValue1(const EntityOperationValue1& from);

  inline EntityOperationValue1& operator=(const EntityOperationValue1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityOperationValue1(EntityOperationValue1&& from) noexcept
    : EntityOperationValue1() {
    *this = ::std::move(from);
  }

  inline EntityOperationValue1& operator=(EntityOperationValue1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOperationValue1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityOperationValue1* internal_default_instance() {
    return reinterpret_cast<const EntityOperationValue1*>(
               &_EntityOperationValue1_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(EntityOperationValue1* other);
  friend void swap(EntityOperationValue1& a, EntityOperationValue1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityOperationValue1* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityOperationValue1* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityOperationValue1& from);
  void MergeFrom(const EntityOperationValue1& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityOperationValue1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isPlay = 1;
  void clear_isplay();
  static const int kIsPlayFieldNumber = 1;
  bool isplay() const;
  void set_isplay(bool value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityOperationValue1)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool isplay_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityOperationValue1Impl();
};
// -------------------------------------------------------------------

class EntityOperationValue2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityOperationValue2) */ {
 public:
  EntityOperationValue2();
  virtual ~EntityOperationValue2();

  EntityOperationValue2(const EntityOperationValue2& from);

  inline EntityOperationValue2& operator=(const EntityOperationValue2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityOperationValue2(EntityOperationValue2&& from) noexcept
    : EntityOperationValue2() {
    *this = ::std::move(from);
  }

  inline EntityOperationValue2& operator=(EntityOperationValue2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOperationValue2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityOperationValue2* internal_default_instance() {
    return reinterpret_cast<const EntityOperationValue2*>(
               &_EntityOperationValue2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(EntityOperationValue2* other);
  friend void swap(EntityOperationValue2& a, EntityOperationValue2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityOperationValue2* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityOperationValue2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityOperationValue2& from);
  void MergeFrom(const EntityOperationValue2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityOperationValue2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isPlay = 1;
  void clear_isplay();
  static const int kIsPlayFieldNumber = 1;
  bool isplay() const;
  void set_isplay(bool value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityOperationValue2)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool isplay_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityOperationValue2Impl();
};
// -------------------------------------------------------------------

class EntityOperationAlone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityOperationAlone) */ {
 public:
  EntityOperationAlone();
  virtual ~EntityOperationAlone();

  EntityOperationAlone(const EntityOperationAlone& from);

  inline EntityOperationAlone& operator=(const EntityOperationAlone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityOperationAlone(EntityOperationAlone&& from) noexcept
    : EntityOperationAlone() {
    *this = ::std::move(from);
  }

  inline EntityOperationAlone& operator=(EntityOperationAlone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOperationAlone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityOperationAlone* internal_default_instance() {
    return reinterpret_cast<const EntityOperationAlone*>(
               &_EntityOperationAlone_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(EntityOperationAlone* other);
  friend void swap(EntityOperationAlone& a, EntityOperationAlone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityOperationAlone* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityOperationAlone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityOperationAlone& from);
  void MergeFrom(const EntityOperationAlone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityOperationAlone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityOperationValue1 value1 = 4;
  int value1_size() const;
  void clear_value1();
  static const int kValue1FieldNumber = 4;
  const ::Gamedata::EntityOperationValue1& value1(int index) const;
  ::Gamedata::EntityOperationValue1* mutable_value1(int index);
  ::Gamedata::EntityOperationValue1* add_value1();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue1 >*
      mutable_value1();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue1 >&
      value1() const;

  // repeated .Gamedata.EntityOperationValue2 value2 = 5;
  int value2_size() const;
  void clear_value2();
  static const int kValue2FieldNumber = 5;
  const ::Gamedata::EntityOperationValue2& value2(int index) const;
  ::Gamedata::EntityOperationValue2* mutable_value2(int index);
  ::Gamedata::EntityOperationValue2* add_value2();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue2 >*
      mutable_value2();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue2 >&
      value2() const;

  // .Gamedata.EntityOperationType theType = 1;
  void clear_thetype();
  static const int kTheTypeFieldNumber = 1;
  ::Gamedata::EntityOperationType thetype() const;
  void set_thetype(::Gamedata::EntityOperationType value);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // int32 entityId = 3;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 3;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityOperationAlone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue1 > value1_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue2 > value2_;
  int thetype_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 entityid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityOperationAloneImpl();
};
// -------------------------------------------------------------------

class EntityOperationTotal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityOperationTotal) */ {
 public:
  EntityOperationTotal();
  virtual ~EntityOperationTotal();

  EntityOperationTotal(const EntityOperationTotal& from);

  inline EntityOperationTotal& operator=(const EntityOperationTotal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityOperationTotal(EntityOperationTotal&& from) noexcept
    : EntityOperationTotal() {
    *this = ::std::move(from);
  }

  inline EntityOperationTotal& operator=(EntityOperationTotal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOperationTotal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityOperationTotal* internal_default_instance() {
    return reinterpret_cast<const EntityOperationTotal*>(
               &_EntityOperationTotal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(EntityOperationTotal* other);
  friend void swap(EntityOperationTotal& a, EntityOperationTotal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityOperationTotal* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityOperationTotal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityOperationTotal& from);
  void MergeFrom(const EntityOperationTotal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityOperationTotal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityOperationAlone node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::Gamedata::EntityOperationAlone& node(int index) const;
  ::Gamedata::EntityOperationAlone* mutable_node(int index);
  ::Gamedata::EntityOperationAlone* add_node();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationAlone >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationAlone >&
      node() const;

  // @@protoc_insertion_point(class_scope:Gamedata.EntityOperationTotal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationAlone > node_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityOperationTotalImpl();
};
// -------------------------------------------------------------------

class OverallSituationSkyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.OverallSituationSkyInfo) */ {
 public:
  OverallSituationSkyInfo();
  virtual ~OverallSituationSkyInfo();

  OverallSituationSkyInfo(const OverallSituationSkyInfo& from);

  inline OverallSituationSkyInfo& operator=(const OverallSituationSkyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverallSituationSkyInfo(OverallSituationSkyInfo&& from) noexcept
    : OverallSituationSkyInfo() {
    *this = ::std::move(from);
  }

  inline OverallSituationSkyInfo& operator=(OverallSituationSkyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OverallSituationSkyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverallSituationSkyInfo* internal_default_instance() {
    return reinterpret_cast<const OverallSituationSkyInfo*>(
               &_OverallSituationSkyInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(OverallSituationSkyInfo* other);
  friend void swap(OverallSituationSkyInfo& a, OverallSituationSkyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverallSituationSkyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  OverallSituationSkyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OverallSituationSkyInfo& from);
  void MergeFrom(const OverallSituationSkyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OverallSituationSkyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // int32 weather = 2;
  void clear_weather();
  static const int kWeatherFieldNumber = 2;
  ::google::protobuf::int32 weather() const;
  void set_weather(::google::protobuf::int32 value);

  // int32 cloud_coverageoverall = 3;
  void clear_cloud_coverageoverall();
  static const int kCloudCoverageoverallFieldNumber = 3;
  ::google::protobuf::int32 cloud_coverageoverall() const;
  void set_cloud_coverageoverall(::google::protobuf::int32 value);

  // int32 cloud_speed = 4;
  void clear_cloud_speed();
  static const int kCloudSpeedFieldNumber = 4;
  ::google::protobuf::int32 cloud_speed() const;
  void set_cloud_speed(::google::protobuf::int32 value);

  // int32 moon_color = 5;
  void clear_moon_color();
  static const int kMoonColorFieldNumber = 5;
  ::google::protobuf::int32 moon_color() const;
  void set_moon_color(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.OverallSituationSkyInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 weather_;
  ::google::protobuf::int32 cloud_coverageoverall_;
  ::google::protobuf::int32 cloud_speed_;
  ::google::protobuf::int32 moon_color_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsOverallSituationSkyInfoImpl();
};
// -------------------------------------------------------------------

class EntityMeshChildInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMeshChildInfo) */ {
 public:
  EntityMeshChildInfo();
  virtual ~EntityMeshChildInfo();

  EntityMeshChildInfo(const EntityMeshChildInfo& from);

  inline EntityMeshChildInfo& operator=(const EntityMeshChildInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMeshChildInfo(EntityMeshChildInfo&& from) noexcept
    : EntityMeshChildInfo() {
    *this = ::std::move(from);
  }

  inline EntityMeshChildInfo& operator=(EntityMeshChildInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMeshChildInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMeshChildInfo* internal_default_instance() {
    return reinterpret_cast<const EntityMeshChildInfo*>(
               &_EntityMeshChildInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(EntityMeshChildInfo* other);
  friend void swap(EntityMeshChildInfo& a, EntityMeshChildInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMeshChildInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMeshChildInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMeshChildInfo& from);
  void MergeFrom(const EntityMeshChildInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMeshChildInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FTransform transform = 7;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 7;
  const ::Gamedata::FTransform& transform() const;
  ::Gamedata::FTransform* release_transform();
  ::Gamedata::FTransform* mutable_transform();
  void set_allocated_transform(::Gamedata::FTransform* transform);

  // int32 xlsId = 4;
  void clear_xlsid();
  static const int kXlsIdFieldNumber = 4;
  ::google::protobuf::int32 xlsid() const;
  void set_xlsid(::google::protobuf::int32 value);

  // int32 materialId = 5;
  void clear_materialid();
  static const int kMaterialIdFieldNumber = 5;
  ::google::protobuf::int32 materialid() const;
  void set_materialid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMeshChildInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FTransform* transform_;
  ::google::protobuf::int32 xlsid_;
  ::google::protobuf::int32 materialid_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMeshChildInfoImpl();
};
// -------------------------------------------------------------------

class EntityMeshMasterInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EntityMeshMasterInfo) */ {
 public:
  EntityMeshMasterInfo();
  virtual ~EntityMeshMasterInfo();

  EntityMeshMasterInfo(const EntityMeshMasterInfo& from);

  inline EntityMeshMasterInfo& operator=(const EntityMeshMasterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMeshMasterInfo(EntityMeshMasterInfo&& from) noexcept
    : EntityMeshMasterInfo() {
    *this = ::std::move(from);
  }

  inline EntityMeshMasterInfo& operator=(EntityMeshMasterInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMeshMasterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMeshMasterInfo* internal_default_instance() {
    return reinterpret_cast<const EntityMeshMasterInfo*>(
               &_EntityMeshMasterInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(EntityMeshMasterInfo* other);
  friend void swap(EntityMeshMasterInfo& a, EntityMeshMasterInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMeshMasterInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMeshMasterInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMeshMasterInfo& from);
  void MergeFrom(const EntityMeshMasterInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMeshMasterInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.EntityMeshChildInfo child = 7;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 7;
  const ::Gamedata::EntityMeshChildInfo& child(int index) const;
  ::Gamedata::EntityMeshChildInfo* mutable_child(int index);
  ::Gamedata::EntityMeshChildInfo* add_child();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityMeshChildInfo >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityMeshChildInfo >&
      child() const;

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // int32 player_id = 2;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // int32 xls_id = 3;
  void clear_xls_id();
  static const int kXlsIdFieldNumber = 3;
  ::google::protobuf::int32 xls_id() const;
  void set_xls_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.EntityMeshMasterInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityMeshChildInfo > child_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 player_id_;
  ::google::protobuf::int32 xls_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEntityMeshMasterInfoImpl();
};
// -------------------------------------------------------------------

class OverallSituationData_ActorListEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OverallSituationData_ActorListEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<OverallSituationData_ActorListEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  OverallSituationData_ActorListEntry_DoNotUse();
  OverallSituationData_ActorListEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OverallSituationData_ActorListEntry_DoNotUse& other);
  static const OverallSituationData_ActorListEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverallSituationData_ActorListEntry_DoNotUse*>(&_OverallSituationData_ActorListEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OverallSituationData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.OverallSituationData) */ {
 public:
  OverallSituationData();
  virtual ~OverallSituationData();

  OverallSituationData(const OverallSituationData& from);

  inline OverallSituationData& operator=(const OverallSituationData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverallSituationData(OverallSituationData&& from) noexcept
    : OverallSituationData() {
    *this = ::std::move(from);
  }

  inline OverallSituationData& operator=(OverallSituationData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OverallSituationData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverallSituationData* internal_default_instance() {
    return reinterpret_cast<const OverallSituationData*>(
               &_OverallSituationData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(OverallSituationData* other);
  friend void swap(OverallSituationData& a, OverallSituationData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverallSituationData* New() const PROTOBUF_FINAL { return New(NULL); }

  OverallSituationData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OverallSituationData& from);
  void MergeFrom(const OverallSituationData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OverallSituationData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityMeshMasterInfo> actor_list = 1;
  int actor_list_size() const;
  void clear_actor_list();
  static const int kActorListFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >&
      actor_list() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >*
      mutable_actor_list();

  // .Gamedata.OverallSituationSkyInfo sky_info = 2;
  bool has_sky_info() const;
  void clear_sky_info();
  static const int kSkyInfoFieldNumber = 2;
  const ::Gamedata::OverallSituationSkyInfo& sky_info() const;
  ::Gamedata::OverallSituationSkyInfo* release_sky_info();
  ::Gamedata::OverallSituationSkyInfo* mutable_sky_info();
  void set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info);

  // @@protoc_insertion_point(class_scope:Gamedata.OverallSituationData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      OverallSituationData_ActorListEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > actor_list_;
  ::Gamedata::OverallSituationSkyInfo* sky_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsOverallSituationDataImpl();
};
// -------------------------------------------------------------------

class OverallSituationDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.OverallSituationDataRequest) */ {
 public:
  OverallSituationDataRequest();
  virtual ~OverallSituationDataRequest();

  OverallSituationDataRequest(const OverallSituationDataRequest& from);

  inline OverallSituationDataRequest& operator=(const OverallSituationDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverallSituationDataRequest(OverallSituationDataRequest&& from) noexcept
    : OverallSituationDataRequest() {
    *this = ::std::move(from);
  }

  inline OverallSituationDataRequest& operator=(OverallSituationDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OverallSituationDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverallSituationDataRequest* internal_default_instance() {
    return reinterpret_cast<const OverallSituationDataRequest*>(
               &_OverallSituationDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(OverallSituationDataRequest* other);
  friend void swap(OverallSituationDataRequest& a, OverallSituationDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverallSituationDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  OverallSituationDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OverallSituationDataRequest& from);
  void MergeFrom(const OverallSituationDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OverallSituationDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.OverallSituationSkyInfo sky_info = 4;
  bool has_sky_info() const;
  void clear_sky_info();
  static const int kSkyInfoFieldNumber = 4;
  const ::Gamedata::OverallSituationSkyInfo& sky_info() const;
  ::Gamedata::OverallSituationSkyInfo* release_sky_info();
  ::Gamedata::OverallSituationSkyInfo* mutable_sky_info();
  void set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info);

  // .Gamedata.EntityMeshMasterInfo actor_add = 5;
  bool has_actor_add() const;
  void clear_actor_add();
  static const int kActorAddFieldNumber = 5;
  const ::Gamedata::EntityMeshMasterInfo& actor_add() const;
  ::Gamedata::EntityMeshMasterInfo* release_actor_add();
  ::Gamedata::EntityMeshMasterInfo* mutable_actor_add();
  void set_allocated_actor_add(::Gamedata::EntityMeshMasterInfo* actor_add);

  // .Gamedata.FTransform actor_add_transform = 6;
  bool has_actor_add_transform() const;
  void clear_actor_add_transform();
  static const int kActorAddTransformFieldNumber = 6;
  const ::Gamedata::FTransform& actor_add_transform() const;
  ::Gamedata::FTransform* release_actor_add_transform();
  ::Gamedata::FTransform* mutable_actor_add_transform();
  void set_allocated_actor_add_transform(::Gamedata::FTransform* actor_add_transform);

  // .Gamedata.EntityMeshMasterInfo actor_update = 7;
  bool has_actor_update() const;
  void clear_actor_update();
  static const int kActorUpdateFieldNumber = 7;
  const ::Gamedata::EntityMeshMasterInfo& actor_update() const;
  ::Gamedata::EntityMeshMasterInfo* release_actor_update();
  ::Gamedata::EntityMeshMasterInfo* mutable_actor_update();
  void set_allocated_actor_update(::Gamedata::EntityMeshMasterInfo* actor_update);

  // .Gamedata.FTransform actor_update_transform = 8;
  bool has_actor_update_transform() const;
  void clear_actor_update_transform();
  static const int kActorUpdateTransformFieldNumber = 8;
  const ::Gamedata::FTransform& actor_update_transform() const;
  ::Gamedata::FTransform* release_actor_update_transform();
  ::Gamedata::FTransform* mutable_actor_update_transform();
  void set_allocated_actor_update_transform(::Gamedata::FTransform* actor_update_transform);

  // int32 player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // .Gamedata.OverallSituationDataType set_type = 2;
  void clear_set_type();
  static const int kSetTypeFieldNumber = 2;
  ::Gamedata::OverallSituationDataType set_type() const;
  void set_set_type(::Gamedata::OverallSituationDataType value);

  // int32 actor_delete = 9;
  void clear_actor_delete();
  static const int kActorDeleteFieldNumber = 9;
  ::google::protobuf::int32 actor_delete() const;
  void set_actor_delete(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.OverallSituationDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::OverallSituationSkyInfo* sky_info_;
  ::Gamedata::EntityMeshMasterInfo* actor_add_;
  ::Gamedata::FTransform* actor_add_transform_;
  ::Gamedata::EntityMeshMasterInfo* actor_update_;
  ::Gamedata::FTransform* actor_update_transform_;
  ::google::protobuf::int32 player_id_;
  int set_type_;
  ::google::protobuf::int32 actor_delete_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsOverallSituationDataRequestImpl();
};
// -------------------------------------------------------------------

class OverallSituationDataResponse_ActorListEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OverallSituationDataResponse_ActorListEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<OverallSituationDataResponse_ActorListEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  OverallSituationDataResponse_ActorListEntry_DoNotUse();
  OverallSituationDataResponse_ActorListEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OverallSituationDataResponse_ActorListEntry_DoNotUse& other);
  static const OverallSituationDataResponse_ActorListEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OverallSituationDataResponse_ActorListEntry_DoNotUse*>(&_OverallSituationDataResponse_ActorListEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OverallSituationDataResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.OverallSituationDataResponse) */ {
 public:
  OverallSituationDataResponse();
  virtual ~OverallSituationDataResponse();

  OverallSituationDataResponse(const OverallSituationDataResponse& from);

  inline OverallSituationDataResponse& operator=(const OverallSituationDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverallSituationDataResponse(OverallSituationDataResponse&& from) noexcept
    : OverallSituationDataResponse() {
    *this = ::std::move(from);
  }

  inline OverallSituationDataResponse& operator=(OverallSituationDataResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OverallSituationDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverallSituationDataResponse* internal_default_instance() {
    return reinterpret_cast<const OverallSituationDataResponse*>(
               &_OverallSituationDataResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(OverallSituationDataResponse* other);
  friend void swap(OverallSituationDataResponse& a, OverallSituationDataResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverallSituationDataResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  OverallSituationDataResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OverallSituationDataResponse& from);
  void MergeFrom(const OverallSituationDataResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OverallSituationDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.EntityMeshMasterInfo> actor_list = 5;
  int actor_list_size() const;
  void clear_actor_list();
  static const int kActorListFieldNumber = 5;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >&
      actor_list() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >*
      mutable_actor_list();

  // .Gamedata.OverallSituationData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::Gamedata::OverallSituationData& data() const;
  ::Gamedata::OverallSituationData* release_data();
  ::Gamedata::OverallSituationData* mutable_data();
  void set_allocated_data(::Gamedata::OverallSituationData* data);

  // .Gamedata.OverallSituationSkyInfo sky_info = 4;
  bool has_sky_info() const;
  void clear_sky_info();
  static const int kSkyInfoFieldNumber = 4;
  const ::Gamedata::OverallSituationSkyInfo& sky_info() const;
  ::Gamedata::OverallSituationSkyInfo* release_sky_info();
  ::Gamedata::OverallSituationSkyInfo* mutable_sky_info();
  void set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info);

  // .Gamedata.EntityMeshMasterInfo actor_add = 6;
  bool has_actor_add() const;
  void clear_actor_add();
  static const int kActorAddFieldNumber = 6;
  const ::Gamedata::EntityMeshMasterInfo& actor_add() const;
  ::Gamedata::EntityMeshMasterInfo* release_actor_add();
  ::Gamedata::EntityMeshMasterInfo* mutable_actor_add();
  void set_allocated_actor_add(::Gamedata::EntityMeshMasterInfo* actor_add);

  // .Gamedata.FTransform actor_add_transform = 7;
  bool has_actor_add_transform() const;
  void clear_actor_add_transform();
  static const int kActorAddTransformFieldNumber = 7;
  const ::Gamedata::FTransform& actor_add_transform() const;
  ::Gamedata::FTransform* release_actor_add_transform();
  ::Gamedata::FTransform* mutable_actor_add_transform();
  void set_allocated_actor_add_transform(::Gamedata::FTransform* actor_add_transform);

  // .Gamedata.EntityMeshMasterInfo actor_update = 8;
  bool has_actor_update() const;
  void clear_actor_update();
  static const int kActorUpdateFieldNumber = 8;
  const ::Gamedata::EntityMeshMasterInfo& actor_update() const;
  ::Gamedata::EntityMeshMasterInfo* release_actor_update();
  ::Gamedata::EntityMeshMasterInfo* mutable_actor_update();
  void set_allocated_actor_update(::Gamedata::EntityMeshMasterInfo* actor_update);

  // .Gamedata.FTransform actor_update_transform = 9;
  bool has_actor_update_transform() const;
  void clear_actor_update_transform();
  static const int kActorUpdateTransformFieldNumber = 9;
  const ::Gamedata::FTransform& actor_update_transform() const;
  ::Gamedata::FTransform* release_actor_update_transform();
  ::Gamedata::FTransform* mutable_actor_update_transform();
  void set_allocated_actor_update_transform(::Gamedata::FTransform* actor_update_transform);

  // .Gamedata.OverallSituationDataType set_type = 1;
  void clear_set_type();
  static const int kSetTypeFieldNumber = 1;
  ::Gamedata::OverallSituationDataType set_type() const;
  void set_set_type(::Gamedata::OverallSituationDataType value);

  // int32 actor_delete = 10;
  void clear_actor_delete();
  static const int kActorDeleteFieldNumber = 10;
  ::google::protobuf::int32 actor_delete() const;
  void set_actor_delete(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.OverallSituationDataResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      OverallSituationDataResponse_ActorListEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > actor_list_;
  ::Gamedata::OverallSituationData* data_;
  ::Gamedata::OverallSituationSkyInfo* sky_info_;
  ::Gamedata::EntityMeshMasterInfo* actor_add_;
  ::Gamedata::FTransform* actor_add_transform_;
  ::Gamedata::EntityMeshMasterInfo* actor_update_;
  ::Gamedata::FTransform* actor_update_transform_;
  int set_type_;
  ::google::protobuf::int32 actor_delete_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsOverallSituationDataResponseImpl();
};
// -------------------------------------------------------------------

class EventCommandInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EventCommandInfo) */ {
 public:
  EventCommandInfo();
  virtual ~EventCommandInfo();

  EventCommandInfo(const EventCommandInfo& from);

  inline EventCommandInfo& operator=(const EventCommandInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventCommandInfo(EventCommandInfo&& from) noexcept
    : EventCommandInfo() {
    *this = ::std::move(from);
  }

  inline EventCommandInfo& operator=(EventCommandInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventCommandInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventCommandInfo* internal_default_instance() {
    return reinterpret_cast<const EventCommandInfo*>(
               &_EventCommandInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(EventCommandInfo* other);
  friend void swap(EventCommandInfo& a, EventCommandInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventCommandInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EventCommandInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventCommandInfo& from);
  void MergeFrom(const EventCommandInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventCommandInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 entity_list = 2;
  int entity_list_size() const;
  void clear_entity_list();
  static const int kEntityListFieldNumber = 2;
  ::google::protobuf::int32 entity_list(int index) const;
  void set_entity_list(int index, ::google::protobuf::int32 value);
  void add_entity_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entity_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entity_list();

  // string command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::std::string& command() const;
  void set_command(const ::std::string& value);
  #if LANG_CXX11
  void set_command(::std::string&& value);
  #endif
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  ::std::string* mutable_command();
  ::std::string* release_command();
  void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:Gamedata.EventCommandInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entity_list_;
  mutable int _entity_list_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr command_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEventCommandInfoImpl();
};
// -------------------------------------------------------------------

class EventInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.EventInfo) */ {
 public:
  EventInfo();
  virtual ~EventInfo();

  EventInfo(const EventInfo& from);

  inline EventInfo& operator=(const EventInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventInfo(EventInfo&& from) noexcept
    : EventInfo() {
    *this = ::std::move(from);
  }

  inline EventInfo& operator=(EventInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventInfo* internal_default_instance() {
    return reinterpret_cast<const EventInfo*>(
               &_EventInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(EventInfo* other);
  friend void swap(EventInfo& a, EventInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EventInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventInfo& from);
  void MergeFrom(const EventInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 broadcast_player_list = 4;
  int broadcast_player_list_size() const;
  void clear_broadcast_player_list();
  static const int kBroadcastPlayerListFieldNumber = 4;
  ::google::protobuf::int32 broadcast_player_list(int index) const;
  void set_broadcast_player_list(int index, ::google::protobuf::int32 value);
  void add_broadcast_player_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      broadcast_player_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_broadcast_player_list();

  // .Gamedata.EventCommandInfo command_info = 5;
  bool has_command_info() const;
  void clear_command_info();
  static const int kCommandInfoFieldNumber = 5;
  const ::Gamedata::EventCommandInfo& command_info() const;
  ::Gamedata::EventCommandInfo* release_command_info();
  ::Gamedata::EventCommandInfo* mutable_command_info();
  void set_allocated_command_info(::Gamedata::EventCommandInfo* command_info);

  // int32 player_id = 1;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // .Gamedata.EventType event_type = 2;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  ::Gamedata::EventType event_type() const;
  void set_event_type(::Gamedata::EventType value);

  // .Gamedata.EventBroadcastRangeType broadcast_range_type = 3;
  void clear_broadcast_range_type();
  static const int kBroadcastRangeTypeFieldNumber = 3;
  ::Gamedata::EventBroadcastRangeType broadcast_range_type() const;
  void set_broadcast_range_type(::Gamedata::EventBroadcastRangeType value);

  // @@protoc_insertion_point(class_scope:Gamedata.EventInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > broadcast_player_list_;
  mutable int _broadcast_player_list_cached_byte_size_;
  ::Gamedata::EventCommandInfo* command_info_;
  ::google::protobuf::int32 player_id_;
  int event_type_;
  int broadcast_range_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsEventInfoImpl();
};
// -------------------------------------------------------------------

class TimelineOneFrameOneEntityData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.TimelineOneFrameOneEntityData) */ {
 public:
  TimelineOneFrameOneEntityData();
  virtual ~TimelineOneFrameOneEntityData();

  TimelineOneFrameOneEntityData(const TimelineOneFrameOneEntityData& from);

  inline TimelineOneFrameOneEntityData& operator=(const TimelineOneFrameOneEntityData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimelineOneFrameOneEntityData(TimelineOneFrameOneEntityData&& from) noexcept
    : TimelineOneFrameOneEntityData() {
    *this = ::std::move(from);
  }

  inline TimelineOneFrameOneEntityData& operator=(TimelineOneFrameOneEntityData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimelineOneFrameOneEntityData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimelineOneFrameOneEntityData* internal_default_instance() {
    return reinterpret_cast<const TimelineOneFrameOneEntityData*>(
               &_TimelineOneFrameOneEntityData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(TimelineOneFrameOneEntityData* other);
  friend void swap(TimelineOneFrameOneEntityData& a, TimelineOneFrameOneEntityData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimelineOneFrameOneEntityData* New() const PROTOBUF_FINAL { return New(NULL); }

  TimelineOneFrameOneEntityData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimelineOneFrameOneEntityData& from);
  void MergeFrom(const TimelineOneFrameOneEntityData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimelineOneFrameOneEntityData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.FTransform_s child_transform = 2;
  int child_transform_size() const;
  void clear_child_transform();
  static const int kChildTransformFieldNumber = 2;
  const ::Gamedata::FTransform_s& child_transform(int index) const;
  ::Gamedata::FTransform_s* mutable_child_transform(int index);
  ::Gamedata::FTransform_s* add_child_transform();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::FTransform_s >*
      mutable_child_transform();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::FTransform_s >&
      child_transform() const;

  // .Gamedata.FTransform_s collision_transform = 1;
  bool has_collision_transform() const;
  void clear_collision_transform();
  static const int kCollisionTransformFieldNumber = 1;
  const ::Gamedata::FTransform_s& collision_transform() const;
  ::Gamedata::FTransform_s* release_collision_transform();
  ::Gamedata::FTransform_s* mutable_collision_transform();
  void set_allocated_collision_transform(::Gamedata::FTransform_s* collision_transform);

  // @@protoc_insertion_point(class_scope:Gamedata.TimelineOneFrameOneEntityData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::FTransform_s > child_transform_;
  ::Gamedata::FTransform_s* collision_transform_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsTimelineOneFrameOneEntityDataImpl();
};
// -------------------------------------------------------------------

class TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse, 
    ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse();
  TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse& other);
  static const TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse*>(&_TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TimelineOnewFrameAllEntityData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.TimelineOnewFrameAllEntityData) */ {
 public:
  TimelineOnewFrameAllEntityData();
  virtual ~TimelineOnewFrameAllEntityData();

  TimelineOnewFrameAllEntityData(const TimelineOnewFrameAllEntityData& from);

  inline TimelineOnewFrameAllEntityData& operator=(const TimelineOnewFrameAllEntityData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimelineOnewFrameAllEntityData(TimelineOnewFrameAllEntityData&& from) noexcept
    : TimelineOnewFrameAllEntityData() {
    *this = ::std::move(from);
  }

  inline TimelineOnewFrameAllEntityData& operator=(TimelineOnewFrameAllEntityData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimelineOnewFrameAllEntityData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimelineOnewFrameAllEntityData* internal_default_instance() {
    return reinterpret_cast<const TimelineOnewFrameAllEntityData*>(
               &_TimelineOnewFrameAllEntityData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(TimelineOnewFrameAllEntityData* other);
  friend void swap(TimelineOnewFrameAllEntityData& a, TimelineOnewFrameAllEntityData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimelineOnewFrameAllEntityData* New() const PROTOBUF_FINAL { return New(NULL); }

  TimelineOnewFrameAllEntityData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimelineOnewFrameAllEntityData& from);
  void MergeFrom(const TimelineOnewFrameAllEntityData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimelineOnewFrameAllEntityData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .Gamedata.TimelineOneFrameOneEntityData> entity_transform_map = 2;
  int entity_transform_map_size() const;
  void clear_entity_transform_map();
  static const int kEntityTransformMapFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData >&
      entity_transform_map() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData >*
      mutable_entity_transform_map();

  // @@protoc_insertion_point(class_scope:Gamedata.TimelineOnewFrameAllEntityData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TimelineOnewFrameAllEntityData_EntityTransformMapEntry_DoNotUse,
      ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > entity_transform_map_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsTimelineOnewFrameAllEntityDataImpl();
};
// -------------------------------------------------------------------

class TimelineOneSecondAllFrameData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.TimelineOneSecondAllFrameData) */ {
 public:
  TimelineOneSecondAllFrameData();
  virtual ~TimelineOneSecondAllFrameData();

  TimelineOneSecondAllFrameData(const TimelineOneSecondAllFrameData& from);

  inline TimelineOneSecondAllFrameData& operator=(const TimelineOneSecondAllFrameData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimelineOneSecondAllFrameData(TimelineOneSecondAllFrameData&& from) noexcept
    : TimelineOneSecondAllFrameData() {
    *this = ::std::move(from);
  }

  inline TimelineOneSecondAllFrameData& operator=(TimelineOneSecondAllFrameData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimelineOneSecondAllFrameData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimelineOneSecondAllFrameData* internal_default_instance() {
    return reinterpret_cast<const TimelineOneSecondAllFrameData*>(
               &_TimelineOneSecondAllFrameData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(TimelineOneSecondAllFrameData* other);
  friend void swap(TimelineOneSecondAllFrameData& a, TimelineOneSecondAllFrameData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimelineOneSecondAllFrameData* New() const PROTOBUF_FINAL { return New(NULL); }

  TimelineOneSecondAllFrameData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimelineOneSecondAllFrameData& from);
  void MergeFrom(const TimelineOneSecondAllFrameData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimelineOneSecondAllFrameData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Gamedata.TimelineOnewFrameAllEntityData frame_list = 2;
  int frame_list_size() const;
  void clear_frame_list();
  static const int kFrameListFieldNumber = 2;
  const ::Gamedata::TimelineOnewFrameAllEntityData& frame_list(int index) const;
  ::Gamedata::TimelineOnewFrameAllEntityData* mutable_frame_list(int index);
  ::Gamedata::TimelineOnewFrameAllEntityData* add_frame_list();
  ::google::protobuf::RepeatedPtrField< ::Gamedata::TimelineOnewFrameAllEntityData >*
      mutable_frame_list();
  const ::google::protobuf::RepeatedPtrField< ::Gamedata::TimelineOnewFrameAllEntityData >&
      frame_list() const;

  // int32 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.TimelineOneSecondAllFrameData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Gamedata::TimelineOnewFrameAllEntityData > frame_list_;
  ::google::protobuf::int32 time_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsTimelineOneSecondAllFrameDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerRacingInfo

// float steering_input = 1;
inline void PlayerRacingInfo::clear_steering_input() {
  steering_input_ = 0;
}
inline float PlayerRacingInfo::steering_input() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerRacingInfo.steering_input)
  return steering_input_;
}
inline void PlayerRacingInfo::set_steering_input(float value) {
  
  steering_input_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerRacingInfo.steering_input)
}

// float throttle_input = 2;
inline void PlayerRacingInfo::clear_throttle_input() {
  throttle_input_ = 0;
}
inline float PlayerRacingInfo::throttle_input() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerRacingInfo.throttle_input)
  return throttle_input_;
}
inline void PlayerRacingInfo::set_throttle_input(float value) {
  
  throttle_input_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerRacingInfo.throttle_input)
}

// float brake_input = 3;
inline void PlayerRacingInfo::clear_brake_input() {
  brake_input_ = 0;
}
inline float PlayerRacingInfo::brake_input() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerRacingInfo.brake_input)
  return brake_input_;
}
inline void PlayerRacingInfo::set_brake_input(float value) {
  
  brake_input_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerRacingInfo.brake_input)
}

// float handbrake_input = 4;
inline void PlayerRacingInfo::clear_handbrake_input() {
  handbrake_input_ = 0;
}
inline float PlayerRacingInfo::handbrake_input() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerRacingInfo.handbrake_input)
  return handbrake_input_;
}
inline void PlayerRacingInfo::set_handbrake_input(float value) {
  
  handbrake_input_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerRacingInfo.handbrake_input)
}

// int32 current_gear = 5;
inline void PlayerRacingInfo::clear_current_gear() {
  current_gear_ = 0;
}
inline ::google::protobuf::int32 PlayerRacingInfo::current_gear() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerRacingInfo.current_gear)
  return current_gear_;
}
inline void PlayerRacingInfo::set_current_gear(::google::protobuf::int32 value) {
  
  current_gear_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerRacingInfo.current_gear)
}

// -------------------------------------------------------------------

// PlayerButtonKeyInfo

// repeated string command_list = 1;
inline int PlayerButtonKeyInfo::command_list_size() const {
  return command_list_.size();
}
inline void PlayerButtonKeyInfo::clear_command_list() {
  command_list_.Clear();
}
inline const ::std::string& PlayerButtonKeyInfo::command_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerButtonKeyInfo.command_list)
  return command_list_.Get(index);
}
inline ::std::string* PlayerButtonKeyInfo::mutable_command_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerButtonKeyInfo.command_list)
  return command_list_.Mutable(index);
}
inline void PlayerButtonKeyInfo::set_command_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Gamedata.PlayerButtonKeyInfo.command_list)
  command_list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PlayerButtonKeyInfo::set_command_list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Gamedata.PlayerButtonKeyInfo.command_list)
  command_list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PlayerButtonKeyInfo::set_command_list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  command_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerButtonKeyInfo.command_list)
}
inline void PlayerButtonKeyInfo::set_command_list(int index, const char* value, size_t size) {
  command_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerButtonKeyInfo.command_list)
}
inline ::std::string* PlayerButtonKeyInfo::add_command_list() {
  // @@protoc_insertion_point(field_add_mutable:Gamedata.PlayerButtonKeyInfo.command_list)
  return command_list_.Add();
}
inline void PlayerButtonKeyInfo::add_command_list(const ::std::string& value) {
  command_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Gamedata.PlayerButtonKeyInfo.command_list)
}
#if LANG_CXX11
inline void PlayerButtonKeyInfo::add_command_list(::std::string&& value) {
  command_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Gamedata.PlayerButtonKeyInfo.command_list)
}
#endif
inline void PlayerButtonKeyInfo::add_command_list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  command_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Gamedata.PlayerButtonKeyInfo.command_list)
}
inline void PlayerButtonKeyInfo::add_command_list(const char* value, size_t size) {
  command_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Gamedata.PlayerButtonKeyInfo.command_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PlayerButtonKeyInfo::command_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerButtonKeyInfo.command_list)
  return command_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PlayerButtonKeyInfo::mutable_command_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerButtonKeyInfo.command_list)
  return &command_list_;
}

// -------------------------------------------------------------------

// PlayerEntityButtonInfo

// repeated .Gamedata.PlayerButtonKeyInfo key_list = 1;
inline int PlayerEntityButtonInfo::key_list_size() const {
  return key_list_.size();
}
inline void PlayerEntityButtonInfo::clear_key_list() {
  key_list_.Clear();
}
inline const ::Gamedata::PlayerButtonKeyInfo& PlayerEntityButtonInfo::key_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerEntityButtonInfo.key_list)
  return key_list_.Get(index);
}
inline ::Gamedata::PlayerButtonKeyInfo* PlayerEntityButtonInfo::mutable_key_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerEntityButtonInfo.key_list)
  return key_list_.Mutable(index);
}
inline ::Gamedata::PlayerButtonKeyInfo* PlayerEntityButtonInfo::add_key_list() {
  // @@protoc_insertion_point(field_add:Gamedata.PlayerEntityButtonInfo.key_list)
  return key_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerButtonKeyInfo >*
PlayerEntityButtonInfo::mutable_key_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerEntityButtonInfo.key_list)
  return &key_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerButtonKeyInfo >&
PlayerEntityButtonInfo::key_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerEntityButtonInfo.key_list)
  return key_list_;
}

// -------------------------------------------------------------------

// PlayerLocaionInfo

// .Gamedata.FTransform_s transform_s = 1;
inline bool PlayerLocaionInfo::has_transform_s() const {
  return this != internal_default_instance() && transform_s_ != NULL;
}
inline const ::Gamedata::FTransform_s& PlayerLocaionInfo::transform_s() const {
  const ::Gamedata::FTransform_s* p = transform_s_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.transform_s)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform_s*>(
      &::Gamedata::_FTransform_s_default_instance_);
}
inline ::Gamedata::FTransform_s* PlayerLocaionInfo::release_transform_s() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLocaionInfo.transform_s)
  
  ::Gamedata::FTransform_s* temp = transform_s_;
  transform_s_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform_s* PlayerLocaionInfo::mutable_transform_s() {
  
  if (transform_s_ == NULL) {
    transform_s_ = new ::Gamedata::FTransform_s;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLocaionInfo.transform_s)
  return transform_s_;
}
inline void PlayerLocaionInfo::set_allocated_transform_s(::Gamedata::FTransform_s* transform_s) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transform_s_);
  }
  if (transform_s) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform_s = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform_s, submessage_arena);
    }
    
  } else {
    
  }
  transform_s_ = transform_s;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLocaionInfo.transform_s)
}

// .Gamedata.FVector velocity = 2;
inline bool PlayerLocaionInfo::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline const ::Gamedata::FVector& PlayerLocaionInfo::velocity() const {
  const ::Gamedata::FVector* p = velocity_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* PlayerLocaionInfo::release_velocity() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLocaionInfo.velocity)
  
  ::Gamedata::FVector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* PlayerLocaionInfo::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLocaionInfo.velocity)
  return velocity_;
}
inline void PlayerLocaionInfo::set_allocated_velocity(::Gamedata::FVector* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLocaionInfo.velocity)
}

// .Gamedata.CharacterMovementModeType characterMovementModeType = 3;
inline void PlayerLocaionInfo::clear_charactermovementmodetype() {
  charactermovementmodetype_ = 0;
}
inline ::Gamedata::CharacterMovementModeType PlayerLocaionInfo::charactermovementmodetype() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.characterMovementModeType)
  return static_cast< ::Gamedata::CharacterMovementModeType >(charactermovementmodetype_);
}
inline void PlayerLocaionInfo::set_charactermovementmodetype(::Gamedata::CharacterMovementModeType value) {
  
  charactermovementmodetype_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLocaionInfo.characterMovementModeType)
}

// .Gamedata.CharacterActionType characterActionType = 4;
inline void PlayerLocaionInfo::clear_characteractiontype() {
  characteractiontype_ = 0;
}
inline ::Gamedata::CharacterActionType PlayerLocaionInfo::characteractiontype() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.characterActionType)
  return static_cast< ::Gamedata::CharacterActionType >(characteractiontype_);
}
inline void PlayerLocaionInfo::set_characteractiontype(::Gamedata::CharacterActionType value) {
  
  characteractiontype_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLocaionInfo.characterActionType)
}

// bool isRacing = 5;
inline void PlayerLocaionInfo::clear_isracing() {
  isracing_ = false;
}
inline bool PlayerLocaionInfo::isracing() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.isRacing)
  return isracing_;
}
inline void PlayerLocaionInfo::set_isracing(bool value) {
  
  isracing_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLocaionInfo.isRacing)
}

// .Gamedata.PlayerRacingInfo player_racing_info = 6;
inline bool PlayerLocaionInfo::has_player_racing_info() const {
  return this != internal_default_instance() && player_racing_info_ != NULL;
}
inline void PlayerLocaionInfo::clear_player_racing_info() {
  if (GetArenaNoVirtual() == NULL && player_racing_info_ != NULL) {
    delete player_racing_info_;
  }
  player_racing_info_ = NULL;
}
inline const ::Gamedata::PlayerRacingInfo& PlayerLocaionInfo::player_racing_info() const {
  const ::Gamedata::PlayerRacingInfo* p = player_racing_info_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLocaionInfo.player_racing_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerRacingInfo*>(
      &::Gamedata::_PlayerRacingInfo_default_instance_);
}
inline ::Gamedata::PlayerRacingInfo* PlayerLocaionInfo::release_player_racing_info() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLocaionInfo.player_racing_info)
  
  ::Gamedata::PlayerRacingInfo* temp = player_racing_info_;
  player_racing_info_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerRacingInfo* PlayerLocaionInfo::mutable_player_racing_info() {
  
  if (player_racing_info_ == NULL) {
    player_racing_info_ = new ::Gamedata::PlayerRacingInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLocaionInfo.player_racing_info)
  return player_racing_info_;
}
inline void PlayerLocaionInfo::set_allocated_player_racing_info(::Gamedata::PlayerRacingInfo* player_racing_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_racing_info_;
  }
  if (player_racing_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_racing_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_racing_info, submessage_arena);
    }
    
  } else {
    
  }
  player_racing_info_ = player_racing_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLocaionInfo.player_racing_info)
}

// -------------------------------------------------------------------

// PlayerStorageEntity

// .Gamedata.EntityInfo entity_info = 1;
inline bool PlayerStorageEntity::has_entity_info() const {
  return this != internal_default_instance() && entity_info_ != NULL;
}
inline void PlayerStorageEntity::clear_entity_info() {
  if (GetArenaNoVirtual() == NULL && entity_info_ != NULL) {
    delete entity_info_;
  }
  entity_info_ = NULL;
}
inline const ::Gamedata::EntityInfo& PlayerStorageEntity::entity_info() const {
  const ::Gamedata::EntityInfo* p = entity_info_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerStorageEntity.entity_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityInfo*>(
      &::Gamedata::_EntityInfo_default_instance_);
}
inline ::Gamedata::EntityInfo* PlayerStorageEntity::release_entity_info() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerStorageEntity.entity_info)
  
  ::Gamedata::EntityInfo* temp = entity_info_;
  entity_info_ = NULL;
  return temp;
}
inline ::Gamedata::EntityInfo* PlayerStorageEntity::mutable_entity_info() {
  
  if (entity_info_ == NULL) {
    entity_info_ = new ::Gamedata::EntityInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerStorageEntity.entity_info)
  return entity_info_;
}
inline void PlayerStorageEntity::set_allocated_entity_info(::Gamedata::EntityInfo* entity_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entity_info_;
  }
  if (entity_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entity_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_info, submessage_arena);
    }
    
  } else {
    
  }
  entity_info_ = entity_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerStorageEntity.entity_info)
}

// string entity_name = 2;
inline void PlayerStorageEntity::clear_entity_name() {
  entity_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerStorageEntity::entity_name() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerStorageEntity.entity_name)
  return entity_name_.GetNoArena();
}
inline void PlayerStorageEntity::set_entity_name(const ::std::string& value) {
  
  entity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerStorageEntity.entity_name)
}
#if LANG_CXX11
inline void PlayerStorageEntity::set_entity_name(::std::string&& value) {
  
  entity_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.PlayerStorageEntity.entity_name)
}
#endif
inline void PlayerStorageEntity::set_entity_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  entity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerStorageEntity.entity_name)
}
inline void PlayerStorageEntity::set_entity_name(const char* value, size_t size) {
  
  entity_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerStorageEntity.entity_name)
}
inline ::std::string* PlayerStorageEntity::mutable_entity_name() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerStorageEntity.entity_name)
  return entity_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerStorageEntity::release_entity_name() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerStorageEntity.entity_name)
  
  return entity_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerStorageEntity::set_allocated_entity_name(::std::string* entity_name) {
  if (entity_name != NULL) {
    
  } else {
    
  }
  entity_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entity_name);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerStorageEntity.entity_name)
}

// int32 unique_mark = 3;
inline void PlayerStorageEntity::clear_unique_mark() {
  unique_mark_ = 0;
}
inline ::google::protobuf::int32 PlayerStorageEntity::unique_mark() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerStorageEntity.unique_mark)
  return unique_mark_;
}
inline void PlayerStorageEntity::set_unique_mark(::google::protobuf::int32 value) {
  
  unique_mark_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerStorageEntity.unique_mark)
}

// -------------------------------------------------------------------

// PlayerEntityStorageInfo

// repeated .Gamedata.PlayerStorageEntity storage_entity_list = 1;
inline int PlayerEntityStorageInfo::storage_entity_list_size() const {
  return storage_entity_list_.size();
}
inline void PlayerEntityStorageInfo::clear_storage_entity_list() {
  storage_entity_list_.Clear();
}
inline const ::Gamedata::PlayerStorageEntity& PlayerEntityStorageInfo::storage_entity_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerEntityStorageInfo.storage_entity_list)
  return storage_entity_list_.Get(index);
}
inline ::Gamedata::PlayerStorageEntity* PlayerEntityStorageInfo::mutable_storage_entity_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerEntityStorageInfo.storage_entity_list)
  return storage_entity_list_.Mutable(index);
}
inline ::Gamedata::PlayerStorageEntity* PlayerEntityStorageInfo::add_storage_entity_list() {
  // @@protoc_insertion_point(field_add:Gamedata.PlayerEntityStorageInfo.storage_entity_list)
  return storage_entity_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerStorageEntity >*
PlayerEntityStorageInfo::mutable_storage_entity_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerEntityStorageInfo.storage_entity_list)
  return &storage_entity_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerStorageEntity >&
PlayerEntityStorageInfo::storage_entity_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerEntityStorageInfo.storage_entity_list)
  return storage_entity_list_;
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 playerId = 1;
inline void PlayerInfo::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.playerId)
  return playerid_;
}
inline void PlayerInfo::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerInfo.playerId)
}

// .Gamedata.GameMainOperationMode character_pawn_type = 2;
inline void PlayerInfo::clear_character_pawn_type() {
  character_pawn_type_ = 0;
}
inline ::Gamedata::GameMainOperationMode PlayerInfo::character_pawn_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.character_pawn_type)
  return static_cast< ::Gamedata::GameMainOperationMode >(character_pawn_type_);
}
inline void PlayerInfo::set_character_pawn_type(::Gamedata::GameMainOperationMode value) {
  
  character_pawn_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerInfo.character_pawn_type)
}

// .Gamedata.PlayerLocaionInfo playerLocaionInfo = 4;
inline bool PlayerInfo::has_playerlocaioninfo() const {
  return this != internal_default_instance() && playerlocaioninfo_ != NULL;
}
inline void PlayerInfo::clear_playerlocaioninfo() {
  if (GetArenaNoVirtual() == NULL && playerlocaioninfo_ != NULL) {
    delete playerlocaioninfo_;
  }
  playerlocaioninfo_ = NULL;
}
inline const ::Gamedata::PlayerLocaionInfo& PlayerInfo::playerlocaioninfo() const {
  const ::Gamedata::PlayerLocaionInfo* p = playerlocaioninfo_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.playerLocaionInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerLocaionInfo*>(
      &::Gamedata::_PlayerLocaionInfo_default_instance_);
}
inline ::Gamedata::PlayerLocaionInfo* PlayerInfo::release_playerlocaioninfo() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerInfo.playerLocaionInfo)
  
  ::Gamedata::PlayerLocaionInfo* temp = playerlocaioninfo_;
  playerlocaioninfo_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerLocaionInfo* PlayerInfo::mutable_playerlocaioninfo() {
  
  if (playerlocaioninfo_ == NULL) {
    playerlocaioninfo_ = new ::Gamedata::PlayerLocaionInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerInfo.playerLocaionInfo)
  return playerlocaioninfo_;
}
inline void PlayerInfo::set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete playerlocaioninfo_;
  }
  if (playerlocaioninfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      playerlocaioninfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerlocaioninfo, submessage_arena);
    }
    
  } else {
    
  }
  playerlocaioninfo_ = playerlocaioninfo;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerInfo.playerLocaionInfo)
}

// .Gamedata.PlayerEntityButtonInfo entity_button_info = 5;
inline bool PlayerInfo::has_entity_button_info() const {
  return this != internal_default_instance() && entity_button_info_ != NULL;
}
inline void PlayerInfo::clear_entity_button_info() {
  if (GetArenaNoVirtual() == NULL && entity_button_info_ != NULL) {
    delete entity_button_info_;
  }
  entity_button_info_ = NULL;
}
inline const ::Gamedata::PlayerEntityButtonInfo& PlayerInfo::entity_button_info() const {
  const ::Gamedata::PlayerEntityButtonInfo* p = entity_button_info_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.entity_button_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerEntityButtonInfo*>(
      &::Gamedata::_PlayerEntityButtonInfo_default_instance_);
}
inline ::Gamedata::PlayerEntityButtonInfo* PlayerInfo::release_entity_button_info() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerInfo.entity_button_info)
  
  ::Gamedata::PlayerEntityButtonInfo* temp = entity_button_info_;
  entity_button_info_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerEntityButtonInfo* PlayerInfo::mutable_entity_button_info() {
  
  if (entity_button_info_ == NULL) {
    entity_button_info_ = new ::Gamedata::PlayerEntityButtonInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerInfo.entity_button_info)
  return entity_button_info_;
}
inline void PlayerInfo::set_allocated_entity_button_info(::Gamedata::PlayerEntityButtonInfo* entity_button_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entity_button_info_;
  }
  if (entity_button_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entity_button_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_button_info, submessage_arena);
    }
    
  } else {
    
  }
  entity_button_info_ = entity_button_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerInfo.entity_button_info)
}

// .Gamedata.PlayerEntityStorageInfo entity_storage = 6;
inline bool PlayerInfo::has_entity_storage() const {
  return this != internal_default_instance() && entity_storage_ != NULL;
}
inline void PlayerInfo::clear_entity_storage() {
  if (GetArenaNoVirtual() == NULL && entity_storage_ != NULL) {
    delete entity_storage_;
  }
  entity_storage_ = NULL;
}
inline const ::Gamedata::PlayerEntityStorageInfo& PlayerInfo::entity_storage() const {
  const ::Gamedata::PlayerEntityStorageInfo* p = entity_storage_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.entity_storage)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerEntityStorageInfo*>(
      &::Gamedata::_PlayerEntityStorageInfo_default_instance_);
}
inline ::Gamedata::PlayerEntityStorageInfo* PlayerInfo::release_entity_storage() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerInfo.entity_storage)
  
  ::Gamedata::PlayerEntityStorageInfo* temp = entity_storage_;
  entity_storage_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerEntityStorageInfo* PlayerInfo::mutable_entity_storage() {
  
  if (entity_storage_ == NULL) {
    entity_storage_ = new ::Gamedata::PlayerEntityStorageInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerInfo.entity_storage)
  return entity_storage_;
}
inline void PlayerInfo::set_allocated_entity_storage(::Gamedata::PlayerEntityStorageInfo* entity_storage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entity_storage_;
  }
  if (entity_storage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entity_storage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_storage, submessage_arena);
    }
    
  } else {
    
  }
  entity_storage_ = entity_storage;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerInfo.entity_storage)
}

// int32 sky_level_index = 7;
inline void PlayerInfo::clear_sky_level_index() {
  sky_level_index_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::sky_level_index() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.sky_level_index)
  return sky_level_index_;
}
inline void PlayerInfo::set_sky_level_index(::google::protobuf::int32 value) {
  
  sky_level_index_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerInfo.sky_level_index)
}

// int32 character_index = 8;
inline void PlayerInfo::clear_character_index() {
  character_index_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::character_index() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerInfo.character_index)
  return character_index_;
}
inline void PlayerInfo::set_character_index(::google::protobuf::int32 value) {
  
  character_index_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerInfo.character_index)
}

// -------------------------------------------------------------------

// PlayerEnterView

// repeated .Gamedata.PlayerInfo playerInfoList = 1;
inline int PlayerEnterView::playerinfolist_size() const {
  return playerinfolist_.size();
}
inline void PlayerEnterView::clear_playerinfolist() {
  playerinfolist_.Clear();
}
inline const ::Gamedata::PlayerInfo& PlayerEnterView::playerinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerEnterView.playerInfoList)
  return playerinfolist_.Get(index);
}
inline ::Gamedata::PlayerInfo* PlayerEnterView::mutable_playerinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerEnterView.playerInfoList)
  return playerinfolist_.Mutable(index);
}
inline ::Gamedata::PlayerInfo* PlayerEnterView::add_playerinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.PlayerEnterView.playerInfoList)
  return playerinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >*
PlayerEnterView::mutable_playerinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerEnterView.playerInfoList)
  return &playerinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >&
PlayerEnterView::playerinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerEnterView.playerInfoList)
  return playerinfolist_;
}

// -------------------------------------------------------------------

// PlayerLeaveView

// repeated int32 playerIdList = 1;
inline int PlayerLeaveView::playeridlist_size() const {
  return playeridlist_.size();
}
inline void PlayerLeaveView::clear_playeridlist() {
  playeridlist_.Clear();
}
inline ::google::protobuf::int32 PlayerLeaveView::playeridlist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLeaveView.playerIdList)
  return playeridlist_.Get(index);
}
inline void PlayerLeaveView::set_playeridlist(int index, ::google::protobuf::int32 value) {
  playeridlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLeaveView.playerIdList)
}
inline void PlayerLeaveView::add_playeridlist(::google::protobuf::int32 value) {
  playeridlist_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.PlayerLeaveView.playerIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlayerLeaveView::playeridlist() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerLeaveView.playerIdList)
  return playeridlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlayerLeaveView::mutable_playeridlist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerLeaveView.playerIdList)
  return &playeridlist_;
}

// -------------------------------------------------------------------

// PlayerUpdateView

// repeated .Gamedata.PlayerInfo playerInfoList = 1;
inline int PlayerUpdateView::playerinfolist_size() const {
  return playerinfolist_.size();
}
inline void PlayerUpdateView::clear_playerinfolist() {
  playerinfolist_.Clear();
}
inline const ::Gamedata::PlayerInfo& PlayerUpdateView::playerinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerUpdateView.playerInfoList)
  return playerinfolist_.Get(index);
}
inline ::Gamedata::PlayerInfo* PlayerUpdateView::mutable_playerinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerUpdateView.playerInfoList)
  return playerinfolist_.Mutable(index);
}
inline ::Gamedata::PlayerInfo* PlayerUpdateView::add_playerinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.PlayerUpdateView.playerInfoList)
  return playerinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >*
PlayerUpdateView::mutable_playerinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.PlayerUpdateView.playerInfoList)
  return &playerinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::PlayerInfo >&
PlayerUpdateView::playerinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.PlayerUpdateView.playerInfoList)
  return playerinfolist_;
}

// -------------------------------------------------------------------

// PlayerUpdateLocation

// int32 playerId = 1;
inline void PlayerUpdateLocation::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 PlayerUpdateLocation::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerUpdateLocation.playerId)
  return playerid_;
}
inline void PlayerUpdateLocation::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerUpdateLocation.playerId)
}

// .Gamedata.PlayerLocaionInfo playerLocaionInfo = 2;
inline bool PlayerUpdateLocation::has_playerlocaioninfo() const {
  return this != internal_default_instance() && playerlocaioninfo_ != NULL;
}
inline void PlayerUpdateLocation::clear_playerlocaioninfo() {
  if (GetArenaNoVirtual() == NULL && playerlocaioninfo_ != NULL) {
    delete playerlocaioninfo_;
  }
  playerlocaioninfo_ = NULL;
}
inline const ::Gamedata::PlayerLocaionInfo& PlayerUpdateLocation::playerlocaioninfo() const {
  const ::Gamedata::PlayerLocaionInfo* p = playerlocaioninfo_;
  // @@protoc_insertion_point(field_get:Gamedata.PlayerUpdateLocation.playerLocaionInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerLocaionInfo*>(
      &::Gamedata::_PlayerLocaionInfo_default_instance_);
}
inline ::Gamedata::PlayerLocaionInfo* PlayerUpdateLocation::release_playerlocaioninfo() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerUpdateLocation.playerLocaionInfo)
  
  ::Gamedata::PlayerLocaionInfo* temp = playerlocaioninfo_;
  playerlocaioninfo_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerLocaionInfo* PlayerUpdateLocation::mutable_playerlocaioninfo() {
  
  if (playerlocaioninfo_ == NULL) {
    playerlocaioninfo_ = new ::Gamedata::PlayerLocaionInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerUpdateLocation.playerLocaionInfo)
  return playerlocaioninfo_;
}
inline void PlayerUpdateLocation::set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete playerlocaioninfo_;
  }
  if (playerlocaioninfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      playerlocaioninfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerlocaioninfo, submessage_arena);
    }
    
  } else {
    
  }
  playerlocaioninfo_ = playerlocaioninfo;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerUpdateLocation.playerLocaionInfo)
}

// -------------------------------------------------------------------

// UpdatePlayerDataRequest

// .Gamedata.PlayerInfo playerInfo = 1;
inline bool UpdatePlayerDataRequest::has_playerinfo() const {
  return this != internal_default_instance() && playerinfo_ != NULL;
}
inline void UpdatePlayerDataRequest::clear_playerinfo() {
  if (GetArenaNoVirtual() == NULL && playerinfo_ != NULL) {
    delete playerinfo_;
  }
  playerinfo_ = NULL;
}
inline const ::Gamedata::PlayerInfo& UpdatePlayerDataRequest::playerinfo() const {
  const ::Gamedata::PlayerInfo* p = playerinfo_;
  // @@protoc_insertion_point(field_get:Gamedata.UpdatePlayerDataRequest.playerInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerInfo*>(
      &::Gamedata::_PlayerInfo_default_instance_);
}
inline ::Gamedata::PlayerInfo* UpdatePlayerDataRequest::release_playerinfo() {
  // @@protoc_insertion_point(field_release:Gamedata.UpdatePlayerDataRequest.playerInfo)
  
  ::Gamedata::PlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerInfo* UpdatePlayerDataRequest::mutable_playerinfo() {
  
  if (playerinfo_ == NULL) {
    playerinfo_ = new ::Gamedata::PlayerInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.UpdatePlayerDataRequest.playerInfo)
  return playerinfo_;
}
inline void UpdatePlayerDataRequest::set_allocated_playerinfo(::Gamedata::PlayerInfo* playerinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete playerinfo_;
  }
  if (playerinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      playerinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.UpdatePlayerDataRequest.playerInfo)
}

// int32 playerId = 2;
inline void UpdatePlayerDataRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 UpdatePlayerDataRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.UpdatePlayerDataRequest.playerId)
  return playerid_;
}
inline void UpdatePlayerDataRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.UpdatePlayerDataRequest.playerId)
}

// -------------------------------------------------------------------

// UpdateLocationRequest

// int32 playerId = 1;
inline void UpdateLocationRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 UpdateLocationRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.UpdateLocationRequest.playerId)
  return playerid_;
}
inline void UpdateLocationRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.UpdateLocationRequest.playerId)
}

// .Gamedata.PlayerLocaionInfo playerLocaionInfo = 2;
inline bool UpdateLocationRequest::has_playerlocaioninfo() const {
  return this != internal_default_instance() && playerlocaioninfo_ != NULL;
}
inline void UpdateLocationRequest::clear_playerlocaioninfo() {
  if (GetArenaNoVirtual() == NULL && playerlocaioninfo_ != NULL) {
    delete playerlocaioninfo_;
  }
  playerlocaioninfo_ = NULL;
}
inline const ::Gamedata::PlayerLocaionInfo& UpdateLocationRequest::playerlocaioninfo() const {
  const ::Gamedata::PlayerLocaionInfo* p = playerlocaioninfo_;
  // @@protoc_insertion_point(field_get:Gamedata.UpdateLocationRequest.playerLocaionInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::PlayerLocaionInfo*>(
      &::Gamedata::_PlayerLocaionInfo_default_instance_);
}
inline ::Gamedata::PlayerLocaionInfo* UpdateLocationRequest::release_playerlocaioninfo() {
  // @@protoc_insertion_point(field_release:Gamedata.UpdateLocationRequest.playerLocaionInfo)
  
  ::Gamedata::PlayerLocaionInfo* temp = playerlocaioninfo_;
  playerlocaioninfo_ = NULL;
  return temp;
}
inline ::Gamedata::PlayerLocaionInfo* UpdateLocationRequest::mutable_playerlocaioninfo() {
  
  if (playerlocaioninfo_ == NULL) {
    playerlocaioninfo_ = new ::Gamedata::PlayerLocaionInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.UpdateLocationRequest.playerLocaionInfo)
  return playerlocaioninfo_;
}
inline void UpdateLocationRequest::set_allocated_playerlocaioninfo(::Gamedata::PlayerLocaionInfo* playerlocaioninfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete playerlocaioninfo_;
  }
  if (playerlocaioninfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      playerlocaioninfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerlocaioninfo, submessage_arena);
    }
    
  } else {
    
  }
  playerlocaioninfo_ = playerlocaioninfo;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.UpdateLocationRequest.playerLocaionInfo)
}

// -------------------------------------------------------------------

// ChangeJiugonggeRequest

// int32 playerId = 1;
inline void ChangeJiugonggeRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 ChangeJiugonggeRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.ChangeJiugonggeRequest.playerId)
  return playerid_;
}
inline void ChangeJiugonggeRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.ChangeJiugonggeRequest.playerId)
}

// .Gamedata.FVector location = 2;
inline bool ChangeJiugonggeRequest::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::Gamedata::FVector& ChangeJiugonggeRequest::location() const {
  const ::Gamedata::FVector* p = location_;
  // @@protoc_insertion_point(field_get:Gamedata.ChangeJiugonggeRequest.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* ChangeJiugonggeRequest::release_location() {
  // @@protoc_insertion_point(field_release:Gamedata.ChangeJiugonggeRequest.location)
  
  ::Gamedata::FVector* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* ChangeJiugonggeRequest::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.ChangeJiugonggeRequest.location)
  return location_;
}
inline void ChangeJiugonggeRequest::set_allocated_location(::Gamedata::FVector* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.ChangeJiugonggeRequest.location)
}

// -------------------------------------------------------------------

// EntitySplineAlone

// .Gamedata.FTransform_s transform_s = 1;
inline bool EntitySplineAlone::has_transform_s() const {
  return this != internal_default_instance() && transform_s_ != NULL;
}
inline const ::Gamedata::FTransform_s& EntitySplineAlone::transform_s() const {
  const ::Gamedata::FTransform_s* p = transform_s_;
  // @@protoc_insertion_point(field_get:Gamedata.EntitySplineAlone.transform_s)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform_s*>(
      &::Gamedata::_FTransform_s_default_instance_);
}
inline ::Gamedata::FTransform_s* EntitySplineAlone::release_transform_s() {
  // @@protoc_insertion_point(field_release:Gamedata.EntitySplineAlone.transform_s)
  
  ::Gamedata::FTransform_s* temp = transform_s_;
  transform_s_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform_s* EntitySplineAlone::mutable_transform_s() {
  
  if (transform_s_ == NULL) {
    transform_s_ = new ::Gamedata::FTransform_s;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntitySplineAlone.transform_s)
  return transform_s_;
}
inline void EntitySplineAlone::set_allocated_transform_s(::Gamedata::FTransform_s* transform_s) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transform_s_);
  }
  if (transform_s) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform_s = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform_s, submessage_arena);
    }
    
  } else {
    
  }
  transform_s_ = transform_s;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntitySplineAlone.transform_s)
}

// -------------------------------------------------------------------

// EntityLaser

// -------------------------------------------------------------------

// EntityMusic

// -------------------------------------------------------------------

// EntityScenesTimelineGroup

// int32 groupId = 1;
inline void EntityScenesTimelineGroup::clear_groupid() {
  groupid_ = 0;
}
inline ::google::protobuf::int32 EntityScenesTimelineGroup::groupid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineGroup.groupId)
  return groupid_;
}
inline void EntityScenesTimelineGroup::set_groupid(::google::protobuf::int32 value) {
  
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineGroup.groupId)
}

// string groupName = 2;
inline void EntityScenesTimelineGroup::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityScenesTimelineGroup::groupname() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineGroup.groupName)
  return groupname_.GetNoArena();
}
inline void EntityScenesTimelineGroup::set_groupname(const ::std::string& value) {
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineGroup.groupName)
}
#if LANG_CXX11
inline void EntityScenesTimelineGroup::set_groupname(::std::string&& value) {
  
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityScenesTimelineGroup.groupName)
}
#endif
inline void EntityScenesTimelineGroup::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityScenesTimelineGroup.groupName)
}
inline void EntityScenesTimelineGroup::set_groupname(const char* value, size_t size) {
  
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityScenesTimelineGroup.groupName)
}
inline ::std::string* EntityScenesTimelineGroup::mutable_groupname() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityScenesTimelineGroup.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityScenesTimelineGroup::release_groupname() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityScenesTimelineGroup.groupName)
  
  return groupname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityScenesTimelineGroup::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    
  } else {
    
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityScenesTimelineGroup.groupName)
}

// repeated int32 entityIdList = 3;
inline int EntityScenesTimelineGroup::entityidlist_size() const {
  return entityidlist_.size();
}
inline void EntityScenesTimelineGroup::clear_entityidlist() {
  entityidlist_.Clear();
}
inline ::google::protobuf::int32 EntityScenesTimelineGroup::entityidlist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineGroup.entityIdList)
  return entityidlist_.Get(index);
}
inline void EntityScenesTimelineGroup::set_entityidlist(int index, ::google::protobuf::int32 value) {
  entityidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineGroup.entityIdList)
}
inline void EntityScenesTimelineGroup::add_entityidlist(::google::protobuf::int32 value) {
  entityidlist_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.EntityScenesTimelineGroup.entityIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EntityScenesTimelineGroup::entityidlist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityScenesTimelineGroup.entityIdList)
  return entityidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EntityScenesTimelineGroup::mutable_entityidlist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityScenesTimelineGroup.entityIdList)
  return &entityidlist_;
}

// -------------------------------------------------------------------

// EntityScenesTimelineNode

// int32 entityId = 1;
inline void EntityScenesTimelineNode::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 EntityScenesTimelineNode::entityid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineNode.entityId)
  return entityid_;
}
inline void EntityScenesTimelineNode::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineNode.entityId)
}

// int32 groupId = 2;
inline void EntityScenesTimelineNode::clear_groupid() {
  groupid_ = 0;
}
inline ::google::protobuf::int32 EntityScenesTimelineNode::groupid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineNode.groupId)
  return groupid_;
}
inline void EntityScenesTimelineNode::set_groupid(::google::protobuf::int32 value) {
  
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineNode.groupId)
}

// int32 type = 3;
inline void EntityScenesTimelineNode::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 EntityScenesTimelineNode::type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineNode.type)
  return type_;
}
inline void EntityScenesTimelineNode::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineNode.type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EntityScenesTimelineAlone

// string timelineName = 2;
inline void EntityScenesTimelineAlone::clear_timelinename() {
  timelinename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityScenesTimelineAlone::timelinename() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineAlone.timelineName)
  return timelinename_.GetNoArena();
}
inline void EntityScenesTimelineAlone::set_timelinename(const ::std::string& value) {
  
  timelinename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineAlone.timelineName)
}
#if LANG_CXX11
inline void EntityScenesTimelineAlone::set_timelinename(::std::string&& value) {
  
  timelinename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityScenesTimelineAlone.timelineName)
}
#endif
inline void EntityScenesTimelineAlone::set_timelinename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  timelinename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityScenesTimelineAlone.timelineName)
}
inline void EntityScenesTimelineAlone::set_timelinename(const char* value, size_t size) {
  
  timelinename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityScenesTimelineAlone.timelineName)
}
inline ::std::string* EntityScenesTimelineAlone::mutable_timelinename() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityScenesTimelineAlone.timelineName)
  return timelinename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityScenesTimelineAlone::release_timelinename() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityScenesTimelineAlone.timelineName)
  
  return timelinename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityScenesTimelineAlone::set_allocated_timelinename(::std::string* timelinename) {
  if (timelinename != NULL) {
    
  } else {
    
  }
  timelinename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timelinename);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityScenesTimelineAlone.timelineName)
}

// map<int32, .Gamedata.EntityScenesTimelineNode> entityMap = 3;
inline int EntityScenesTimelineAlone::entitymap_size() const {
  return entitymap_.size();
}
inline void EntityScenesTimelineAlone::clear_entitymap() {
  entitymap_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode >&
EntityScenesTimelineAlone::entitymap() const {
  // @@protoc_insertion_point(field_map:Gamedata.EntityScenesTimelineAlone.entityMap)
  return entitymap_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineNode >*
EntityScenesTimelineAlone::mutable_entitymap() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.EntityScenesTimelineAlone.entityMap)
  return entitymap_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EntityScenesTimelineTotal

// bool isPlay = 1;
inline void EntityScenesTimelineTotal::clear_isplay() {
  isplay_ = false;
}
inline bool EntityScenesTimelineTotal::isplay() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineTotal.isPlay)
  return isplay_;
}
inline void EntityScenesTimelineTotal::set_isplay(bool value) {
  
  isplay_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineTotal.isPlay)
}

// float playTime = 2;
inline void EntityScenesTimelineTotal::clear_playtime() {
  playtime_ = 0;
}
inline float EntityScenesTimelineTotal::playtime() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineTotal.playTime)
  return playtime_;
}
inline void EntityScenesTimelineTotal::set_playtime(float value) {
  
  playtime_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineTotal.playTime)
}

// map<int32, .Gamedata.EntityScenesTimelineGroup> groupMap = 3;
inline int EntityScenesTimelineTotal::groupmap_size() const {
  return groupmap_.size();
}
inline void EntityScenesTimelineTotal::clear_groupmap() {
  groupmap_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup >&
EntityScenesTimelineTotal::groupmap() const {
  // @@protoc_insertion_point(field_map:Gamedata.EntityScenesTimelineTotal.groupMap)
  return groupmap_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityScenesTimelineGroup >*
EntityScenesTimelineTotal::mutable_groupmap() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.EntityScenesTimelineTotal.groupMap)
  return groupmap_.MutableMap();
}

// repeated .Gamedata.EntityScenesTimelineAlone alone = 4;
inline int EntityScenesTimelineTotal::alone_size() const {
  return alone_.size();
}
inline void EntityScenesTimelineTotal::clear_alone() {
  alone_.Clear();
}
inline const ::Gamedata::EntityScenesTimelineAlone& EntityScenesTimelineTotal::alone(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineTotal.alone)
  return alone_.Get(index);
}
inline ::Gamedata::EntityScenesTimelineAlone* EntityScenesTimelineTotal::mutable_alone(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityScenesTimelineTotal.alone)
  return alone_.Mutable(index);
}
inline ::Gamedata::EntityScenesTimelineAlone* EntityScenesTimelineTotal::add_alone() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityScenesTimelineTotal.alone)
  return alone_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityScenesTimelineAlone >*
EntityScenesTimelineTotal::mutable_alone() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityScenesTimelineTotal.alone)
  return &alone_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityScenesTimelineAlone >&
EntityScenesTimelineTotal::alone() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityScenesTimelineTotal.alone)
  return alone_;
}

// float totalTime = 5;
inline void EntityScenesTimelineTotal::clear_totaltime() {
  totaltime_ = 0;
}
inline float EntityScenesTimelineTotal::totaltime() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityScenesTimelineTotal.totalTime)
  return totaltime_;
}
inline void EntityScenesTimelineTotal::set_totaltime(float value) {
  
  totaltime_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityScenesTimelineTotal.totalTime)
}

// -------------------------------------------------------------------

// EntityMoveTimelinePoint

// int32 uniqueMark = 1;
inline void EntityMoveTimelinePoint::clear_uniquemark() {
  uniquemark_ = 0;
}
inline ::google::protobuf::int32 EntityMoveTimelinePoint::uniquemark() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimelinePoint.uniqueMark)
  return uniquemark_;
}
inline void EntityMoveTimelinePoint::set_uniquemark(::google::protobuf::int32 value) {
  
  uniquemark_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimelinePoint.uniqueMark)
}

// .Gamedata.FVector location = 2;
inline bool EntityMoveTimelinePoint::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::Gamedata::FVector& EntityMoveTimelinePoint::location() const {
  const ::Gamedata::FVector* p = location_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimelinePoint.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* EntityMoveTimelinePoint::release_location() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMoveTimelinePoint.location)
  
  ::Gamedata::FVector* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* EntityMoveTimelinePoint::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMoveTimelinePoint.location)
  return location_;
}
inline void EntityMoveTimelinePoint::set_allocated_location(::Gamedata::FVector* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMoveTimelinePoint.location)
}

// .Gamedata.FRotator rotator = 3;
inline bool EntityMoveTimelinePoint::has_rotator() const {
  return this != internal_default_instance() && rotator_ != NULL;
}
inline const ::Gamedata::FRotator& EntityMoveTimelinePoint::rotator() const {
  const ::Gamedata::FRotator* p = rotator_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimelinePoint.rotator)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FRotator*>(
      &::Gamedata::_FRotator_default_instance_);
}
inline ::Gamedata::FRotator* EntityMoveTimelinePoint::release_rotator() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMoveTimelinePoint.rotator)
  
  ::Gamedata::FRotator* temp = rotator_;
  rotator_ = NULL;
  return temp;
}
inline ::Gamedata::FRotator* EntityMoveTimelinePoint::mutable_rotator() {
  
  if (rotator_ == NULL) {
    rotator_ = new ::Gamedata::FRotator;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMoveTimelinePoint.rotator)
  return rotator_;
}
inline void EntityMoveTimelinePoint::set_allocated_rotator(::Gamedata::FRotator* rotator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rotator_);
  }
  if (rotator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotator, submessage_arena);
    }
    
  } else {
    
  }
  rotator_ = rotator;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMoveTimelinePoint.rotator)
}

// .Gamedata.FVector scale = 5;
inline bool EntityMoveTimelinePoint::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline const ::Gamedata::FVector& EntityMoveTimelinePoint::scale() const {
  const ::Gamedata::FVector* p = scale_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimelinePoint.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* EntityMoveTimelinePoint::release_scale() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMoveTimelinePoint.scale)
  
  ::Gamedata::FVector* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* EntityMoveTimelinePoint::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMoveTimelinePoint.scale)
  return scale_;
}
inline void EntityMoveTimelinePoint::set_allocated_scale(::Gamedata::FVector* scale) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(scale_);
  }
  if (scale) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scale = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMoveTimelinePoint.scale)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EntityMoveTimeline

// string name = 1;
inline void EntityMoveTimeline::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityMoveTimeline::name() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.name)
  return name_.GetNoArena();
}
inline void EntityMoveTimeline::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.name)
}
#if LANG_CXX11
inline void EntityMoveTimeline::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityMoveTimeline.name)
}
#endif
inline void EntityMoveTimeline::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityMoveTimeline.name)
}
inline void EntityMoveTimeline::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityMoveTimeline.name)
}
inline ::std::string* EntityMoveTimeline::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMoveTimeline.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityMoveTimeline::release_name() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMoveTimeline.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityMoveTimeline::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMoveTimeline.name)
}

// map<int32, .Gamedata.EntityMoveTimelinePoint> pointMap = 2;
inline int EntityMoveTimeline::pointmap_size() const {
  return pointmap_.size();
}
inline void EntityMoveTimeline::clear_pointmap() {
  pointmap_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint >&
EntityMoveTimeline::pointmap() const {
  // @@protoc_insertion_point(field_map:Gamedata.EntityMoveTimeline.pointMap)
  return pointmap_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMoveTimelinePoint >*
EntityMoveTimeline::mutable_pointmap() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.EntityMoveTimeline.pointMap)
  return pointmap_.MutableMap();
}

// .Gamedata.EntityMoveTimelineEndOfPlay EntityMoveTimelineEndOfPlay = 5;
inline void EntityMoveTimeline::clear_entitymovetimelineendofplay() {
  entitymovetimelineendofplay_ = 0;
}
inline ::Gamedata::EntityMoveTimelineEndOfPlay EntityMoveTimeline::entitymovetimelineendofplay() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.EntityMoveTimelineEndOfPlay)
  return static_cast< ::Gamedata::EntityMoveTimelineEndOfPlay >(entitymovetimelineendofplay_);
}
inline void EntityMoveTimeline::set_entitymovetimelineendofplay(::Gamedata::EntityMoveTimelineEndOfPlay value) {
  
  entitymovetimelineendofplay_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.EntityMoveTimelineEndOfPlay)
}

// bool isReflection = 6;
inline void EntityMoveTimeline::clear_isreflection() {
  isreflection_ = false;
}
inline bool EntityMoveTimeline::isreflection() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.isReflection)
  return isreflection_;
}
inline void EntityMoveTimeline::set_isreflection(bool value) {
  
  isreflection_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.isReflection)
}

// float size = 7;
inline void EntityMoveTimeline::clear_size() {
  size_ = 0;
}
inline float EntityMoveTimeline::size() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.size)
  return size_;
}
inline void EntityMoveTimeline::set_size(float value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.size)
}

// int32 lenght = 8;
inline void EntityMoveTimeline::clear_lenght() {
  lenght_ = 0;
}
inline ::google::protobuf::int32 EntityMoveTimeline::lenght() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.lenght)
  return lenght_;
}
inline void EntityMoveTimeline::set_lenght(::google::protobuf::int32 value) {
  
  lenght_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.lenght)
}

// float playLenght = 9;
inline void EntityMoveTimeline::clear_playlenght() {
  playlenght_ = 0;
}
inline float EntityMoveTimeline::playlenght() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.playLenght)
  return playlenght_;
}
inline void EntityMoveTimeline::set_playlenght(float value) {
  
  playlenght_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.playLenght)
}

// bool isMove = 10;
inline void EntityMoveTimeline::clear_ismove() {
  ismove_ = false;
}
inline bool EntityMoveTimeline::ismove() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.isMove)
  return ismove_;
}
inline void EntityMoveTimeline::set_ismove(bool value) {
  
  ismove_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.isMove)
}

// bool moveYaw = 11;
inline void EntityMoveTimeline::clear_moveyaw() {
  moveyaw_ = false;
}
inline bool EntityMoveTimeline::moveyaw() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.moveYaw)
  return moveyaw_;
}
inline void EntityMoveTimeline::set_moveyaw(bool value) {
  
  moveyaw_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.moveYaw)
}

// int32 scenesTimelineIndex = 12;
inline void EntityMoveTimeline::clear_scenestimelineindex() {
  scenestimelineindex_ = 0;
}
inline ::google::protobuf::int32 EntityMoveTimeline::scenestimelineindex() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.scenesTimelineIndex)
  return scenestimelineindex_;
}
inline void EntityMoveTimeline::set_scenestimelineindex(::google::protobuf::int32 value) {
  
  scenestimelineindex_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.scenesTimelineIndex)
}

// int32 entityListIndex = 13;
inline void EntityMoveTimeline::clear_entitylistindex() {
  entitylistindex_ = 0;
}
inline ::google::protobuf::int32 EntityMoveTimeline::entitylistindex() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMoveTimeline.entityListIndex)
  return entitylistindex_;
}
inline void EntityMoveTimeline::set_entitylistindex(::google::protobuf::int32 value) {
  
  entitylistindex_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMoveTimeline.entityListIndex)
}

// -------------------------------------------------------------------

// EntityPythonInfo

// .Gamedata.EntityPythonErrorType err = 1;
inline void EntityPythonInfo::clear_err() {
  err_ = 0;
}
inline ::Gamedata::EntityPythonErrorType EntityPythonInfo::err() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityPythonInfo.err)
  return static_cast< ::Gamedata::EntityPythonErrorType >(err_);
}
inline void EntityPythonInfo::set_err(::Gamedata::EntityPythonErrorType value) {
  
  err_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityPythonInfo.err)
}

// string py = 2;
inline void EntityPythonInfo::clear_py() {
  py_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityPythonInfo::py() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityPythonInfo.py)
  return py_.GetNoArena();
}
inline void EntityPythonInfo::set_py(const ::std::string& value) {
  
  py_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityPythonInfo.py)
}
#if LANG_CXX11
inline void EntityPythonInfo::set_py(::std::string&& value) {
  
  py_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityPythonInfo.py)
}
#endif
inline void EntityPythonInfo::set_py(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  py_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityPythonInfo.py)
}
inline void EntityPythonInfo::set_py(const char* value, size_t size) {
  
  py_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityPythonInfo.py)
}
inline ::std::string* EntityPythonInfo::mutable_py() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityPythonInfo.py)
  return py_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityPythonInfo::release_py() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityPythonInfo.py)
  
  return py_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityPythonInfo::set_allocated_py(::std::string* py) {
  if (py != NULL) {
    
  } else {
    
  }
  py_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), py);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityPythonInfo.py)
}

// -------------------------------------------------------------------

// EntityCommandAuto

// -------------------------------------------------------------------

// EntityCommandCommand

// string command_name = 2;
inline void EntityCommandCommand::clear_command_name() {
  command_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityCommandCommand::command_name() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandCommand.command_name)
  return command_name_.GetNoArena();
}
inline void EntityCommandCommand::set_command_name(const ::std::string& value) {
  
  command_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandCommand.command_name)
}
#if LANG_CXX11
inline void EntityCommandCommand::set_command_name(::std::string&& value) {
  
  command_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityCommandCommand.command_name)
}
#endif
inline void EntityCommandCommand::set_command_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityCommandCommand.command_name)
}
inline void EntityCommandCommand::set_command_name(const char* value, size_t size) {
  
  command_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityCommandCommand.command_name)
}
inline ::std::string* EntityCommandCommand::mutable_command_name() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityCommandCommand.command_name)
  return command_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityCommandCommand::release_command_name() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityCommandCommand.command_name)
  
  return command_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityCommandCommand::set_allocated_command_name(::std::string* command_name) {
  if (command_name != NULL) {
    
  } else {
    
  }
  command_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command_name);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityCommandCommand.command_name)
}

// float start_time = 3;
inline void EntityCommandCommand::clear_start_time() {
  start_time_ = 0;
}
inline float EntityCommandCommand::start_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandCommand.start_time)
  return start_time_;
}
inline void EntityCommandCommand::set_start_time(float value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandCommand.start_time)
}

// float end_time = 4;
inline void EntityCommandCommand::clear_end_time() {
  end_time_ = 0;
}
inline float EntityCommandCommand::end_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandCommand.end_time)
  return end_time_;
}
inline void EntityCommandCommand::set_end_time(float value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandCommand.end_time)
}

// -------------------------------------------------------------------

// EntityCommandInteractive

// bool is_fixed_position = 1;
inline void EntityCommandInteractive::clear_is_fixed_position() {
  is_fixed_position_ = false;
}
inline bool EntityCommandInteractive::is_fixed_position() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInteractive.is_fixed_position)
  return is_fixed_position_;
}
inline void EntityCommandInteractive::set_is_fixed_position(bool value) {
  
  is_fixed_position_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandInteractive.is_fixed_position)
}

// bool is_open = 2;
inline void EntityCommandInteractive::clear_is_open() {
  is_open_ = false;
}
inline bool EntityCommandInteractive::is_open() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInteractive.is_open)
  return is_open_;
}
inline void EntityCommandInteractive::set_is_open(bool value) {
  
  is_open_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandInteractive.is_open)
}

// float start_time = 3;
inline void EntityCommandInteractive::clear_start_time() {
  start_time_ = 0;
}
inline float EntityCommandInteractive::start_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInteractive.start_time)
  return start_time_;
}
inline void EntityCommandInteractive::set_start_time(float value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandInteractive.start_time)
}

// float end_time = 4;
inline void EntityCommandInteractive::clear_end_time() {
  end_time_ = 0;
}
inline float EntityCommandInteractive::end_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInteractive.end_time)
  return end_time_;
}
inline void EntityCommandInteractive::set_end_time(float value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandInteractive.end_time)
}

// -------------------------------------------------------------------

// EntityCommandTrigger

// bool is_open = 1;
inline void EntityCommandTrigger::clear_is_open() {
  is_open_ = false;
}
inline bool EntityCommandTrigger::is_open() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandTrigger.is_open)
  return is_open_;
}
inline void EntityCommandTrigger::set_is_open(bool value) {
  
  is_open_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandTrigger.is_open)
}

// float start_time = 2;
inline void EntityCommandTrigger::clear_start_time() {
  start_time_ = 0;
}
inline float EntityCommandTrigger::start_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandTrigger.start_time)
  return start_time_;
}
inline void EntityCommandTrigger::set_start_time(float value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandTrigger.start_time)
}

// float end_time = 3;
inline void EntityCommandTrigger::clear_end_time() {
  end_time_ = 0;
}
inline float EntityCommandTrigger::end_time() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandTrigger.end_time)
  return end_time_;
}
inline void EntityCommandTrigger::set_end_time(float value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandTrigger.end_time)
}

// -------------------------------------------------------------------

// EntityCommandInfo

// .Gamedata.EntityCommandType type = 1;
inline void EntityCommandInfo::clear_type() {
  type_ = 0;
}
inline ::Gamedata::EntityCommandType EntityCommandInfo::type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInfo.type)
  return static_cast< ::Gamedata::EntityCommandType >(type_);
}
inline void EntityCommandInfo::set_type(::Gamedata::EntityCommandType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityCommandInfo.type)
}

// repeated .Gamedata.EntityCommandCommand command_list = 2;
inline int EntityCommandInfo::command_list_size() const {
  return command_list_.size();
}
inline void EntityCommandInfo::clear_command_list() {
  command_list_.Clear();
}
inline const ::Gamedata::EntityCommandCommand& EntityCommandInfo::command_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInfo.command_list)
  return command_list_.Get(index);
}
inline ::Gamedata::EntityCommandCommand* EntityCommandInfo::mutable_command_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityCommandInfo.command_list)
  return command_list_.Mutable(index);
}
inline ::Gamedata::EntityCommandCommand* EntityCommandInfo::add_command_list() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityCommandInfo.command_list)
  return command_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityCommandCommand >*
EntityCommandInfo::mutable_command_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityCommandInfo.command_list)
  return &command_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityCommandCommand >&
EntityCommandInfo::command_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityCommandInfo.command_list)
  return command_list_;
}

// .Gamedata.EntityCommandInteractive interactive = 3;
inline bool EntityCommandInfo::has_interactive() const {
  return this != internal_default_instance() && interactive_ != NULL;
}
inline void EntityCommandInfo::clear_interactive() {
  if (GetArenaNoVirtual() == NULL && interactive_ != NULL) {
    delete interactive_;
  }
  interactive_ = NULL;
}
inline const ::Gamedata::EntityCommandInteractive& EntityCommandInfo::interactive() const {
  const ::Gamedata::EntityCommandInteractive* p = interactive_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInfo.interactive)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityCommandInteractive*>(
      &::Gamedata::_EntityCommandInteractive_default_instance_);
}
inline ::Gamedata::EntityCommandInteractive* EntityCommandInfo::release_interactive() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityCommandInfo.interactive)
  
  ::Gamedata::EntityCommandInteractive* temp = interactive_;
  interactive_ = NULL;
  return temp;
}
inline ::Gamedata::EntityCommandInteractive* EntityCommandInfo::mutable_interactive() {
  
  if (interactive_ == NULL) {
    interactive_ = new ::Gamedata::EntityCommandInteractive;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityCommandInfo.interactive)
  return interactive_;
}
inline void EntityCommandInfo::set_allocated_interactive(::Gamedata::EntityCommandInteractive* interactive) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete interactive_;
  }
  if (interactive) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      interactive = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interactive, submessage_arena);
    }
    
  } else {
    
  }
  interactive_ = interactive;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityCommandInfo.interactive)
}

// .Gamedata.EntityCommandTrigger trigger = 4;
inline bool EntityCommandInfo::has_trigger() const {
  return this != internal_default_instance() && trigger_ != NULL;
}
inline void EntityCommandInfo::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) {
    delete trigger_;
  }
  trigger_ = NULL;
}
inline const ::Gamedata::EntityCommandTrigger& EntityCommandInfo::trigger() const {
  const ::Gamedata::EntityCommandTrigger* p = trigger_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityCommandInfo.trigger)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityCommandTrigger*>(
      &::Gamedata::_EntityCommandTrigger_default_instance_);
}
inline ::Gamedata::EntityCommandTrigger* EntityCommandInfo::release_trigger() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityCommandInfo.trigger)
  
  ::Gamedata::EntityCommandTrigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline ::Gamedata::EntityCommandTrigger* EntityCommandInfo::mutable_trigger() {
  
  if (trigger_ == NULL) {
    trigger_ = new ::Gamedata::EntityCommandTrigger;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityCommandInfo.trigger)
  return trigger_;
}
inline void EntityCommandInfo::set_allocated_trigger(::Gamedata::EntityCommandTrigger* trigger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trigger_;
  }
  if (trigger) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trigger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityCommandInfo.trigger)
}

// -------------------------------------------------------------------

// EntityTransformTimelinePoint

// int32 uniqueMark = 1;
inline void EntityTransformTimelinePoint::clear_uniquemark() {
  uniquemark_ = 0;
}
inline ::google::protobuf::int32 EntityTransformTimelinePoint::uniquemark() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimelinePoint.uniqueMark)
  return uniquemark_;
}
inline void EntityTransformTimelinePoint::set_uniquemark(::google::protobuf::int32 value) {
  
  uniquemark_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimelinePoint.uniqueMark)
}

// .Gamedata.FVector location = 2;
inline bool EntityTransformTimelinePoint::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::Gamedata::FVector& EntityTransformTimelinePoint::location() const {
  const ::Gamedata::FVector* p = location_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimelinePoint.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* EntityTransformTimelinePoint::release_location() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityTransformTimelinePoint.location)
  
  ::Gamedata::FVector* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* EntityTransformTimelinePoint::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityTransformTimelinePoint.location)
  return location_;
}
inline void EntityTransformTimelinePoint::set_allocated_location(::Gamedata::FVector* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityTransformTimelinePoint.location)
}

// .Gamedata.FRotator rotator = 3;
inline bool EntityTransformTimelinePoint::has_rotator() const {
  return this != internal_default_instance() && rotator_ != NULL;
}
inline const ::Gamedata::FRotator& EntityTransformTimelinePoint::rotator() const {
  const ::Gamedata::FRotator* p = rotator_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimelinePoint.rotator)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FRotator*>(
      &::Gamedata::_FRotator_default_instance_);
}
inline ::Gamedata::FRotator* EntityTransformTimelinePoint::release_rotator() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityTransformTimelinePoint.rotator)
  
  ::Gamedata::FRotator* temp = rotator_;
  rotator_ = NULL;
  return temp;
}
inline ::Gamedata::FRotator* EntityTransformTimelinePoint::mutable_rotator() {
  
  if (rotator_ == NULL) {
    rotator_ = new ::Gamedata::FRotator;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityTransformTimelinePoint.rotator)
  return rotator_;
}
inline void EntityTransformTimelinePoint::set_allocated_rotator(::Gamedata::FRotator* rotator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rotator_);
  }
  if (rotator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotator, submessage_arena);
    }
    
  } else {
    
  }
  rotator_ = rotator;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityTransformTimelinePoint.rotator)
}

// .Gamedata.FVector color = 4;
inline bool EntityTransformTimelinePoint::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline const ::Gamedata::FVector& EntityTransformTimelinePoint::color() const {
  const ::Gamedata::FVector* p = color_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimelinePoint.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* EntityTransformTimelinePoint::release_color() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityTransformTimelinePoint.color)
  
  ::Gamedata::FVector* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* EntityTransformTimelinePoint::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityTransformTimelinePoint.color)
  return color_;
}
inline void EntityTransformTimelinePoint::set_allocated_color(::Gamedata::FVector* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(color_);
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityTransformTimelinePoint.color)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EntityTransformTimeline

// map<int32, .Gamedata.EntityTransformTimelinePoint> point_map = 1;
inline int EntityTransformTimeline::point_map_size() const {
  return point_map_.size();
}
inline void EntityTransformTimeline::clear_point_map() {
  point_map_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint >&
EntityTransformTimeline::point_map() const {
  // @@protoc_insertion_point(field_map:Gamedata.EntityTransformTimeline.point_map)
  return point_map_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityTransformTimelinePoint >*
EntityTransformTimeline::mutable_point_map() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.EntityTransformTimeline.point_map)
  return point_map_.MutableMap();
}

// bool is_loop = 2;
inline void EntityTransformTimeline::clear_is_loop() {
  is_loop_ = false;
}
inline bool EntityTransformTimeline::is_loop() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimeline.is_loop)
  return is_loop_;
}
inline void EntityTransformTimeline::set_is_loop(bool value) {
  
  is_loop_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimeline.is_loop)
}

// int32 version = 3;
inline void EntityTransformTimeline::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 EntityTransformTimeline::version() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimeline.version)
  return version_;
}
inline void EntityTransformTimeline::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimeline.version)
}

// .Gamedata.TimelineHighlightType timeline_highlight = 4;
inline void EntityTransformTimeline::clear_timeline_highlight() {
  timeline_highlight_ = 0;
}
inline ::Gamedata::TimelineHighlightType EntityTransformTimeline::timeline_highlight() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimeline.timeline_highlight)
  return static_cast< ::Gamedata::TimelineHighlightType >(timeline_highlight_);
}
inline void EntityTransformTimeline::set_timeline_highlight(::Gamedata::TimelineHighlightType value) {
  
  timeline_highlight_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimeline.timeline_highlight)
}

// bool location_teleport = 5;
inline void EntityTransformTimeline::clear_location_teleport() {
  location_teleport_ = false;
}
inline bool EntityTransformTimeline::location_teleport() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimeline.location_teleport)
  return location_teleport_;
}
inline void EntityTransformTimeline::set_location_teleport(bool value) {
  
  location_teleport_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimeline.location_teleport)
}

// bool color_teleport = 6;
inline void EntityTransformTimeline::clear_color_teleport() {
  color_teleport_ = false;
}
inline bool EntityTransformTimeline::color_teleport() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityTransformTimeline.color_teleport)
  return color_teleport_;
}
inline void EntityTransformTimeline::set_color_teleport(bool value) {
  
  color_teleport_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityTransformTimeline.color_teleport)
}

// -------------------------------------------------------------------

// EntityChildInfo

// .Gamedata.FTransform transform = 2;
inline bool EntityChildInfo::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline const ::Gamedata::FTransform& EntityChildInfo::transform() const {
  const ::Gamedata::FTransform* p = transform_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityChildInfo.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* EntityChildInfo::release_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityChildInfo.transform)
  
  ::Gamedata::FTransform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* EntityChildInfo::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityChildInfo.transform)
  return transform_;
}
inline void EntityChildInfo::set_allocated_transform(::Gamedata::FTransform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transform_);
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityChildInfo.transform)
}

// .Gamedata.EntityMMeshInfo mesh = 3;
inline bool EntityChildInfo::has_mesh() const {
  return this != internal_default_instance() && mesh_ != NULL;
}
inline void EntityChildInfo::clear_mesh() {
  if (GetArenaNoVirtual() == NULL && mesh_ != NULL) {
    delete mesh_;
  }
  mesh_ = NULL;
}
inline const ::Gamedata::EntityMMeshInfo& EntityChildInfo::mesh() const {
  const ::Gamedata::EntityMMeshInfo* p = mesh_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityChildInfo.mesh)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityMMeshInfo*>(
      &::Gamedata::_EntityMMeshInfo_default_instance_);
}
inline ::Gamedata::EntityMMeshInfo* EntityChildInfo::release_mesh() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityChildInfo.mesh)
  
  ::Gamedata::EntityMMeshInfo* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline ::Gamedata::EntityMMeshInfo* EntityChildInfo::mutable_mesh() {
  
  if (mesh_ == NULL) {
    mesh_ = new ::Gamedata::EntityMMeshInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityChildInfo.mesh)
  return mesh_;
}
inline void EntityChildInfo::set_allocated_mesh(::Gamedata::EntityMMeshInfo* mesh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mesh_;
  }
  if (mesh) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mesh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mesh, submessage_arena);
    }
    
  } else {
    
  }
  mesh_ = mesh;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityChildInfo.mesh)
}

// .Gamedata.EntityImageInfo image = 4;
inline bool EntityChildInfo::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void EntityChildInfo::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::Gamedata::EntityImageInfo& EntityChildInfo::image() const {
  const ::Gamedata::EntityImageInfo* p = image_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityChildInfo.image)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityImageInfo*>(
      &::Gamedata::_EntityImageInfo_default_instance_);
}
inline ::Gamedata::EntityImageInfo* EntityChildInfo::release_image() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityChildInfo.image)
  
  ::Gamedata::EntityImageInfo* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::Gamedata::EntityImageInfo* EntityChildInfo::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::Gamedata::EntityImageInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityChildInfo.image)
  return image_;
}
inline void EntityChildInfo::set_allocated_image(::Gamedata::EntityImageInfo* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityChildInfo.image)
}

// -------------------------------------------------------------------

// EntityMMeshInfo

// int32 xls_id = 1;
inline void EntityMMeshInfo::clear_xls_id() {
  xls_id_ = 0;
}
inline ::google::protobuf::int32 EntityMMeshInfo::xls_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMMeshInfo.xls_id)
  return xls_id_;
}
inline void EntityMMeshInfo::set_xls_id(::google::protobuf::int32 value) {
  
  xls_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMMeshInfo.xls_id)
}

// int32 material_id = 2;
inline void EntityMMeshInfo::clear_material_id() {
  material_id_ = 0;
}
inline ::google::protobuf::int32 EntityMMeshInfo::material_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMMeshInfo.material_id)
  return material_id_;
}
inline void EntityMMeshInfo::set_material_id(::google::protobuf::int32 value) {
  
  material_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMMeshInfo.material_id)
}

// bool highlight = 3;
inline void EntityMMeshInfo::clear_highlight() {
  highlight_ = false;
}
inline bool EntityMMeshInfo::highlight() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMMeshInfo.highlight)
  return highlight_;
}
inline void EntityMMeshInfo::set_highlight(bool value) {
  
  highlight_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMMeshInfo.highlight)
}

// .Gamedata.FVector color = 4;
inline bool EntityMMeshInfo::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline const ::Gamedata::FVector& EntityMMeshInfo::color() const {
  const ::Gamedata::FVector* p = color_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityMMeshInfo.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* EntityMMeshInfo::release_color() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMMeshInfo.color)
  
  ::Gamedata::FVector* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* EntityMMeshInfo::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMMeshInfo.color)
  return color_;
}
inline void EntityMMeshInfo::set_allocated_color(::Gamedata::FVector* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(color_);
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMMeshInfo.color)
}

// -------------------------------------------------------------------

// EntityImageInfo

// string url = 8;
inline void EntityImageInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityImageInfo::url() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityImageInfo.url)
  return url_.GetNoArena();
}
inline void EntityImageInfo::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityImageInfo.url)
}
#if LANG_CXX11
inline void EntityImageInfo::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityImageInfo.url)
}
#endif
inline void EntityImageInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityImageInfo.url)
}
inline void EntityImageInfo::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityImageInfo.url)
}
inline ::std::string* EntityImageInfo::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityImageInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityImageInfo::release_url() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityImageInfo.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityImageInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityImageInfo.url)
}

// -------------------------------------------------------------------

// EntityInfo

// int32 entityId = 1;
inline void EntityInfo::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 EntityInfo::entityid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.entityId)
  return entityid_;
}
inline void EntityInfo::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityInfo.entityId)
}

// int32 playerId = 2;
inline void EntityInfo::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 EntityInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.playerId)
  return playerid_;
}
inline void EntityInfo::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityInfo.playerId)
}

// .Gamedata.FTransform transform = 3;
inline bool EntityInfo::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline const ::Gamedata::FTransform& EntityInfo::transform() const {
  const ::Gamedata::FTransform* p = transform_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* EntityInfo::release_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityInfo.transform)
  
  ::Gamedata::FTransform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* EntityInfo::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.transform)
  return transform_;
}
inline void EntityInfo::set_allocated_transform(::Gamedata::FTransform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transform_);
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityInfo.transform)
}

// .Gamedata.EntityCollisionType collision_type = 4;
inline void EntityInfo::clear_collision_type() {
  collision_type_ = 0;
}
inline ::Gamedata::EntityCollisionType EntityInfo::collision_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.collision_type)
  return static_cast< ::Gamedata::EntityCollisionType >(collision_type_);
}
inline void EntityInfo::set_collision_type(::Gamedata::EntityCollisionType value) {
  
  collision_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityInfo.collision_type)
}

// repeated .Gamedata.EntityChildInfo child_list = 5;
inline int EntityInfo::child_list_size() const {
  return child_list_.size();
}
inline void EntityInfo::clear_child_list() {
  child_list_.Clear();
}
inline const ::Gamedata::EntityChildInfo& EntityInfo::child_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.child_list)
  return child_list_.Get(index);
}
inline ::Gamedata::EntityChildInfo* EntityInfo::mutable_child_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.child_list)
  return child_list_.Mutable(index);
}
inline ::Gamedata::EntityChildInfo* EntityInfo::add_child_list() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityInfo.child_list)
  return child_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityChildInfo >*
EntityInfo::mutable_child_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityInfo.child_list)
  return &child_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityChildInfo >&
EntityInfo::child_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityInfo.child_list)
  return child_list_;
}

// .Gamedata.EntitySplineAlone spline = 6;
inline bool EntityInfo::has_spline() const {
  return this != internal_default_instance() && spline_ != NULL;
}
inline void EntityInfo::clear_spline() {
  if (GetArenaNoVirtual() == NULL && spline_ != NULL) {
    delete spline_;
  }
  spline_ = NULL;
}
inline const ::Gamedata::EntitySplineAlone& EntityInfo::spline() const {
  const ::Gamedata::EntitySplineAlone* p = spline_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.spline)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntitySplineAlone*>(
      &::Gamedata::_EntitySplineAlone_default_instance_);
}
inline ::Gamedata::EntitySplineAlone* EntityInfo::release_spline() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityInfo.spline)
  
  ::Gamedata::EntitySplineAlone* temp = spline_;
  spline_ = NULL;
  return temp;
}
inline ::Gamedata::EntitySplineAlone* EntityInfo::mutable_spline() {
  
  if (spline_ == NULL) {
    spline_ = new ::Gamedata::EntitySplineAlone;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.spline)
  return spline_;
}
inline void EntityInfo::set_allocated_spline(::Gamedata::EntitySplineAlone* spline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete spline_;
  }
  if (spline) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spline, submessage_arena);
    }
    
  } else {
    
  }
  spline_ = spline;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityInfo.spline)
}

// .Gamedata.EntityPythonInfo python_info = 7;
inline bool EntityInfo::has_python_info() const {
  return this != internal_default_instance() && python_info_ != NULL;
}
inline void EntityInfo::clear_python_info() {
  if (GetArenaNoVirtual() == NULL && python_info_ != NULL) {
    delete python_info_;
  }
  python_info_ = NULL;
}
inline const ::Gamedata::EntityPythonInfo& EntityInfo::python_info() const {
  const ::Gamedata::EntityPythonInfo* p = python_info_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.python_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityPythonInfo*>(
      &::Gamedata::_EntityPythonInfo_default_instance_);
}
inline ::Gamedata::EntityPythonInfo* EntityInfo::release_python_info() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityInfo.python_info)
  
  ::Gamedata::EntityPythonInfo* temp = python_info_;
  python_info_ = NULL;
  return temp;
}
inline ::Gamedata::EntityPythonInfo* EntityInfo::mutable_python_info() {
  
  if (python_info_ == NULL) {
    python_info_ = new ::Gamedata::EntityPythonInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.python_info)
  return python_info_;
}
inline void EntityInfo::set_allocated_python_info(::Gamedata::EntityPythonInfo* python_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete python_info_;
  }
  if (python_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      python_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, python_info, submessage_arena);
    }
    
  } else {
    
  }
  python_info_ = python_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityInfo.python_info)
}

// .Gamedata.EntityTransformTimeline transform_timeline = 8;
inline bool EntityInfo::has_transform_timeline() const {
  return this != internal_default_instance() && transform_timeline_ != NULL;
}
inline void EntityInfo::clear_transform_timeline() {
  if (GetArenaNoVirtual() == NULL && transform_timeline_ != NULL) {
    delete transform_timeline_;
  }
  transform_timeline_ = NULL;
}
inline const ::Gamedata::EntityTransformTimeline& EntityInfo::transform_timeline() const {
  const ::Gamedata::EntityTransformTimeline* p = transform_timeline_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.transform_timeline)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityTransformTimeline*>(
      &::Gamedata::_EntityTransformTimeline_default_instance_);
}
inline ::Gamedata::EntityTransformTimeline* EntityInfo::release_transform_timeline() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityInfo.transform_timeline)
  
  ::Gamedata::EntityTransformTimeline* temp = transform_timeline_;
  transform_timeline_ = NULL;
  return temp;
}
inline ::Gamedata::EntityTransformTimeline* EntityInfo::mutable_transform_timeline() {
  
  if (transform_timeline_ == NULL) {
    transform_timeline_ = new ::Gamedata::EntityTransformTimeline;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.transform_timeline)
  return transform_timeline_;
}
inline void EntityInfo::set_allocated_transform_timeline(::Gamedata::EntityTransformTimeline* transform_timeline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_timeline_;
  }
  if (transform_timeline) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform_timeline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform_timeline, submessage_arena);
    }
    
  } else {
    
  }
  transform_timeline_ = transform_timeline;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityInfo.transform_timeline)
}

// .Gamedata.EntityCommandInfo command = 9;
inline bool EntityInfo::has_command() const {
  return this != internal_default_instance() && command_ != NULL;
}
inline void EntityInfo::clear_command() {
  if (GetArenaNoVirtual() == NULL && command_ != NULL) {
    delete command_;
  }
  command_ = NULL;
}
inline const ::Gamedata::EntityCommandInfo& EntityInfo::command() const {
  const ::Gamedata::EntityCommandInfo* p = command_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.command)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityCommandInfo*>(
      &::Gamedata::_EntityCommandInfo_default_instance_);
}
inline ::Gamedata::EntityCommandInfo* EntityInfo::release_command() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityInfo.command)
  
  ::Gamedata::EntityCommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::Gamedata::EntityCommandInfo* EntityInfo::mutable_command() {
  
  if (command_ == NULL) {
    command_ = new ::Gamedata::EntityCommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityInfo.command)
  return command_;
}
inline void EntityInfo::set_allocated_command(::Gamedata::EntityCommandInfo* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityInfo.command)
}

// int32 lockPlayerId = 10;
inline void EntityInfo::clear_lockplayerid() {
  lockplayerid_ = 0;
}
inline ::google::protobuf::int32 EntityInfo::lockplayerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.lockPlayerId)
  return lockplayerid_;
}
inline void EntityInfo::set_lockplayerid(::google::protobuf::int32 value) {
  
  lockplayerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityInfo.lockPlayerId)
}

// .Gamedata.EntitySyncType entity_sync_type = 11;
inline void EntityInfo::clear_entity_sync_type() {
  entity_sync_type_ = 0;
}
inline ::Gamedata::EntitySyncType EntityInfo::entity_sync_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityInfo.entity_sync_type)
  return static_cast< ::Gamedata::EntitySyncType >(entity_sync_type_);
}
inline void EntityInfo::set_entity_sync_type(::Gamedata::EntitySyncType value) {
  
  entity_sync_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityInfo.entity_sync_type)
}

// -------------------------------------------------------------------

// EntityEnterView

// repeated .Gamedata.EntityInfo entityInfoList = 1;
inline int EntityEnterView::entityinfolist_size() const {
  return entityinfolist_.size();
}
inline void EntityEnterView::clear_entityinfolist() {
  entityinfolist_.Clear();
}
inline const ::Gamedata::EntityInfo& EntityEnterView::entityinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityEnterView.entityInfoList)
  return entityinfolist_.Get(index);
}
inline ::Gamedata::EntityInfo* EntityEnterView::mutable_entityinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityEnterView.entityInfoList)
  return entityinfolist_.Mutable(index);
}
inline ::Gamedata::EntityInfo* EntityEnterView::add_entityinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityEnterView.entityInfoList)
  return entityinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
EntityEnterView::mutable_entityinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityEnterView.entityInfoList)
  return &entityinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
EntityEnterView::entityinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityEnterView.entityInfoList)
  return entityinfolist_;
}

// -------------------------------------------------------------------

// EntityUpdateView

// repeated .Gamedata.EntityInfo entityInfoList = 1;
inline int EntityUpdateView::entityinfolist_size() const {
  return entityinfolist_.size();
}
inline void EntityUpdateView::clear_entityinfolist() {
  entityinfolist_.Clear();
}
inline const ::Gamedata::EntityInfo& EntityUpdateView::entityinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityUpdateView.entityInfoList)
  return entityinfolist_.Get(index);
}
inline ::Gamedata::EntityInfo* EntityUpdateView::mutable_entityinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityUpdateView.entityInfoList)
  return entityinfolist_.Mutable(index);
}
inline ::Gamedata::EntityInfo* EntityUpdateView::add_entityinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityUpdateView.entityInfoList)
  return entityinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
EntityUpdateView::mutable_entityinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityUpdateView.entityInfoList)
  return &entityinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
EntityUpdateView::entityinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityUpdateView.entityInfoList)
  return entityinfolist_;
}

// -------------------------------------------------------------------

// EntityLeaveView

// repeated int32 entityIdList = 1;
inline int EntityLeaveView::entityidlist_size() const {
  return entityidlist_.size();
}
inline void EntityLeaveView::clear_entityidlist() {
  entityidlist_.Clear();
}
inline ::google::protobuf::int32 EntityLeaveView::entityidlist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityLeaveView.entityIdList)
  return entityidlist_.Get(index);
}
inline void EntityLeaveView::set_entityidlist(int index, ::google::protobuf::int32 value) {
  entityidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityLeaveView.entityIdList)
}
inline void EntityLeaveView::add_entityidlist(::google::protobuf::int32 value) {
  entityidlist_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.EntityLeaveView.entityIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EntityLeaveView::entityidlist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityLeaveView.entityIdList)
  return entityidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EntityLeaveView::mutable_entityidlist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityLeaveView.entityIdList)
  return &entityidlist_;
}

// -------------------------------------------------------------------

// EntityAddRequest

// repeated .Gamedata.EntityInfo entityInfoList = 1;
inline int EntityAddRequest::entityinfolist_size() const {
  return entityinfolist_.size();
}
inline void EntityAddRequest::clear_entityinfolist() {
  entityinfolist_.Clear();
}
inline const ::Gamedata::EntityInfo& EntityAddRequest::entityinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityAddRequest.entityInfoList)
  return entityinfolist_.Get(index);
}
inline ::Gamedata::EntityInfo* EntityAddRequest::mutable_entityinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityAddRequest.entityInfoList)
  return entityinfolist_.Mutable(index);
}
inline ::Gamedata::EntityInfo* EntityAddRequest::add_entityinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityAddRequest.entityInfoList)
  return entityinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
EntityAddRequest::mutable_entityinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityAddRequest.entityInfoList)
  return &entityinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
EntityAddRequest::entityinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityAddRequest.entityInfoList)
  return entityinfolist_;
}

// int32 playerId = 2;
inline void EntityAddRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 EntityAddRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityAddRequest.playerId)
  return playerid_;
}
inline void EntityAddRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityAddRequest.playerId)
}

// -------------------------------------------------------------------

// EntityRemoveRequest

// repeated int32 entityIdList = 1;
inline int EntityRemoveRequest::entityidlist_size() const {
  return entityidlist_.size();
}
inline void EntityRemoveRequest::clear_entityidlist() {
  entityidlist_.Clear();
}
inline ::google::protobuf::int32 EntityRemoveRequest::entityidlist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityRemoveRequest.entityIdList)
  return entityidlist_.Get(index);
}
inline void EntityRemoveRequest::set_entityidlist(int index, ::google::protobuf::int32 value) {
  entityidlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityRemoveRequest.entityIdList)
}
inline void EntityRemoveRequest::add_entityidlist(::google::protobuf::int32 value) {
  entityidlist_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.EntityRemoveRequest.entityIdList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EntityRemoveRequest::entityidlist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityRemoveRequest.entityIdList)
  return entityidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EntityRemoveRequest::mutable_entityidlist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityRemoveRequest.entityIdList)
  return &entityidlist_;
}

// int32 playerId = 2;
inline void EntityRemoveRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 EntityRemoveRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityRemoveRequest.playerId)
  return playerid_;
}
inline void EntityRemoveRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityRemoveRequest.playerId)
}

// -------------------------------------------------------------------

// EntityUpdateRequest

// repeated .Gamedata.EntityInfo entityInfoList = 1;
inline int EntityUpdateRequest::entityinfolist_size() const {
  return entityinfolist_.size();
}
inline void EntityUpdateRequest::clear_entityinfolist() {
  entityinfolist_.Clear();
}
inline const ::Gamedata::EntityInfo& EntityUpdateRequest::entityinfolist(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityUpdateRequest.entityInfoList)
  return entityinfolist_.Get(index);
}
inline ::Gamedata::EntityInfo* EntityUpdateRequest::mutable_entityinfolist(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityUpdateRequest.entityInfoList)
  return entityinfolist_.Mutable(index);
}
inline ::Gamedata::EntityInfo* EntityUpdateRequest::add_entityinfolist() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityUpdateRequest.entityInfoList)
  return entityinfolist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >*
EntityUpdateRequest::mutable_entityinfolist() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityUpdateRequest.entityInfoList)
  return &entityinfolist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityInfo >&
EntityUpdateRequest::entityinfolist() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityUpdateRequest.entityInfoList)
  return entityinfolist_;
}

// int32 playerId = 2;
inline void EntityUpdateRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 EntityUpdateRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityUpdateRequest.playerId)
  return playerid_;
}
inline void EntityUpdateRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityUpdateRequest.playerId)
}

// -------------------------------------------------------------------

// EntityOperationValue1

// bool isPlay = 1;
inline void EntityOperationValue1::clear_isplay() {
  isplay_ = false;
}
inline bool EntityOperationValue1::isplay() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationValue1.isPlay)
  return isplay_;
}
inline void EntityOperationValue1::set_isplay(bool value) {
  
  isplay_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityOperationValue1.isPlay)
}

// -------------------------------------------------------------------

// EntityOperationValue2

// bool isPlay = 1;
inline void EntityOperationValue2::clear_isplay() {
  isplay_ = false;
}
inline bool EntityOperationValue2::isplay() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationValue2.isPlay)
  return isplay_;
}
inline void EntityOperationValue2::set_isplay(bool value) {
  
  isplay_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityOperationValue2.isPlay)
}

// -------------------------------------------------------------------

// EntityOperationAlone

// .Gamedata.EntityOperationType theType = 1;
inline void EntityOperationAlone::clear_thetype() {
  thetype_ = 0;
}
inline ::Gamedata::EntityOperationType EntityOperationAlone::thetype() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationAlone.theType)
  return static_cast< ::Gamedata::EntityOperationType >(thetype_);
}
inline void EntityOperationAlone::set_thetype(::Gamedata::EntityOperationType value) {
  
  thetype_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityOperationAlone.theType)
}

// int32 playerId = 2;
inline void EntityOperationAlone::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 EntityOperationAlone::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationAlone.playerId)
  return playerid_;
}
inline void EntityOperationAlone::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityOperationAlone.playerId)
}

// int32 entityId = 3;
inline void EntityOperationAlone::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 EntityOperationAlone::entityid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationAlone.entityId)
  return entityid_;
}
inline void EntityOperationAlone::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityOperationAlone.entityId)
}

// repeated .Gamedata.EntityOperationValue1 value1 = 4;
inline int EntityOperationAlone::value1_size() const {
  return value1_.size();
}
inline void EntityOperationAlone::clear_value1() {
  value1_.Clear();
}
inline const ::Gamedata::EntityOperationValue1& EntityOperationAlone::value1(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationAlone.value1)
  return value1_.Get(index);
}
inline ::Gamedata::EntityOperationValue1* EntityOperationAlone::mutable_value1(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityOperationAlone.value1)
  return value1_.Mutable(index);
}
inline ::Gamedata::EntityOperationValue1* EntityOperationAlone::add_value1() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityOperationAlone.value1)
  return value1_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue1 >*
EntityOperationAlone::mutable_value1() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityOperationAlone.value1)
  return &value1_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue1 >&
EntityOperationAlone::value1() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityOperationAlone.value1)
  return value1_;
}

// repeated .Gamedata.EntityOperationValue2 value2 = 5;
inline int EntityOperationAlone::value2_size() const {
  return value2_.size();
}
inline void EntityOperationAlone::clear_value2() {
  value2_.Clear();
}
inline const ::Gamedata::EntityOperationValue2& EntityOperationAlone::value2(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationAlone.value2)
  return value2_.Get(index);
}
inline ::Gamedata::EntityOperationValue2* EntityOperationAlone::mutable_value2(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityOperationAlone.value2)
  return value2_.Mutable(index);
}
inline ::Gamedata::EntityOperationValue2* EntityOperationAlone::add_value2() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityOperationAlone.value2)
  return value2_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue2 >*
EntityOperationAlone::mutable_value2() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityOperationAlone.value2)
  return &value2_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationValue2 >&
EntityOperationAlone::value2() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityOperationAlone.value2)
  return value2_;
}

// -------------------------------------------------------------------

// EntityOperationTotal

// repeated .Gamedata.EntityOperationAlone node = 1;
inline int EntityOperationTotal::node_size() const {
  return node_.size();
}
inline void EntityOperationTotal::clear_node() {
  node_.Clear();
}
inline const ::Gamedata::EntityOperationAlone& EntityOperationTotal::node(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityOperationTotal.node)
  return node_.Get(index);
}
inline ::Gamedata::EntityOperationAlone* EntityOperationTotal::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityOperationTotal.node)
  return node_.Mutable(index);
}
inline ::Gamedata::EntityOperationAlone* EntityOperationTotal::add_node() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityOperationTotal.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationAlone >*
EntityOperationTotal::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityOperationTotal.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityOperationAlone >&
EntityOperationTotal::node() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityOperationTotal.node)
  return node_;
}

// -------------------------------------------------------------------

// OverallSituationSkyInfo

// int32 time = 1;
inline void OverallSituationSkyInfo::clear_time() {
  time_ = 0;
}
inline ::google::protobuf::int32 OverallSituationSkyInfo::time() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationSkyInfo.time)
  return time_;
}
inline void OverallSituationSkyInfo::set_time(::google::protobuf::int32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationSkyInfo.time)
}

// int32 weather = 2;
inline void OverallSituationSkyInfo::clear_weather() {
  weather_ = 0;
}
inline ::google::protobuf::int32 OverallSituationSkyInfo::weather() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationSkyInfo.weather)
  return weather_;
}
inline void OverallSituationSkyInfo::set_weather(::google::protobuf::int32 value) {
  
  weather_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationSkyInfo.weather)
}

// int32 cloud_coverageoverall = 3;
inline void OverallSituationSkyInfo::clear_cloud_coverageoverall() {
  cloud_coverageoverall_ = 0;
}
inline ::google::protobuf::int32 OverallSituationSkyInfo::cloud_coverageoverall() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationSkyInfo.cloud_coverageoverall)
  return cloud_coverageoverall_;
}
inline void OverallSituationSkyInfo::set_cloud_coverageoverall(::google::protobuf::int32 value) {
  
  cloud_coverageoverall_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationSkyInfo.cloud_coverageoverall)
}

// int32 cloud_speed = 4;
inline void OverallSituationSkyInfo::clear_cloud_speed() {
  cloud_speed_ = 0;
}
inline ::google::protobuf::int32 OverallSituationSkyInfo::cloud_speed() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationSkyInfo.cloud_speed)
  return cloud_speed_;
}
inline void OverallSituationSkyInfo::set_cloud_speed(::google::protobuf::int32 value) {
  
  cloud_speed_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationSkyInfo.cloud_speed)
}

// int32 moon_color = 5;
inline void OverallSituationSkyInfo::clear_moon_color() {
  moon_color_ = 0;
}
inline ::google::protobuf::int32 OverallSituationSkyInfo::moon_color() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationSkyInfo.moon_color)
  return moon_color_;
}
inline void OverallSituationSkyInfo::set_moon_color(::google::protobuf::int32 value) {
  
  moon_color_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationSkyInfo.moon_color)
}

// -------------------------------------------------------------------

// EntityMeshChildInfo

// int32 xlsId = 4;
inline void EntityMeshChildInfo::clear_xlsid() {
  xlsid_ = 0;
}
inline ::google::protobuf::int32 EntityMeshChildInfo::xlsid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshChildInfo.xlsId)
  return xlsid_;
}
inline void EntityMeshChildInfo::set_xlsid(::google::protobuf::int32 value) {
  
  xlsid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshChildInfo.xlsId)
}

// int32 materialId = 5;
inline void EntityMeshChildInfo::clear_materialid() {
  materialid_ = 0;
}
inline ::google::protobuf::int32 EntityMeshChildInfo::materialid() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshChildInfo.materialId)
  return materialid_;
}
inline void EntityMeshChildInfo::set_materialid(::google::protobuf::int32 value) {
  
  materialid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshChildInfo.materialId)
}

// .Gamedata.FTransform transform = 7;
inline bool EntityMeshChildInfo::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline const ::Gamedata::FTransform& EntityMeshChildInfo::transform() const {
  const ::Gamedata::FTransform* p = transform_;
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshChildInfo.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* EntityMeshChildInfo::release_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMeshChildInfo.transform)
  
  ::Gamedata::FTransform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* EntityMeshChildInfo::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMeshChildInfo.transform)
  return transform_;
}
inline void EntityMeshChildInfo::set_allocated_transform(::Gamedata::FTransform* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transform_);
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMeshChildInfo.transform)
}

// -------------------------------------------------------------------

// EntityMeshMasterInfo

// int32 xls_id = 3;
inline void EntityMeshMasterInfo::clear_xls_id() {
  xls_id_ = 0;
}
inline ::google::protobuf::int32 EntityMeshMasterInfo::xls_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshMasterInfo.xls_id)
  return xls_id_;
}
inline void EntityMeshMasterInfo::set_xls_id(::google::protobuf::int32 value) {
  
  xls_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshMasterInfo.xls_id)
}

// int32 player_id = 2;
inline void EntityMeshMasterInfo::clear_player_id() {
  player_id_ = 0;
}
inline ::google::protobuf::int32 EntityMeshMasterInfo::player_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshMasterInfo.player_id)
  return player_id_;
}
inline void EntityMeshMasterInfo::set_player_id(::google::protobuf::int32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshMasterInfo.player_id)
}

// string name = 4;
inline void EntityMeshMasterInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityMeshMasterInfo::name() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshMasterInfo.name)
  return name_.GetNoArena();
}
inline void EntityMeshMasterInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshMasterInfo.name)
}
#if LANG_CXX11
inline void EntityMeshMasterInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityMeshMasterInfo.name)
}
#endif
inline void EntityMeshMasterInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityMeshMasterInfo.name)
}
inline void EntityMeshMasterInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityMeshMasterInfo.name)
}
inline ::std::string* EntityMeshMasterInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMeshMasterInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityMeshMasterInfo::release_name() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMeshMasterInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityMeshMasterInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMeshMasterInfo.name)
}

// string type = 5;
inline void EntityMeshMasterInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityMeshMasterInfo::type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshMasterInfo.type)
  return type_.GetNoArena();
}
inline void EntityMeshMasterInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EntityMeshMasterInfo.type)
}
#if LANG_CXX11
inline void EntityMeshMasterInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EntityMeshMasterInfo.type)
}
#endif
inline void EntityMeshMasterInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EntityMeshMasterInfo.type)
}
inline void EntityMeshMasterInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EntityMeshMasterInfo.type)
}
inline ::std::string* EntityMeshMasterInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMeshMasterInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityMeshMasterInfo::release_type() {
  // @@protoc_insertion_point(field_release:Gamedata.EntityMeshMasterInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityMeshMasterInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EntityMeshMasterInfo.type)
}

// repeated .Gamedata.EntityMeshChildInfo child = 7;
inline int EntityMeshMasterInfo::child_size() const {
  return child_.size();
}
inline void EntityMeshMasterInfo::clear_child() {
  child_.Clear();
}
inline const ::Gamedata::EntityMeshChildInfo& EntityMeshMasterInfo::child(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EntityMeshMasterInfo.child)
  return child_.Get(index);
}
inline ::Gamedata::EntityMeshChildInfo* EntityMeshMasterInfo::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.EntityMeshMasterInfo.child)
  return child_.Mutable(index);
}
inline ::Gamedata::EntityMeshChildInfo* EntityMeshMasterInfo::add_child() {
  // @@protoc_insertion_point(field_add:Gamedata.EntityMeshMasterInfo.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityMeshChildInfo >*
EntityMeshMasterInfo::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EntityMeshMasterInfo.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::EntityMeshChildInfo >&
EntityMeshMasterInfo::child() const {
  // @@protoc_insertion_point(field_list:Gamedata.EntityMeshMasterInfo.child)
  return child_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OverallSituationData

// map<int32, .Gamedata.EntityMeshMasterInfo> actor_list = 1;
inline int OverallSituationData::actor_list_size() const {
  return actor_list_.size();
}
inline void OverallSituationData::clear_actor_list() {
  actor_list_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >&
OverallSituationData::actor_list() const {
  // @@protoc_insertion_point(field_map:Gamedata.OverallSituationData.actor_list)
  return actor_list_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >*
OverallSituationData::mutable_actor_list() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.OverallSituationData.actor_list)
  return actor_list_.MutableMap();
}

// .Gamedata.OverallSituationSkyInfo sky_info = 2;
inline bool OverallSituationData::has_sky_info() const {
  return this != internal_default_instance() && sky_info_ != NULL;
}
inline void OverallSituationData::clear_sky_info() {
  if (GetArenaNoVirtual() == NULL && sky_info_ != NULL) {
    delete sky_info_;
  }
  sky_info_ = NULL;
}
inline const ::Gamedata::OverallSituationSkyInfo& OverallSituationData::sky_info() const {
  const ::Gamedata::OverallSituationSkyInfo* p = sky_info_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationData.sky_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::OverallSituationSkyInfo*>(
      &::Gamedata::_OverallSituationSkyInfo_default_instance_);
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationData::release_sky_info() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationData.sky_info)
  
  ::Gamedata::OverallSituationSkyInfo* temp = sky_info_;
  sky_info_ = NULL;
  return temp;
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationData::mutable_sky_info() {
  
  if (sky_info_ == NULL) {
    sky_info_ = new ::Gamedata::OverallSituationSkyInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationData.sky_info)
  return sky_info_;
}
inline void OverallSituationData::set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sky_info_;
  }
  if (sky_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sky_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sky_info, submessage_arena);
    }
    
  } else {
    
  }
  sky_info_ = sky_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationData.sky_info)
}

// -------------------------------------------------------------------

// OverallSituationDataRequest

// int32 player_id = 1;
inline void OverallSituationDataRequest::clear_player_id() {
  player_id_ = 0;
}
inline ::google::protobuf::int32 OverallSituationDataRequest::player_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.player_id)
  return player_id_;
}
inline void OverallSituationDataRequest::set_player_id(::google::protobuf::int32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationDataRequest.player_id)
}

// .Gamedata.OverallSituationDataType set_type = 2;
inline void OverallSituationDataRequest::clear_set_type() {
  set_type_ = 0;
}
inline ::Gamedata::OverallSituationDataType OverallSituationDataRequest::set_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.set_type)
  return static_cast< ::Gamedata::OverallSituationDataType >(set_type_);
}
inline void OverallSituationDataRequest::set_set_type(::Gamedata::OverallSituationDataType value) {
  
  set_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationDataRequest.set_type)
}

// .Gamedata.OverallSituationSkyInfo sky_info = 4;
inline bool OverallSituationDataRequest::has_sky_info() const {
  return this != internal_default_instance() && sky_info_ != NULL;
}
inline void OverallSituationDataRequest::clear_sky_info() {
  if (GetArenaNoVirtual() == NULL && sky_info_ != NULL) {
    delete sky_info_;
  }
  sky_info_ = NULL;
}
inline const ::Gamedata::OverallSituationSkyInfo& OverallSituationDataRequest::sky_info() const {
  const ::Gamedata::OverallSituationSkyInfo* p = sky_info_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.sky_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::OverallSituationSkyInfo*>(
      &::Gamedata::_OverallSituationSkyInfo_default_instance_);
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationDataRequest::release_sky_info() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataRequest.sky_info)
  
  ::Gamedata::OverallSituationSkyInfo* temp = sky_info_;
  sky_info_ = NULL;
  return temp;
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationDataRequest::mutable_sky_info() {
  
  if (sky_info_ == NULL) {
    sky_info_ = new ::Gamedata::OverallSituationSkyInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataRequest.sky_info)
  return sky_info_;
}
inline void OverallSituationDataRequest::set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sky_info_;
  }
  if (sky_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sky_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sky_info, submessage_arena);
    }
    
  } else {
    
  }
  sky_info_ = sky_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataRequest.sky_info)
}

// .Gamedata.EntityMeshMasterInfo actor_add = 5;
inline bool OverallSituationDataRequest::has_actor_add() const {
  return this != internal_default_instance() && actor_add_ != NULL;
}
inline void OverallSituationDataRequest::clear_actor_add() {
  if (GetArenaNoVirtual() == NULL && actor_add_ != NULL) {
    delete actor_add_;
  }
  actor_add_ = NULL;
}
inline const ::Gamedata::EntityMeshMasterInfo& OverallSituationDataRequest::actor_add() const {
  const ::Gamedata::EntityMeshMasterInfo* p = actor_add_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.actor_add)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityMeshMasterInfo*>(
      &::Gamedata::_EntityMeshMasterInfo_default_instance_);
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataRequest::release_actor_add() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataRequest.actor_add)
  
  ::Gamedata::EntityMeshMasterInfo* temp = actor_add_;
  actor_add_ = NULL;
  return temp;
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataRequest::mutable_actor_add() {
  
  if (actor_add_ == NULL) {
    actor_add_ = new ::Gamedata::EntityMeshMasterInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataRequest.actor_add)
  return actor_add_;
}
inline void OverallSituationDataRequest::set_allocated_actor_add(::Gamedata::EntityMeshMasterInfo* actor_add) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_add_;
  }
  if (actor_add) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_add = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_add, submessage_arena);
    }
    
  } else {
    
  }
  actor_add_ = actor_add;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataRequest.actor_add)
}

// .Gamedata.FTransform actor_add_transform = 6;
inline bool OverallSituationDataRequest::has_actor_add_transform() const {
  return this != internal_default_instance() && actor_add_transform_ != NULL;
}
inline const ::Gamedata::FTransform& OverallSituationDataRequest::actor_add_transform() const {
  const ::Gamedata::FTransform* p = actor_add_transform_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.actor_add_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* OverallSituationDataRequest::release_actor_add_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataRequest.actor_add_transform)
  
  ::Gamedata::FTransform* temp = actor_add_transform_;
  actor_add_transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* OverallSituationDataRequest::mutable_actor_add_transform() {
  
  if (actor_add_transform_ == NULL) {
    actor_add_transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataRequest.actor_add_transform)
  return actor_add_transform_;
}
inline void OverallSituationDataRequest::set_allocated_actor_add_transform(::Gamedata::FTransform* actor_add_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(actor_add_transform_);
  }
  if (actor_add_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_add_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_add_transform, submessage_arena);
    }
    
  } else {
    
  }
  actor_add_transform_ = actor_add_transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataRequest.actor_add_transform)
}

// .Gamedata.EntityMeshMasterInfo actor_update = 7;
inline bool OverallSituationDataRequest::has_actor_update() const {
  return this != internal_default_instance() && actor_update_ != NULL;
}
inline void OverallSituationDataRequest::clear_actor_update() {
  if (GetArenaNoVirtual() == NULL && actor_update_ != NULL) {
    delete actor_update_;
  }
  actor_update_ = NULL;
}
inline const ::Gamedata::EntityMeshMasterInfo& OverallSituationDataRequest::actor_update() const {
  const ::Gamedata::EntityMeshMasterInfo* p = actor_update_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.actor_update)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityMeshMasterInfo*>(
      &::Gamedata::_EntityMeshMasterInfo_default_instance_);
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataRequest::release_actor_update() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataRequest.actor_update)
  
  ::Gamedata::EntityMeshMasterInfo* temp = actor_update_;
  actor_update_ = NULL;
  return temp;
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataRequest::mutable_actor_update() {
  
  if (actor_update_ == NULL) {
    actor_update_ = new ::Gamedata::EntityMeshMasterInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataRequest.actor_update)
  return actor_update_;
}
inline void OverallSituationDataRequest::set_allocated_actor_update(::Gamedata::EntityMeshMasterInfo* actor_update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_update_;
  }
  if (actor_update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_update, submessage_arena);
    }
    
  } else {
    
  }
  actor_update_ = actor_update;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataRequest.actor_update)
}

// .Gamedata.FTransform actor_update_transform = 8;
inline bool OverallSituationDataRequest::has_actor_update_transform() const {
  return this != internal_default_instance() && actor_update_transform_ != NULL;
}
inline const ::Gamedata::FTransform& OverallSituationDataRequest::actor_update_transform() const {
  const ::Gamedata::FTransform* p = actor_update_transform_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.actor_update_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* OverallSituationDataRequest::release_actor_update_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataRequest.actor_update_transform)
  
  ::Gamedata::FTransform* temp = actor_update_transform_;
  actor_update_transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* OverallSituationDataRequest::mutable_actor_update_transform() {
  
  if (actor_update_transform_ == NULL) {
    actor_update_transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataRequest.actor_update_transform)
  return actor_update_transform_;
}
inline void OverallSituationDataRequest::set_allocated_actor_update_transform(::Gamedata::FTransform* actor_update_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(actor_update_transform_);
  }
  if (actor_update_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_update_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_update_transform, submessage_arena);
    }
    
  } else {
    
  }
  actor_update_transform_ = actor_update_transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataRequest.actor_update_transform)
}

// int32 actor_delete = 9;
inline void OverallSituationDataRequest::clear_actor_delete() {
  actor_delete_ = 0;
}
inline ::google::protobuf::int32 OverallSituationDataRequest::actor_delete() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataRequest.actor_delete)
  return actor_delete_;
}
inline void OverallSituationDataRequest::set_actor_delete(::google::protobuf::int32 value) {
  
  actor_delete_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationDataRequest.actor_delete)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OverallSituationDataResponse

// .Gamedata.OverallSituationDataType set_type = 1;
inline void OverallSituationDataResponse::clear_set_type() {
  set_type_ = 0;
}
inline ::Gamedata::OverallSituationDataType OverallSituationDataResponse::set_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.set_type)
  return static_cast< ::Gamedata::OverallSituationDataType >(set_type_);
}
inline void OverallSituationDataResponse::set_set_type(::Gamedata::OverallSituationDataType value) {
  
  set_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationDataResponse.set_type)
}

// .Gamedata.OverallSituationData data = 2;
inline bool OverallSituationDataResponse::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void OverallSituationDataResponse::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::Gamedata::OverallSituationData& OverallSituationDataResponse::data() const {
  const ::Gamedata::OverallSituationData* p = data_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.data)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::OverallSituationData*>(
      &::Gamedata::_OverallSituationData_default_instance_);
}
inline ::Gamedata::OverallSituationData* OverallSituationDataResponse::release_data() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.data)
  
  ::Gamedata::OverallSituationData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::Gamedata::OverallSituationData* OverallSituationDataResponse::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::Gamedata::OverallSituationData;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.data)
  return data_;
}
inline void OverallSituationDataResponse::set_allocated_data(::Gamedata::OverallSituationData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.data)
}

// .Gamedata.OverallSituationSkyInfo sky_info = 4;
inline bool OverallSituationDataResponse::has_sky_info() const {
  return this != internal_default_instance() && sky_info_ != NULL;
}
inline void OverallSituationDataResponse::clear_sky_info() {
  if (GetArenaNoVirtual() == NULL && sky_info_ != NULL) {
    delete sky_info_;
  }
  sky_info_ = NULL;
}
inline const ::Gamedata::OverallSituationSkyInfo& OverallSituationDataResponse::sky_info() const {
  const ::Gamedata::OverallSituationSkyInfo* p = sky_info_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.sky_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::OverallSituationSkyInfo*>(
      &::Gamedata::_OverallSituationSkyInfo_default_instance_);
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationDataResponse::release_sky_info() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.sky_info)
  
  ::Gamedata::OverallSituationSkyInfo* temp = sky_info_;
  sky_info_ = NULL;
  return temp;
}
inline ::Gamedata::OverallSituationSkyInfo* OverallSituationDataResponse::mutable_sky_info() {
  
  if (sky_info_ == NULL) {
    sky_info_ = new ::Gamedata::OverallSituationSkyInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.sky_info)
  return sky_info_;
}
inline void OverallSituationDataResponse::set_allocated_sky_info(::Gamedata::OverallSituationSkyInfo* sky_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sky_info_;
  }
  if (sky_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sky_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sky_info, submessage_arena);
    }
    
  } else {
    
  }
  sky_info_ = sky_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.sky_info)
}

// map<int32, .Gamedata.EntityMeshMasterInfo> actor_list = 5;
inline int OverallSituationDataResponse::actor_list_size() const {
  return actor_list_.size();
}
inline void OverallSituationDataResponse::clear_actor_list() {
  actor_list_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >&
OverallSituationDataResponse::actor_list() const {
  // @@protoc_insertion_point(field_map:Gamedata.OverallSituationDataResponse.actor_list)
  return actor_list_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::EntityMeshMasterInfo >*
OverallSituationDataResponse::mutable_actor_list() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.OverallSituationDataResponse.actor_list)
  return actor_list_.MutableMap();
}

// .Gamedata.EntityMeshMasterInfo actor_add = 6;
inline bool OverallSituationDataResponse::has_actor_add() const {
  return this != internal_default_instance() && actor_add_ != NULL;
}
inline void OverallSituationDataResponse::clear_actor_add() {
  if (GetArenaNoVirtual() == NULL && actor_add_ != NULL) {
    delete actor_add_;
  }
  actor_add_ = NULL;
}
inline const ::Gamedata::EntityMeshMasterInfo& OverallSituationDataResponse::actor_add() const {
  const ::Gamedata::EntityMeshMasterInfo* p = actor_add_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.actor_add)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityMeshMasterInfo*>(
      &::Gamedata::_EntityMeshMasterInfo_default_instance_);
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataResponse::release_actor_add() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.actor_add)
  
  ::Gamedata::EntityMeshMasterInfo* temp = actor_add_;
  actor_add_ = NULL;
  return temp;
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataResponse::mutable_actor_add() {
  
  if (actor_add_ == NULL) {
    actor_add_ = new ::Gamedata::EntityMeshMasterInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.actor_add)
  return actor_add_;
}
inline void OverallSituationDataResponse::set_allocated_actor_add(::Gamedata::EntityMeshMasterInfo* actor_add) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_add_;
  }
  if (actor_add) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_add = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_add, submessage_arena);
    }
    
  } else {
    
  }
  actor_add_ = actor_add;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.actor_add)
}

// .Gamedata.FTransform actor_add_transform = 7;
inline bool OverallSituationDataResponse::has_actor_add_transform() const {
  return this != internal_default_instance() && actor_add_transform_ != NULL;
}
inline const ::Gamedata::FTransform& OverallSituationDataResponse::actor_add_transform() const {
  const ::Gamedata::FTransform* p = actor_add_transform_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.actor_add_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* OverallSituationDataResponse::release_actor_add_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.actor_add_transform)
  
  ::Gamedata::FTransform* temp = actor_add_transform_;
  actor_add_transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* OverallSituationDataResponse::mutable_actor_add_transform() {
  
  if (actor_add_transform_ == NULL) {
    actor_add_transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.actor_add_transform)
  return actor_add_transform_;
}
inline void OverallSituationDataResponse::set_allocated_actor_add_transform(::Gamedata::FTransform* actor_add_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(actor_add_transform_);
  }
  if (actor_add_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_add_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_add_transform, submessage_arena);
    }
    
  } else {
    
  }
  actor_add_transform_ = actor_add_transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.actor_add_transform)
}

// .Gamedata.EntityMeshMasterInfo actor_update = 8;
inline bool OverallSituationDataResponse::has_actor_update() const {
  return this != internal_default_instance() && actor_update_ != NULL;
}
inline void OverallSituationDataResponse::clear_actor_update() {
  if (GetArenaNoVirtual() == NULL && actor_update_ != NULL) {
    delete actor_update_;
  }
  actor_update_ = NULL;
}
inline const ::Gamedata::EntityMeshMasterInfo& OverallSituationDataResponse::actor_update() const {
  const ::Gamedata::EntityMeshMasterInfo* p = actor_update_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.actor_update)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EntityMeshMasterInfo*>(
      &::Gamedata::_EntityMeshMasterInfo_default_instance_);
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataResponse::release_actor_update() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.actor_update)
  
  ::Gamedata::EntityMeshMasterInfo* temp = actor_update_;
  actor_update_ = NULL;
  return temp;
}
inline ::Gamedata::EntityMeshMasterInfo* OverallSituationDataResponse::mutable_actor_update() {
  
  if (actor_update_ == NULL) {
    actor_update_ = new ::Gamedata::EntityMeshMasterInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.actor_update)
  return actor_update_;
}
inline void OverallSituationDataResponse::set_allocated_actor_update(::Gamedata::EntityMeshMasterInfo* actor_update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete actor_update_;
  }
  if (actor_update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_update, submessage_arena);
    }
    
  } else {
    
  }
  actor_update_ = actor_update;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.actor_update)
}

// .Gamedata.FTransform actor_update_transform = 9;
inline bool OverallSituationDataResponse::has_actor_update_transform() const {
  return this != internal_default_instance() && actor_update_transform_ != NULL;
}
inline const ::Gamedata::FTransform& OverallSituationDataResponse::actor_update_transform() const {
  const ::Gamedata::FTransform* p = actor_update_transform_;
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.actor_update_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform*>(
      &::Gamedata::_FTransform_default_instance_);
}
inline ::Gamedata::FTransform* OverallSituationDataResponse::release_actor_update_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.OverallSituationDataResponse.actor_update_transform)
  
  ::Gamedata::FTransform* temp = actor_update_transform_;
  actor_update_transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform* OverallSituationDataResponse::mutable_actor_update_transform() {
  
  if (actor_update_transform_ == NULL) {
    actor_update_transform_ = new ::Gamedata::FTransform;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.OverallSituationDataResponse.actor_update_transform)
  return actor_update_transform_;
}
inline void OverallSituationDataResponse::set_allocated_actor_update_transform(::Gamedata::FTransform* actor_update_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(actor_update_transform_);
  }
  if (actor_update_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      actor_update_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, actor_update_transform, submessage_arena);
    }
    
  } else {
    
  }
  actor_update_transform_ = actor_update_transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.OverallSituationDataResponse.actor_update_transform)
}

// int32 actor_delete = 10;
inline void OverallSituationDataResponse::clear_actor_delete() {
  actor_delete_ = 0;
}
inline ::google::protobuf::int32 OverallSituationDataResponse::actor_delete() const {
  // @@protoc_insertion_point(field_get:Gamedata.OverallSituationDataResponse.actor_delete)
  return actor_delete_;
}
inline void OverallSituationDataResponse::set_actor_delete(::google::protobuf::int32 value) {
  
  actor_delete_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.OverallSituationDataResponse.actor_delete)
}

// -------------------------------------------------------------------

// EventCommandInfo

// string command = 1;
inline void EventCommandInfo::clear_command() {
  command_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventCommandInfo::command() const {
  // @@protoc_insertion_point(field_get:Gamedata.EventCommandInfo.command)
  return command_.GetNoArena();
}
inline void EventCommandInfo::set_command(const ::std::string& value) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.EventCommandInfo.command)
}
#if LANG_CXX11
inline void EventCommandInfo::set_command(::std::string&& value) {
  
  command_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.EventCommandInfo.command)
}
#endif
inline void EventCommandInfo::set_command(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.EventCommandInfo.command)
}
inline void EventCommandInfo::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.EventCommandInfo.command)
}
inline ::std::string* EventCommandInfo::mutable_command() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.EventCommandInfo.command)
  return command_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventCommandInfo::release_command() {
  // @@protoc_insertion_point(field_release:Gamedata.EventCommandInfo.command)
  
  return command_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventCommandInfo::set_allocated_command(::std::string* command) {
  if (command != NULL) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EventCommandInfo.command)
}

// repeated int32 entity_list = 2;
inline int EventCommandInfo::entity_list_size() const {
  return entity_list_.size();
}
inline void EventCommandInfo::clear_entity_list() {
  entity_list_.Clear();
}
inline ::google::protobuf::int32 EventCommandInfo::entity_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EventCommandInfo.entity_list)
  return entity_list_.Get(index);
}
inline void EventCommandInfo::set_entity_list(int index, ::google::protobuf::int32 value) {
  entity_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.EventCommandInfo.entity_list)
}
inline void EventCommandInfo::add_entity_list(::google::protobuf::int32 value) {
  entity_list_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.EventCommandInfo.entity_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EventCommandInfo::entity_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.EventCommandInfo.entity_list)
  return entity_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EventCommandInfo::mutable_entity_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EventCommandInfo.entity_list)
  return &entity_list_;
}

// -------------------------------------------------------------------

// EventInfo

// int32 player_id = 1;
inline void EventInfo::clear_player_id() {
  player_id_ = 0;
}
inline ::google::protobuf::int32 EventInfo::player_id() const {
  // @@protoc_insertion_point(field_get:Gamedata.EventInfo.player_id)
  return player_id_;
}
inline void EventInfo::set_player_id(::google::protobuf::int32 value) {
  
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EventInfo.player_id)
}

// .Gamedata.EventType event_type = 2;
inline void EventInfo::clear_event_type() {
  event_type_ = 0;
}
inline ::Gamedata::EventType EventInfo::event_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EventInfo.event_type)
  return static_cast< ::Gamedata::EventType >(event_type_);
}
inline void EventInfo::set_event_type(::Gamedata::EventType value) {
  
  event_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EventInfo.event_type)
}

// .Gamedata.EventBroadcastRangeType broadcast_range_type = 3;
inline void EventInfo::clear_broadcast_range_type() {
  broadcast_range_type_ = 0;
}
inline ::Gamedata::EventBroadcastRangeType EventInfo::broadcast_range_type() const {
  // @@protoc_insertion_point(field_get:Gamedata.EventInfo.broadcast_range_type)
  return static_cast< ::Gamedata::EventBroadcastRangeType >(broadcast_range_type_);
}
inline void EventInfo::set_broadcast_range_type(::Gamedata::EventBroadcastRangeType value) {
  
  broadcast_range_type_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.EventInfo.broadcast_range_type)
}

// repeated int32 broadcast_player_list = 4;
inline int EventInfo::broadcast_player_list_size() const {
  return broadcast_player_list_.size();
}
inline void EventInfo::clear_broadcast_player_list() {
  broadcast_player_list_.Clear();
}
inline ::google::protobuf::int32 EventInfo::broadcast_player_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.EventInfo.broadcast_player_list)
  return broadcast_player_list_.Get(index);
}
inline void EventInfo::set_broadcast_player_list(int index, ::google::protobuf::int32 value) {
  broadcast_player_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Gamedata.EventInfo.broadcast_player_list)
}
inline void EventInfo::add_broadcast_player_list(::google::protobuf::int32 value) {
  broadcast_player_list_.Add(value);
  // @@protoc_insertion_point(field_add:Gamedata.EventInfo.broadcast_player_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EventInfo::broadcast_player_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.EventInfo.broadcast_player_list)
  return broadcast_player_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EventInfo::mutable_broadcast_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.EventInfo.broadcast_player_list)
  return &broadcast_player_list_;
}

// .Gamedata.EventCommandInfo command_info = 5;
inline bool EventInfo::has_command_info() const {
  return this != internal_default_instance() && command_info_ != NULL;
}
inline void EventInfo::clear_command_info() {
  if (GetArenaNoVirtual() == NULL && command_info_ != NULL) {
    delete command_info_;
  }
  command_info_ = NULL;
}
inline const ::Gamedata::EventCommandInfo& EventInfo::command_info() const {
  const ::Gamedata::EventCommandInfo* p = command_info_;
  // @@protoc_insertion_point(field_get:Gamedata.EventInfo.command_info)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::EventCommandInfo*>(
      &::Gamedata::_EventCommandInfo_default_instance_);
}
inline ::Gamedata::EventCommandInfo* EventInfo::release_command_info() {
  // @@protoc_insertion_point(field_release:Gamedata.EventInfo.command_info)
  
  ::Gamedata::EventCommandInfo* temp = command_info_;
  command_info_ = NULL;
  return temp;
}
inline ::Gamedata::EventCommandInfo* EventInfo::mutable_command_info() {
  
  if (command_info_ == NULL) {
    command_info_ = new ::Gamedata::EventCommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.EventInfo.command_info)
  return command_info_;
}
inline void EventInfo::set_allocated_command_info(::Gamedata::EventCommandInfo* command_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_info_;
  }
  if (command_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command_info, submessage_arena);
    }
    
  } else {
    
  }
  command_info_ = command_info;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.EventInfo.command_info)
}

// -------------------------------------------------------------------

// TimelineOneFrameOneEntityData

// .Gamedata.FTransform_s collision_transform = 1;
inline bool TimelineOneFrameOneEntityData::has_collision_transform() const {
  return this != internal_default_instance() && collision_transform_ != NULL;
}
inline const ::Gamedata::FTransform_s& TimelineOneFrameOneEntityData::collision_transform() const {
  const ::Gamedata::FTransform_s* p = collision_transform_;
  // @@protoc_insertion_point(field_get:Gamedata.TimelineOneFrameOneEntityData.collision_transform)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FTransform_s*>(
      &::Gamedata::_FTransform_s_default_instance_);
}
inline ::Gamedata::FTransform_s* TimelineOneFrameOneEntityData::release_collision_transform() {
  // @@protoc_insertion_point(field_release:Gamedata.TimelineOneFrameOneEntityData.collision_transform)
  
  ::Gamedata::FTransform_s* temp = collision_transform_;
  collision_transform_ = NULL;
  return temp;
}
inline ::Gamedata::FTransform_s* TimelineOneFrameOneEntityData::mutable_collision_transform() {
  
  if (collision_transform_ == NULL) {
    collision_transform_ = new ::Gamedata::FTransform_s;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.TimelineOneFrameOneEntityData.collision_transform)
  return collision_transform_;
}
inline void TimelineOneFrameOneEntityData::set_allocated_collision_transform(::Gamedata::FTransform_s* collision_transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(collision_transform_);
  }
  if (collision_transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      collision_transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, collision_transform, submessage_arena);
    }
    
  } else {
    
  }
  collision_transform_ = collision_transform;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.TimelineOneFrameOneEntityData.collision_transform)
}

// repeated .Gamedata.FTransform_s child_transform = 2;
inline int TimelineOneFrameOneEntityData::child_transform_size() const {
  return child_transform_.size();
}
inline const ::Gamedata::FTransform_s& TimelineOneFrameOneEntityData::child_transform(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.TimelineOneFrameOneEntityData.child_transform)
  return child_transform_.Get(index);
}
inline ::Gamedata::FTransform_s* TimelineOneFrameOneEntityData::mutable_child_transform(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.TimelineOneFrameOneEntityData.child_transform)
  return child_transform_.Mutable(index);
}
inline ::Gamedata::FTransform_s* TimelineOneFrameOneEntityData::add_child_transform() {
  // @@protoc_insertion_point(field_add:Gamedata.TimelineOneFrameOneEntityData.child_transform)
  return child_transform_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::FTransform_s >*
TimelineOneFrameOneEntityData::mutable_child_transform() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.TimelineOneFrameOneEntityData.child_transform)
  return &child_transform_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::FTransform_s >&
TimelineOneFrameOneEntityData::child_transform() const {
  // @@protoc_insertion_point(field_list:Gamedata.TimelineOneFrameOneEntityData.child_transform)
  return child_transform_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TimelineOnewFrameAllEntityData

// map<int32, .Gamedata.TimelineOneFrameOneEntityData> entity_transform_map = 2;
inline int TimelineOnewFrameAllEntityData::entity_transform_map_size() const {
  return entity_transform_map_.size();
}
inline void TimelineOnewFrameAllEntityData::clear_entity_transform_map() {
  entity_transform_map_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData >&
TimelineOnewFrameAllEntityData::entity_transform_map() const {
  // @@protoc_insertion_point(field_map:Gamedata.TimelineOnewFrameAllEntityData.entity_transform_map)
  return entity_transform_map_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::Gamedata::TimelineOneFrameOneEntityData >*
TimelineOnewFrameAllEntityData::mutable_entity_transform_map() {
  // @@protoc_insertion_point(field_mutable_map:Gamedata.TimelineOnewFrameAllEntityData.entity_transform_map)
  return entity_transform_map_.MutableMap();
}

// -------------------------------------------------------------------

// TimelineOneSecondAllFrameData

// int32 time = 1;
inline void TimelineOneSecondAllFrameData::clear_time() {
  time_ = 0;
}
inline ::google::protobuf::int32 TimelineOneSecondAllFrameData::time() const {
  // @@protoc_insertion_point(field_get:Gamedata.TimelineOneSecondAllFrameData.time)
  return time_;
}
inline void TimelineOneSecondAllFrameData::set_time(::google::protobuf::int32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.TimelineOneSecondAllFrameData.time)
}

// repeated .Gamedata.TimelineOnewFrameAllEntityData frame_list = 2;
inline int TimelineOneSecondAllFrameData::frame_list_size() const {
  return frame_list_.size();
}
inline void TimelineOneSecondAllFrameData::clear_frame_list() {
  frame_list_.Clear();
}
inline const ::Gamedata::TimelineOnewFrameAllEntityData& TimelineOneSecondAllFrameData::frame_list(int index) const {
  // @@protoc_insertion_point(field_get:Gamedata.TimelineOneSecondAllFrameData.frame_list)
  return frame_list_.Get(index);
}
inline ::Gamedata::TimelineOnewFrameAllEntityData* TimelineOneSecondAllFrameData::mutable_frame_list(int index) {
  // @@protoc_insertion_point(field_mutable:Gamedata.TimelineOneSecondAllFrameData.frame_list)
  return frame_list_.Mutable(index);
}
inline ::Gamedata::TimelineOnewFrameAllEntityData* TimelineOneSecondAllFrameData::add_frame_list() {
  // @@protoc_insertion_point(field_add:Gamedata.TimelineOneSecondAllFrameData.frame_list)
  return frame_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Gamedata::TimelineOnewFrameAllEntityData >*
TimelineOneSecondAllFrameData::mutable_frame_list() {
  // @@protoc_insertion_point(field_mutable_list:Gamedata.TimelineOneSecondAllFrameData.frame_list)
  return &frame_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Gamedata::TimelineOnewFrameAllEntityData >&
TimelineOneSecondAllFrameData::frame_list() const {
  // @@protoc_insertion_point(field_list:Gamedata.TimelineOneSecondAllFrameData.frame_list)
  return frame_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Gamedata

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Gamedata::GameMainOperationMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::GameMainOperationMode>() {
  return ::Gamedata::GameMainOperationMode_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::CharacterMovementModeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::CharacterMovementModeType>() {
  return ::Gamedata::CharacterMovementModeType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::CharacterActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::CharacterActionType>() {
  return ::Gamedata::CharacterActionType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityTimeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityTimeType>() {
  return ::Gamedata::EntityTimeType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityMoveTimelineEndOfPlay> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityMoveTimelineEndOfPlay>() {
  return ::Gamedata::EntityMoveTimelineEndOfPlay_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityPythonErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityPythonErrorType>() {
  return ::Gamedata::EntityPythonErrorType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityCommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityCommandType>() {
  return ::Gamedata::EntityCommandType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::TimelineHighlightType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::TimelineHighlightType>() {
  return ::Gamedata::TimelineHighlightType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityCollisionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityCollisionType>() {
  return ::Gamedata::EntityCollisionType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntitySyncType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntitySyncType>() {
  return ::Gamedata::EntitySyncType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EntityOperationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EntityOperationType>() {
  return ::Gamedata::EntityOperationType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::OverallSituationDataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::OverallSituationDataType>() {
  return ::Gamedata::OverallSituationDataType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EventType>() {
  return ::Gamedata::EventType_descriptor();
}
template <> struct is_proto_enum< ::Gamedata::EventBroadcastRangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::EventBroadcastRangeType>() {
  return ::Gamedata::EventBroadcastRangeType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hall.proto

#ifndef PROTOBUF_hall_2eproto__INCLUDED
#define PROTOBUF_hall_2eproto__INCLUDED

#pragma warning(disable:4456)
#pragma warning(disable:4146)
#pragma warning(disable:4647)
#pragma warning(disable:4668)
#pragma warning(disable:4125)
#pragma warning(disable:4800)
#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "the_public.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_hall_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlayerLoginRequestImpl();
void InitDefaultsPlayerLoginRequest();
void InitDefaultsPlayerLoginResponseImpl();
void InitDefaultsPlayerLoginResponse();
void InitDefaultsPlayerLogoutRequestImpl();
void InitDefaultsPlayerLogoutRequest();
void InitDefaultsPlayerLogoutResponseImpl();
void InitDefaultsPlayerLogoutResponse();
void InitDefaultsCreateRoomRequestImpl();
void InitDefaultsCreateRoomRequest();
void InitDefaultsCreateRoomResponseImpl();
void InitDefaultsCreateRoomResponse();
void InitDefaultsJoinRoomRequestImpl();
void InitDefaultsJoinRoomRequest();
void InitDefaultsJoinRoomResponseImpl();
void InitDefaultsJoinRoomResponse();
void InitDefaultsJoinMapRequestImpl();
void InitDefaultsJoinMapRequest();
void InitDefaultsJoinMapResponseImpl();
void InitDefaultsJoinMapResponse();
void InitDefaultsLeavelRoomRequestImpl();
void InitDefaultsLeavelRoomRequest();
void InitDefaultsLeavelRoomResponseImpl();
void InitDefaultsLeavelRoomResponse();
inline void InitDefaults() {
  InitDefaultsPlayerLoginRequest();
  InitDefaultsPlayerLoginResponse();
  InitDefaultsPlayerLogoutRequest();
  InitDefaultsPlayerLogoutResponse();
  InitDefaultsCreateRoomRequest();
  InitDefaultsCreateRoomResponse();
  InitDefaultsJoinRoomRequest();
  InitDefaultsJoinRoomResponse();
  InitDefaultsJoinMapRequest();
  InitDefaultsJoinMapResponse();
  InitDefaultsLeavelRoomRequest();
  InitDefaultsLeavelRoomResponse();
}
}  // namespace protobuf_hall_2eproto
namespace Gamedata {
class CreateRoomRequest;
class CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
class CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class JoinMapRequest;
class JoinMapRequestDefaultTypeInternal;
extern JoinMapRequestDefaultTypeInternal _JoinMapRequest_default_instance_;
class JoinMapResponse;
class JoinMapResponseDefaultTypeInternal;
extern JoinMapResponseDefaultTypeInternal _JoinMapResponse_default_instance_;
class JoinRoomRequest;
class JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
class JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class LeavelRoomRequest;
class LeavelRoomRequestDefaultTypeInternal;
extern LeavelRoomRequestDefaultTypeInternal _LeavelRoomRequest_default_instance_;
class LeavelRoomResponse;
class LeavelRoomResponseDefaultTypeInternal;
extern LeavelRoomResponseDefaultTypeInternal _LeavelRoomResponse_default_instance_;
class PlayerLoginRequest;
class PlayerLoginRequestDefaultTypeInternal;
extern PlayerLoginRequestDefaultTypeInternal _PlayerLoginRequest_default_instance_;
class PlayerLoginResponse;
class PlayerLoginResponseDefaultTypeInternal;
extern PlayerLoginResponseDefaultTypeInternal _PlayerLoginResponse_default_instance_;
class PlayerLogoutRequest;
class PlayerLogoutRequestDefaultTypeInternal;
extern PlayerLogoutRequestDefaultTypeInternal _PlayerLogoutRequest_default_instance_;
class PlayerLogoutResponse;
class PlayerLogoutResponseDefaultTypeInternal;
extern PlayerLogoutResponseDefaultTypeInternal _PlayerLogoutResponse_default_instance_;
}  // namespace Gamedata
namespace Gamedata {

enum ReturnCode {
  PB_Successful = 0,
  PB_Failed = 1,
  PB_Error = 2,
  ReturnCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReturnCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReturnCode_IsValid(int value);
const ReturnCode ReturnCode_MIN = PB_Successful;
const ReturnCode ReturnCode_MAX = PB_Error;
const int ReturnCode_ARRAYSIZE = ReturnCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReturnCode_descriptor();
inline const ::std::string& ReturnCode_Name(ReturnCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReturnCode_descriptor(), value);
}
inline bool ReturnCode_Parse(
    const ::std::string& name, ReturnCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReturnCode>(
    ReturnCode_descriptor(), name, value);
}
// ===================================================================

class PlayerLoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLoginRequest) */ {
 public:
  PlayerLoginRequest();
  virtual ~PlayerLoginRequest();

  PlayerLoginRequest(const PlayerLoginRequest& from);

  inline PlayerLoginRequest& operator=(const PlayerLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLoginRequest(PlayerLoginRequest&& from) noexcept
    : PlayerLoginRequest() {
    *this = ::std::move(from);
  }

  inline PlayerLoginRequest& operator=(PlayerLoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLoginRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerLoginRequest*>(
               &_PlayerLoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlayerLoginRequest* other);
  friend void swap(PlayerLoginRequest& a, PlayerLoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLoginRequest& from);
  void MergeFrom(const PlayerLoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsPlayerLoginRequestImpl();
};
// -------------------------------------------------------------------

class PlayerLoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLoginResponse) */ {
 public:
  PlayerLoginResponse();
  virtual ~PlayerLoginResponse();

  PlayerLoginResponse(const PlayerLoginResponse& from);

  inline PlayerLoginResponse& operator=(const PlayerLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLoginResponse(PlayerLoginResponse&& from) noexcept
    : PlayerLoginResponse() {
    *this = ::std::move(from);
  }

  inline PlayerLoginResponse& operator=(PlayerLoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLoginResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerLoginResponse*>(
               &_PlayerLoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PlayerLoginResponse* other);
  friend void swap(PlayerLoginResponse& a, PlayerLoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLoginResponse& from);
  void MergeFrom(const PlayerLoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // int32 playerId = 3;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 3;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsPlayerLoginResponseImpl();
};
// -------------------------------------------------------------------

class PlayerLogoutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLogoutRequest) */ {
 public:
  PlayerLogoutRequest();
  virtual ~PlayerLogoutRequest();

  PlayerLogoutRequest(const PlayerLogoutRequest& from);

  inline PlayerLogoutRequest& operator=(const PlayerLogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLogoutRequest(PlayerLogoutRequest&& from) noexcept
    : PlayerLogoutRequest() {
    *this = ::std::move(from);
  }

  inline PlayerLogoutRequest& operator=(PlayerLogoutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLogoutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLogoutRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerLogoutRequest*>(
               &_PlayerLogoutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PlayerLogoutRequest* other);
  friend void swap(PlayerLogoutRequest& a, PlayerLogoutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLogoutRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLogoutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLogoutRequest& from);
  void MergeFrom(const PlayerLogoutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLogoutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 playerId = 1;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLogoutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsPlayerLogoutRequestImpl();
};
// -------------------------------------------------------------------

class PlayerLogoutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.PlayerLogoutResponse) */ {
 public:
  PlayerLogoutResponse();
  virtual ~PlayerLogoutResponse();

  PlayerLogoutResponse(const PlayerLogoutResponse& from);

  inline PlayerLogoutResponse& operator=(const PlayerLogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLogoutResponse(PlayerLogoutResponse&& from) noexcept
    : PlayerLogoutResponse() {
    *this = ::std::move(from);
  }

  inline PlayerLogoutResponse& operator=(PlayerLogoutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLogoutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLogoutResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerLogoutResponse*>(
               &_PlayerLogoutResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PlayerLogoutResponse* other);
  friend void swap(PlayerLogoutResponse& a, PlayerLogoutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLogoutResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerLogoutResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLogoutResponse& from);
  void MergeFrom(const PlayerLogoutResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLogoutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // @@protoc_insertion_point(class_scope:Gamedata.PlayerLogoutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsPlayerLogoutResponseImpl();
};
// -------------------------------------------------------------------

class CreateRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.CreateRoomRequest) */ {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CreateRoomRequest* other);
  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string roomName = 1;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // string mapName = 2;
  void clear_mapname();
  static const int kMapNameFieldNumber = 2;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  #if LANG_CXX11
  void set_mapname(::std::string&& value);
  #endif
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Gamedata.CreateRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsCreateRoomRequestImpl();
};
// -------------------------------------------------------------------

class CreateRoomResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.CreateRoomResponse) */ {
 public:
  CreateRoomResponse();
  virtual ~CreateRoomResponse();

  CreateRoomResponse(const CreateRoomResponse& from);

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CreateRoomResponse* other);
  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoomResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomResponse& from);
  void MergeFrom(const CreateRoomResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // @@protoc_insertion_point(class_scope:Gamedata.CreateRoomResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsCreateRoomResponseImpl();
};
// -------------------------------------------------------------------

class JoinRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.JoinRoomRequest) */ {
 public:
  JoinRoomRequest();
  virtual ~JoinRoomRequest();

  JoinRoomRequest(const JoinRoomRequest& from);

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(JoinRoomRequest* other);
  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomRequest& from);
  void MergeFrom(const JoinRoomRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomId = 1;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.JoinRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsJoinRoomRequestImpl();
};
// -------------------------------------------------------------------

class JoinRoomResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.JoinRoomResponse) */ {
 public:
  JoinRoomResponse();
  virtual ~JoinRoomResponse();

  JoinRoomResponse(const JoinRoomResponse& from);

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(JoinRoomResponse* other);
  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoomResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinRoomResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinRoomResponse& from);
  void MergeFrom(const JoinRoomResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinRoomResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // @@protoc_insertion_point(class_scope:Gamedata.JoinRoomResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsJoinRoomResponseImpl();
};
// -------------------------------------------------------------------

class JoinMapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.JoinMapRequest) */ {
 public:
  JoinMapRequest();
  virtual ~JoinMapRequest();

  JoinMapRequest(const JoinMapRequest& from);

  inline JoinMapRequest& operator=(const JoinMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinMapRequest(JoinMapRequest&& from) noexcept
    : JoinMapRequest() {
    *this = ::std::move(from);
  }

  inline JoinMapRequest& operator=(JoinMapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinMapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinMapRequest* internal_default_instance() {
    return reinterpret_cast<const JoinMapRequest*>(
               &_JoinMapRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(JoinMapRequest* other);
  friend void swap(JoinMapRequest& a, JoinMapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinMapRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinMapRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinMapRequest& from);
  void MergeFrom(const JoinMapRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinMapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomId = 1;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.JoinMapRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsJoinMapRequestImpl();
};
// -------------------------------------------------------------------

class JoinMapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.JoinMapResponse) */ {
 public:
  JoinMapResponse();
  virtual ~JoinMapResponse();

  JoinMapResponse(const JoinMapResponse& from);

  inline JoinMapResponse& operator=(const JoinMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinMapResponse(JoinMapResponse&& from) noexcept
    : JoinMapResponse() {
    *this = ::std::move(from);
  }

  inline JoinMapResponse& operator=(JoinMapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinMapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinMapResponse* internal_default_instance() {
    return reinterpret_cast<const JoinMapResponse*>(
               &_JoinMapResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(JoinMapResponse* other);
  friend void swap(JoinMapResponse& a, JoinMapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinMapResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinMapResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinMapResponse& from);
  void MergeFrom(const JoinMapResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinMapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // @@protoc_insertion_point(class_scope:Gamedata.JoinMapResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsJoinMapResponseImpl();
};
// -------------------------------------------------------------------

class LeavelRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.LeavelRoomRequest) */ {
 public:
  LeavelRoomRequest();
  virtual ~LeavelRoomRequest();

  LeavelRoomRequest(const LeavelRoomRequest& from);

  inline LeavelRoomRequest& operator=(const LeavelRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeavelRoomRequest(LeavelRoomRequest&& from) noexcept
    : LeavelRoomRequest() {
    *this = ::std::move(from);
  }

  inline LeavelRoomRequest& operator=(LeavelRoomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeavelRoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeavelRoomRequest* internal_default_instance() {
    return reinterpret_cast<const LeavelRoomRequest*>(
               &_LeavelRoomRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LeavelRoomRequest* other);
  friend void swap(LeavelRoomRequest& a, LeavelRoomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeavelRoomRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LeavelRoomRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeavelRoomRequest& from);
  void MergeFrom(const LeavelRoomRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeavelRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 roomId = 1;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // int32 playerId = 2;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Gamedata.LeavelRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 playerid_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsLeavelRoomRequestImpl();
};
// -------------------------------------------------------------------

class LeavelRoomResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.LeavelRoomResponse) */ {
 public:
  LeavelRoomResponse();
  virtual ~LeavelRoomResponse();

  LeavelRoomResponse(const LeavelRoomResponse& from);

  inline LeavelRoomResponse& operator=(const LeavelRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeavelRoomResponse(LeavelRoomResponse&& from) noexcept
    : LeavelRoomResponse() {
    *this = ::std::move(from);
  }

  inline LeavelRoomResponse& operator=(LeavelRoomResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeavelRoomResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeavelRoomResponse* internal_default_instance() {
    return reinterpret_cast<const LeavelRoomResponse*>(
               &_LeavelRoomResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(LeavelRoomResponse* other);
  friend void swap(LeavelRoomResponse& a, LeavelRoomResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeavelRoomResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LeavelRoomResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeavelRoomResponse& from);
  void MergeFrom(const LeavelRoomResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeavelRoomResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // .Gamedata.ReturnCode code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::Gamedata::ReturnCode code() const;
  void set_code(::Gamedata::ReturnCode value);

  // @@protoc_insertion_point(class_scope:Gamedata.LeavelRoomResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int code_;
  mutable int _cached_size_;
  friend struct ::protobuf_hall_2eproto::TableStruct;
  friend void ::protobuf_hall_2eproto::InitDefaultsLeavelRoomResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerLoginRequest

// string account = 1;
inline void PlayerLoginRequest::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLoginRequest::account() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLoginRequest.account)
  return account_.GetNoArena();
}
inline void PlayerLoginRequest::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLoginRequest.account)
}
#if LANG_CXX11
inline void PlayerLoginRequest::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.PlayerLoginRequest.account)
}
#endif
inline void PlayerLoginRequest::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerLoginRequest.account)
}
inline void PlayerLoginRequest::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerLoginRequest.account)
}
inline ::std::string* PlayerLoginRequest::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLoginRequest.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLoginRequest::release_account() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLoginRequest.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLoginRequest::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLoginRequest.account)
}

// string password = 2;
inline void PlayerLoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLoginRequest::password() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLoginRequest.password)
  return password_.GetNoArena();
}
inline void PlayerLoginRequest::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLoginRequest.password)
}
#if LANG_CXX11
inline void PlayerLoginRequest::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.PlayerLoginRequest.password)
}
#endif
inline void PlayerLoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerLoginRequest.password)
}
inline void PlayerLoginRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerLoginRequest.password)
}
inline ::std::string* PlayerLoginRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLoginRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLoginRequest.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLoginRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLoginRequest.password)
}

// -------------------------------------------------------------------

// PlayerLoginResponse

// .Gamedata.ReturnCode code = 1;
inline void PlayerLoginResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode PlayerLoginResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLoginResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void PlayerLoginResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLoginResponse.code)
}

// string msg = 2;
inline void PlayerLoginResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLoginResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLoginResponse.msg)
  return msg_.GetNoArena();
}
inline void PlayerLoginResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLoginResponse.msg)
}
#if LANG_CXX11
inline void PlayerLoginResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.PlayerLoginResponse.msg)
}
#endif
inline void PlayerLoginResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerLoginResponse.msg)
}
inline void PlayerLoginResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerLoginResponse.msg)
}
inline ::std::string* PlayerLoginResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLoginResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLoginResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLoginResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLoginResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLoginResponse.msg)
}

// int32 playerId = 3;
inline void PlayerLoginResponse::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 PlayerLoginResponse::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLoginResponse.playerId)
  return playerid_;
}
inline void PlayerLoginResponse::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLoginResponse.playerId)
}

// -------------------------------------------------------------------

// PlayerLogoutRequest

// int32 playerId = 1;
inline void PlayerLogoutRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 PlayerLogoutRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLogoutRequest.playerId)
  return playerid_;
}
inline void PlayerLogoutRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLogoutRequest.playerId)
}

// -------------------------------------------------------------------

// PlayerLogoutResponse

// .Gamedata.ReturnCode code = 1;
inline void PlayerLogoutResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode PlayerLogoutResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLogoutResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void PlayerLogoutResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLogoutResponse.code)
}

// string msg = 2;
inline void PlayerLogoutResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLogoutResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.PlayerLogoutResponse.msg)
  return msg_.GetNoArena();
}
inline void PlayerLogoutResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.PlayerLogoutResponse.msg)
}
#if LANG_CXX11
inline void PlayerLogoutResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.PlayerLogoutResponse.msg)
}
#endif
inline void PlayerLogoutResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.PlayerLogoutResponse.msg)
}
inline void PlayerLogoutResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.PlayerLogoutResponse.msg)
}
inline ::std::string* PlayerLogoutResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.PlayerLogoutResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLogoutResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.PlayerLogoutResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLogoutResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.PlayerLogoutResponse.msg)
}

// -------------------------------------------------------------------

// CreateRoomRequest

// string roomName = 1;
inline void CreateRoomRequest::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoomRequest::roomname() const {
  // @@protoc_insertion_point(field_get:Gamedata.CreateRoomRequest.roomName)
  return roomname_.GetNoArena();
}
inline void CreateRoomRequest::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.CreateRoomRequest.roomName)
}
#if LANG_CXX11
inline void CreateRoomRequest::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.CreateRoomRequest.roomName)
}
#endif
inline void CreateRoomRequest::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.CreateRoomRequest.roomName)
}
inline void CreateRoomRequest::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.CreateRoomRequest.roomName)
}
inline ::std::string* CreateRoomRequest::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.CreateRoomRequest.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomRequest::release_roomname() {
  // @@protoc_insertion_point(field_release:Gamedata.CreateRoomRequest.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.CreateRoomRequest.roomName)
}

// string mapName = 2;
inline void CreateRoomRequest::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoomRequest::mapname() const {
  // @@protoc_insertion_point(field_get:Gamedata.CreateRoomRequest.mapName)
  return mapname_.GetNoArena();
}
inline void CreateRoomRequest::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.CreateRoomRequest.mapName)
}
#if LANG_CXX11
inline void CreateRoomRequest::set_mapname(::std::string&& value) {
  
  mapname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.CreateRoomRequest.mapName)
}
#endif
inline void CreateRoomRequest::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.CreateRoomRequest.mapName)
}
inline void CreateRoomRequest::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.CreateRoomRequest.mapName)
}
inline ::std::string* CreateRoomRequest::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.CreateRoomRequest.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomRequest::release_mapname() {
  // @@protoc_insertion_point(field_release:Gamedata.CreateRoomRequest.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.CreateRoomRequest.mapName)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// .Gamedata.ReturnCode code = 1;
inline void CreateRoomResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode CreateRoomResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.CreateRoomResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void CreateRoomResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.CreateRoomResponse.code)
}

// string msg = 2;
inline void CreateRoomResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateRoomResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.CreateRoomResponse.msg)
  return msg_.GetNoArena();
}
inline void CreateRoomResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.CreateRoomResponse.msg)
}
#if LANG_CXX11
inline void CreateRoomResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.CreateRoomResponse.msg)
}
#endif
inline void CreateRoomResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.CreateRoomResponse.msg)
}
inline void CreateRoomResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.CreateRoomResponse.msg)
}
inline ::std::string* CreateRoomResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.CreateRoomResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.CreateRoomResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.CreateRoomResponse.msg)
}

// -------------------------------------------------------------------

// JoinRoomRequest

// int32 roomId = 1;
inline void JoinRoomRequest::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 JoinRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinRoomRequest.roomId)
  return roomid_;
}
inline void JoinRoomRequest::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinRoomRequest.roomId)
}

// int32 playerId = 2;
inline void JoinRoomRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 JoinRoomRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinRoomRequest.playerId)
  return playerid_;
}
inline void JoinRoomRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinRoomRequest.playerId)
}

// -------------------------------------------------------------------

// JoinRoomResponse

// .Gamedata.ReturnCode code = 1;
inline void JoinRoomResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode JoinRoomResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinRoomResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void JoinRoomResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinRoomResponse.code)
}

// string msg = 2;
inline void JoinRoomResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinRoomResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinRoomResponse.msg)
  return msg_.GetNoArena();
}
inline void JoinRoomResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.JoinRoomResponse.msg)
}
#if LANG_CXX11
inline void JoinRoomResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.JoinRoomResponse.msg)
}
#endif
inline void JoinRoomResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.JoinRoomResponse.msg)
}
inline void JoinRoomResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.JoinRoomResponse.msg)
}
inline ::std::string* JoinRoomResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.JoinRoomResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinRoomResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.JoinRoomResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinRoomResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.JoinRoomResponse.msg)
}

// -------------------------------------------------------------------

// JoinMapRequest

// int32 roomId = 1;
inline void JoinMapRequest::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 JoinMapRequest::roomid() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinMapRequest.roomId)
  return roomid_;
}
inline void JoinMapRequest::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinMapRequest.roomId)
}

// int32 playerId = 2;
inline void JoinMapRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 JoinMapRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinMapRequest.playerId)
  return playerid_;
}
inline void JoinMapRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinMapRequest.playerId)
}

// -------------------------------------------------------------------

// JoinMapResponse

// .Gamedata.ReturnCode code = 1;
inline void JoinMapResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode JoinMapResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinMapResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void JoinMapResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.JoinMapResponse.code)
}

// string msg = 2;
inline void JoinMapResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMapResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.JoinMapResponse.msg)
  return msg_.GetNoArena();
}
inline void JoinMapResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.JoinMapResponse.msg)
}
#if LANG_CXX11
inline void JoinMapResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.JoinMapResponse.msg)
}
#endif
inline void JoinMapResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.JoinMapResponse.msg)
}
inline void JoinMapResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.JoinMapResponse.msg)
}
inline ::std::string* JoinMapResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.JoinMapResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMapResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.JoinMapResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMapResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.JoinMapResponse.msg)
}

// -------------------------------------------------------------------

// LeavelRoomRequest

// int32 roomId = 1;
inline void LeavelRoomRequest::clear_roomid() {
  roomid_ = 0;
}
inline ::google::protobuf::int32 LeavelRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:Gamedata.LeavelRoomRequest.roomId)
  return roomid_;
}
inline void LeavelRoomRequest::set_roomid(::google::protobuf::int32 value) {
  
  roomid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.LeavelRoomRequest.roomId)
}

// int32 playerId = 2;
inline void LeavelRoomRequest::clear_playerid() {
  playerid_ = 0;
}
inline ::google::protobuf::int32 LeavelRoomRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Gamedata.LeavelRoomRequest.playerId)
  return playerid_;
}
inline void LeavelRoomRequest::set_playerid(::google::protobuf::int32 value) {
  
  playerid_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.LeavelRoomRequest.playerId)
}

// -------------------------------------------------------------------

// LeavelRoomResponse

// .Gamedata.ReturnCode code = 1;
inline void LeavelRoomResponse::clear_code() {
  code_ = 0;
}
inline ::Gamedata::ReturnCode LeavelRoomResponse::code() const {
  // @@protoc_insertion_point(field_get:Gamedata.LeavelRoomResponse.code)
  return static_cast< ::Gamedata::ReturnCode >(code_);
}
inline void LeavelRoomResponse::set_code(::Gamedata::ReturnCode value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.LeavelRoomResponse.code)
}

// string msg = 2;
inline void LeavelRoomResponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeavelRoomResponse::msg() const {
  // @@protoc_insertion_point(field_get:Gamedata.LeavelRoomResponse.msg)
  return msg_.GetNoArena();
}
inline void LeavelRoomResponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Gamedata.LeavelRoomResponse.msg)
}
#if LANG_CXX11
inline void LeavelRoomResponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Gamedata.LeavelRoomResponse.msg)
}
#endif
inline void LeavelRoomResponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Gamedata.LeavelRoomResponse.msg)
}
inline void LeavelRoomResponse::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Gamedata.LeavelRoomResponse.msg)
}
inline ::std::string* LeavelRoomResponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Gamedata.LeavelRoomResponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeavelRoomResponse::release_msg() {
  // @@protoc_insertion_point(field_release:Gamedata.LeavelRoomResponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeavelRoomResponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Gamedata.LeavelRoomResponse.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Gamedata

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Gamedata::ReturnCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::ReturnCode>() {
  return ::Gamedata::ReturnCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hall_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: the_public.proto

#ifndef PROTOBUF_the_5fpublic_2eproto__INCLUDED
#define PROTOBUF_the_5fpublic_2eproto__INCLUDED

#pragma warning(disable:4456)
#pragma warning(disable:4146)
#pragma warning(disable:4647)
#pragma warning(disable:4668)
#pragma warning(disable:4125)
#pragma warning(disable:4800)
#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_the_5fpublic_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFVectorImpl();
void InitDefaultsFVector();
void InitDefaultsFRotatorImpl();
void InitDefaultsFRotator();
void InitDefaultsFTransform_sImpl();
void InitDefaultsFTransform_s();
void InitDefaultsFTransformImpl();
void InitDefaultsFTransform();
inline void InitDefaults() {
  InitDefaultsFVector();
  InitDefaultsFRotator();
  InitDefaultsFTransform_s();
  InitDefaultsFTransform();
}
}  // namespace protobuf_the_5fpublic_2eproto
namespace Gamedata {
class FRotator;
class FRotatorDefaultTypeInternal;
extern FRotatorDefaultTypeInternal _FRotator_default_instance_;
class FTransform;
class FTransformDefaultTypeInternal;
extern FTransformDefaultTypeInternal _FTransform_default_instance_;
class FTransform_s;
class FTransform_sDefaultTypeInternal;
extern FTransform_sDefaultTypeInternal _FTransform_s_default_instance_;
class FVector;
class FVectorDefaultTypeInternal;
extern FVectorDefaultTypeInternal _FVector_default_instance_;
}  // namespace Gamedata
namespace Gamedata {

enum MsgType {
  PB_None = 0,
  PB_Hall_Login = 1000,
  PB_Hall_Logout = 101,
  PB_Hall_JoinRoom = 102,
  PB_Hall_LeaveRoom = 103,
  PB_Hall_JoinMap = 104,
  BP_OverallSituationData_EnterView = 401,
  BP_OverallSituationData_Change = 402,
  PB_PlayerEnterView = 203,
  PB_PlayerUpdateView = 202,
  PB_PlayerLeaveView = 204,
  PB_PlayerUpdateLocation = 205,
  PB_PlayerMoveRequest = 255,
  PB_PlayerJiugonggeRequest = 256,
  PB_PlayerUpdateRequest = 257,
  PB_EntityEnterView = 302,
  PB_EntityUpdateView = 303,
  PB_EntityLeaveView = 304,
  PB_EntityOperation = 309,
  PB_EntityAddRequest = 305,
  PB_EntityRemoveRequest = 306,
  PB_EntityUpdateRequest = 307,
  PB_EntityJiugonggeRequest = 308,
  PB_EventInfo = 501,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = PB_None;
const MsgType MsgType_MAX = PB_Hall_Login;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class FVector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.FVector) */ {
 public:
  FVector();
  virtual ~FVector();

  FVector(const FVector& from);

  inline FVector& operator=(const FVector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FVector(FVector&& from) noexcept
    : FVector() {
    *this = ::std::move(from);
  }

  inline FVector& operator=(FVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FVector* internal_default_instance() {
    return reinterpret_cast<const FVector*>(
               &_FVector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FVector* other);
  friend void swap(FVector& a, FVector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FVector* New() const PROTOBUF_FINAL { return New(NULL); }

  FVector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FVector& from);
  void MergeFrom(const FVector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.FVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_the_5fpublic_2eproto::TableStruct;
  friend void ::protobuf_the_5fpublic_2eproto::InitDefaultsFVectorImpl();
};
// -------------------------------------------------------------------

class FRotator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.FRotator) */ {
 public:
  FRotator();
  virtual ~FRotator();

  FRotator(const FRotator& from);

  inline FRotator& operator=(const FRotator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FRotator(FRotator&& from) noexcept
    : FRotator() {
    *this = ::std::move(from);
  }

  inline FRotator& operator=(FRotator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FRotator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FRotator* internal_default_instance() {
    return reinterpret_cast<const FRotator*>(
               &_FRotator_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FRotator* other);
  friend void swap(FRotator& a, FRotator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FRotator* New() const PROTOBUF_FINAL { return New(NULL); }

  FRotator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FRotator& from);
  void MergeFrom(const FRotator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FRotator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:Gamedata.FRotator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float pitch_;
  float yaw_;
  float roll_;
  mutable int _cached_size_;
  friend struct ::protobuf_the_5fpublic_2eproto::TableStruct;
  friend void ::protobuf_the_5fpublic_2eproto::InitDefaultsFRotatorImpl();
};
// -------------------------------------------------------------------

class FTransform_s : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.FTransform_s) */ {
 public:
  FTransform_s();
  virtual ~FTransform_s();

  FTransform_s(const FTransform_s& from);

  inline FTransform_s& operator=(const FTransform_s& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FTransform_s(FTransform_s&& from) noexcept
    : FTransform_s() {
    *this = ::std::move(from);
  }

  inline FTransform_s& operator=(FTransform_s&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FTransform_s& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FTransform_s* internal_default_instance() {
    return reinterpret_cast<const FTransform_s*>(
               &_FTransform_s_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FTransform_s* other);
  friend void swap(FTransform_s& a, FTransform_s& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FTransform_s* New() const PROTOBUF_FINAL { return New(NULL); }

  FTransform_s* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FTransform_s& from);
  void MergeFrom(const FTransform_s& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FTransform_s* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::Gamedata::FVector& location() const;
  ::Gamedata::FVector* release_location();
  ::Gamedata::FVector* mutable_location();
  void set_allocated_location(::Gamedata::FVector* location);

  // .Gamedata.FRotator rotator = 2;
  bool has_rotator() const;
  void clear_rotator();
  static const int kRotatorFieldNumber = 2;
  const ::Gamedata::FRotator& rotator() const;
  ::Gamedata::FRotator* release_rotator();
  ::Gamedata::FRotator* mutable_rotator();
  void set_allocated_rotator(::Gamedata::FRotator* rotator);

  // @@protoc_insertion_point(class_scope:Gamedata.FTransform_s)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* location_;
  ::Gamedata::FRotator* rotator_;
  mutable int _cached_size_;
  friend struct ::protobuf_the_5fpublic_2eproto::TableStruct;
  friend void ::protobuf_the_5fpublic_2eproto::InitDefaultsFTransform_sImpl();
};
// -------------------------------------------------------------------

class FTransform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Gamedata.FTransform) */ {
 public:
  FTransform();
  virtual ~FTransform();

  FTransform(const FTransform& from);

  inline FTransform& operator=(const FTransform& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FTransform(FTransform&& from) noexcept
    : FTransform() {
    *this = ::std::move(from);
  }

  inline FTransform& operator=(FTransform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FTransform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FTransform* internal_default_instance() {
    return reinterpret_cast<const FTransform*>(
               &_FTransform_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FTransform* other);
  friend void swap(FTransform& a, FTransform& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FTransform* New() const PROTOBUF_FINAL { return New(NULL); }

  FTransform* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FTransform& from);
  void MergeFrom(const FTransform& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FTransform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Gamedata.FVector location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::Gamedata::FVector& location() const;
  ::Gamedata::FVector* release_location();
  ::Gamedata::FVector* mutable_location();
  void set_allocated_location(::Gamedata::FVector* location);

  // .Gamedata.FRotator rotator = 2;
  bool has_rotator() const;
  void clear_rotator();
  static const int kRotatorFieldNumber = 2;
  const ::Gamedata::FRotator& rotator() const;
  ::Gamedata::FRotator* release_rotator();
  ::Gamedata::FRotator* mutable_rotator();
  void set_allocated_rotator(::Gamedata::FRotator* rotator);

  // .Gamedata.FVector scale = 3;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  const ::Gamedata::FVector& scale() const;
  ::Gamedata::FVector* release_scale();
  ::Gamedata::FVector* mutable_scale();
  void set_allocated_scale(::Gamedata::FVector* scale);

  // @@protoc_insertion_point(class_scope:Gamedata.FTransform)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Gamedata::FVector* location_;
  ::Gamedata::FRotator* rotator_;
  ::Gamedata::FVector* scale_;
  mutable int _cached_size_;
  friend struct ::protobuf_the_5fpublic_2eproto::TableStruct;
  friend void ::protobuf_the_5fpublic_2eproto::InitDefaultsFTransformImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FVector

// float x = 1;
inline void FVector::clear_x() {
  x_ = 0;
}
inline float FVector::x() const {
  // @@protoc_insertion_point(field_get:Gamedata.FVector.x)
  return x_;
}
inline void FVector::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FVector.x)
}

// float y = 2;
inline void FVector::clear_y() {
  y_ = 0;
}
inline float FVector::y() const {
  // @@protoc_insertion_point(field_get:Gamedata.FVector.y)
  return y_;
}
inline void FVector::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FVector.y)
}

// float z = 3;
inline void FVector::clear_z() {
  z_ = 0;
}
inline float FVector::z() const {
  // @@protoc_insertion_point(field_get:Gamedata.FVector.z)
  return z_;
}
inline void FVector::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FVector.z)
}

// -------------------------------------------------------------------

// FRotator

// float pitch = 1;
inline void FRotator::clear_pitch() {
  pitch_ = 0;
}
inline float FRotator::pitch() const {
  // @@protoc_insertion_point(field_get:Gamedata.FRotator.pitch)
  return pitch_;
}
inline void FRotator::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FRotator.pitch)
}

// float yaw = 2;
inline void FRotator::clear_yaw() {
  yaw_ = 0;
}
inline float FRotator::yaw() const {
  // @@protoc_insertion_point(field_get:Gamedata.FRotator.yaw)
  return yaw_;
}
inline void FRotator::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FRotator.yaw)
}

// float roll = 3;
inline void FRotator::clear_roll() {
  roll_ = 0;
}
inline float FRotator::roll() const {
  // @@protoc_insertion_point(field_get:Gamedata.FRotator.roll)
  return roll_;
}
inline void FRotator::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:Gamedata.FRotator.roll)
}

// -------------------------------------------------------------------

// FTransform_s

// .Gamedata.FVector location = 1;
inline bool FTransform_s::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void FTransform_s::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::Gamedata::FVector& FTransform_s::location() const {
  const ::Gamedata::FVector* p = location_;
  // @@protoc_insertion_point(field_get:Gamedata.FTransform_s.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* FTransform_s::release_location() {
  // @@protoc_insertion_point(field_release:Gamedata.FTransform_s.location)
  
  ::Gamedata::FVector* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* FTransform_s::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.FTransform_s.location)
  return location_;
}
inline void FTransform_s::set_allocated_location(::Gamedata::FVector* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.FTransform_s.location)
}

// .Gamedata.FRotator rotator = 2;
inline bool FTransform_s::has_rotator() const {
  return this != internal_default_instance() && rotator_ != NULL;
}
inline void FTransform_s::clear_rotator() {
  if (GetArenaNoVirtual() == NULL && rotator_ != NULL) {
    delete rotator_;
  }
  rotator_ = NULL;
}
inline const ::Gamedata::FRotator& FTransform_s::rotator() const {
  const ::Gamedata::FRotator* p = rotator_;
  // @@protoc_insertion_point(field_get:Gamedata.FTransform_s.rotator)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FRotator*>(
      &::Gamedata::_FRotator_default_instance_);
}
inline ::Gamedata::FRotator* FTransform_s::release_rotator() {
  // @@protoc_insertion_point(field_release:Gamedata.FTransform_s.rotator)
  
  ::Gamedata::FRotator* temp = rotator_;
  rotator_ = NULL;
  return temp;
}
inline ::Gamedata::FRotator* FTransform_s::mutable_rotator() {
  
  if (rotator_ == NULL) {
    rotator_ = new ::Gamedata::FRotator;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.FTransform_s.rotator)
  return rotator_;
}
inline void FTransform_s::set_allocated_rotator(::Gamedata::FRotator* rotator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotator_;
  }
  if (rotator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotator, submessage_arena);
    }
    
  } else {
    
  }
  rotator_ = rotator;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.FTransform_s.rotator)
}

// -------------------------------------------------------------------

// FTransform

// .Gamedata.FVector location = 1;
inline bool FTransform::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void FTransform::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::Gamedata::FVector& FTransform::location() const {
  const ::Gamedata::FVector* p = location_;
  // @@protoc_insertion_point(field_get:Gamedata.FTransform.location)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* FTransform::release_location() {
  // @@protoc_insertion_point(field_release:Gamedata.FTransform.location)
  
  ::Gamedata::FVector* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* FTransform::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.FTransform.location)
  return location_;
}
inline void FTransform::set_allocated_location(::Gamedata::FVector* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.FTransform.location)
}

// .Gamedata.FRotator rotator = 2;
inline bool FTransform::has_rotator() const {
  return this != internal_default_instance() && rotator_ != NULL;
}
inline void FTransform::clear_rotator() {
  if (GetArenaNoVirtual() == NULL && rotator_ != NULL) {
    delete rotator_;
  }
  rotator_ = NULL;
}
inline const ::Gamedata::FRotator& FTransform::rotator() const {
  const ::Gamedata::FRotator* p = rotator_;
  // @@protoc_insertion_point(field_get:Gamedata.FTransform.rotator)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FRotator*>(
      &::Gamedata::_FRotator_default_instance_);
}
inline ::Gamedata::FRotator* FTransform::release_rotator() {
  // @@protoc_insertion_point(field_release:Gamedata.FTransform.rotator)
  
  ::Gamedata::FRotator* temp = rotator_;
  rotator_ = NULL;
  return temp;
}
inline ::Gamedata::FRotator* FTransform::mutable_rotator() {
  
  if (rotator_ == NULL) {
    rotator_ = new ::Gamedata::FRotator;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.FTransform.rotator)
  return rotator_;
}
inline void FTransform::set_allocated_rotator(::Gamedata::FRotator* rotator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotator_;
  }
  if (rotator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotator, submessage_arena);
    }
    
  } else {
    
  }
  rotator_ = rotator;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.FTransform.rotator)
}

// .Gamedata.FVector scale = 3;
inline bool FTransform::has_scale() const {
  return this != internal_default_instance() && scale_ != NULL;
}
inline void FTransform::clear_scale() {
  if (GetArenaNoVirtual() == NULL && scale_ != NULL) {
    delete scale_;
  }
  scale_ = NULL;
}
inline const ::Gamedata::FVector& FTransform::scale() const {
  const ::Gamedata::FVector* p = scale_;
  // @@protoc_insertion_point(field_get:Gamedata.FTransform.scale)
  return p != NULL ? *p : *reinterpret_cast<const ::Gamedata::FVector*>(
      &::Gamedata::_FVector_default_instance_);
}
inline ::Gamedata::FVector* FTransform::release_scale() {
  // @@protoc_insertion_point(field_release:Gamedata.FTransform.scale)
  
  ::Gamedata::FVector* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline ::Gamedata::FVector* FTransform::mutable_scale() {
  
  if (scale_ == NULL) {
    scale_ = new ::Gamedata::FVector;
  }
  // @@protoc_insertion_point(field_mutable:Gamedata.FTransform.scale)
  return scale_;
}
inline void FTransform::set_allocated_scale(::Gamedata::FVector* scale) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scale_;
  }
  if (scale) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scale = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:Gamedata.FTransform.scale)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Gamedata

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Gamedata::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Gamedata::MsgType>() {
  return ::Gamedata::MsgType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_the_5fpublic_2eproto__INCLUDED
